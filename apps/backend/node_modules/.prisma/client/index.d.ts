
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentItem
 * 
 */
export type DocumentItem = $Result.DefaultSelection<Prisma.$DocumentItemPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model Asset
 * 
 */
export type Asset = $Result.DefaultSelection<Prisma.$AssetPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model EmailAttachment
 * 
 */
export type EmailAttachment = $Result.DefaultSelection<Prisma.$EmailAttachmentPayload>
/**
 * Model EmailOutbox
 * 
 */
export type EmailOutbox = $Result.DefaultSelection<Prisma.$EmailOutboxPayload>
/**
 * Model EmailDomain
 * 
 */
export type EmailDomain = $Result.DefaultSelection<Prisma.$EmailDomainPayload>
/**
 * Model Mailbox
 * 
 */
export type Mailbox = $Result.DefaultSelection<Prisma.$MailboxPayload>
/**
 * Model EmailAlias
 * 
 */
export type EmailAlias = $Result.DefaultSelection<Prisma.$EmailAliasPayload>
/**
 * Model DomainDNS
 * 
 */
export type DomainDNS = $Result.DefaultSelection<Prisma.$DomainDNSPayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>
/**
 * Model EmailQuarantined
 * 
 */
export type EmailQuarantined = $Result.DefaultSelection<Prisma.$EmailQuarantinedPayload>
/**
 * Model EmailTemplate
 * 
 */
export type EmailTemplate = $Result.DefaultSelection<Prisma.$EmailTemplatePayload>
/**
 * Model VacationResponder
 * 
 */
export type VacationResponder = $Result.DefaultSelection<Prisma.$VacationResponderPayload>
/**
 * Model EmailTracking
 * 
 */
export type EmailTracking = $Result.DefaultSelection<Prisma.$EmailTrackingPayload>
/**
 * Model EmailTrackingEvent
 * 
 */
export type EmailTrackingEvent = $Result.DefaultSelection<Prisma.$EmailTrackingEventPayload>
/**
 * Model EmailLinkClick
 * 
 */
export type EmailLinkClick = $Result.DefaultSelection<Prisma.$EmailLinkClickPayload>
/**
 * Model MailMerge
 * 
 */
export type MailMerge = $Result.DefaultSelection<Prisma.$MailMergePayload>
/**
 * Model EmailHostingSettings
 * 
 */
export type EmailHostingSettings = $Result.DefaultSelection<Prisma.$EmailHostingSettingsPayload>
/**
 * Model MailboxAuditLog
 * 
 */
export type MailboxAuditLog = $Result.DefaultSelection<Prisma.$MailboxAuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  STAFF: 'STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DocumentType: {
  INVOICE: 'INVOICE',
  QUOTATION: 'QUOTATION',
  LETTERHEAD: 'LETTERHEAD',
  RECEIPT: 'RECEIPT'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const DocumentStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const AssetType: {
  LOGO: 'LOGO',
  DOCUMENT: 'DOCUMENT',
  IMAGE: 'IMAGE',
  OTHER: 'OTHER'
};

export type AssetType = (typeof AssetType)[keyof typeof AssetType]


export const EmailFolder: {
  INBOX: 'INBOX',
  SENT: 'SENT',
  DRAFTS: 'DRAFTS',
  TRASH: 'TRASH',
  SPAM: 'SPAM',
  ARCHIVE: 'ARCHIVE'
};

export type EmailFolder = (typeof EmailFolder)[keyof typeof EmailFolder]


export const OutboxStatus: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type OutboxStatus = (typeof OutboxStatus)[keyof typeof OutboxStatus]


export const DNSRecordType: {
  MX: 'MX',
  TXT: 'TXT',
  CNAME: 'CNAME',
  A: 'A',
  AAAA: 'AAAA',
  SRV: 'SRV'
};

export type DNSRecordType = (typeof DNSRecordType)[keyof typeof DNSRecordType]


export const EmailLogStatus: {
  QUEUED: 'QUEUED',
  SENDING: 'SENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  BOUNCED: 'BOUNCED',
  REJECTED: 'REJECTED',
  SPAM: 'SPAM',
  FAILED: 'FAILED'
};

export type EmailLogStatus = (typeof EmailLogStatus)[keyof typeof EmailLogStatus]


export const EmailTemplateCategory: {
  GENERAL: 'GENERAL',
  SALES: 'SALES',
  SUPPORT: 'SUPPORT',
  MARKETING: 'MARKETING',
  HR: 'HR',
  FINANCE: 'FINANCE',
  FOLLOW_UP: 'FOLLOW_UP',
  MEETING: 'MEETING',
  INTRODUCTION: 'INTRODUCTION',
  THANK_YOU: 'THANK_YOU'
};

export type EmailTemplateCategory = (typeof EmailTemplateCategory)[keyof typeof EmailTemplateCategory]


export const MailMergeStatus: {
  DRAFT: 'DRAFT',
  SCHEDULED: 'SCHEDULED',
  SENDING: 'SENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type MailMergeStatus = (typeof MailMergeStatus)[keyof typeof MailMergeStatus]


export const MailboxAuditAction: {
  MAILBOX_CREATED: 'MAILBOX_CREATED',
  MAILBOX_UPDATED: 'MAILBOX_UPDATED',
  MAILBOX_DELETED: 'MAILBOX_DELETED',
  MAILBOX_LINKED_TO_USER: 'MAILBOX_LINKED_TO_USER',
  MAILBOX_UNLINKED_FROM_USER: 'MAILBOX_UNLINKED_FROM_USER',
  MAILBOX_PASSWORD_CHANGED: 'MAILBOX_PASSWORD_CHANGED',
  MAILBOX_QUOTA_CHANGED: 'MAILBOX_QUOTA_CHANGED',
  MAILBOX_ACTIVATED: 'MAILBOX_ACTIVATED',
  MAILBOX_DEACTIVATED: 'MAILBOX_DEACTIVATED',
  USER_PROVISIONED_MAILBOX: 'USER_PROVISIONED_MAILBOX',
  BULK_IMPORT_STARTED: 'BULK_IMPORT_STARTED',
  BULK_IMPORT_COMPLETED: 'BULK_IMPORT_COMPLETED',
  DOMAIN_SETTINGS_CHANGED: 'DOMAIN_SETTINGS_CHANGED'
};

export type MailboxAuditAction = (typeof MailboxAuditAction)[keyof typeof MailboxAuditAction]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type AssetType = $Enums.AssetType

export const AssetType: typeof $Enums.AssetType

export type EmailFolder = $Enums.EmailFolder

export const EmailFolder: typeof $Enums.EmailFolder

export type OutboxStatus = $Enums.OutboxStatus

export const OutboxStatus: typeof $Enums.OutboxStatus

export type DNSRecordType = $Enums.DNSRecordType

export const DNSRecordType: typeof $Enums.DNSRecordType

export type EmailLogStatus = $Enums.EmailLogStatus

export const EmailLogStatus: typeof $Enums.EmailLogStatus

export type EmailTemplateCategory = $Enums.EmailTemplateCategory

export const EmailTemplateCategory: typeof $Enums.EmailTemplateCategory

export type MailMergeStatus = $Enums.MailMergeStatus

export const MailMergeStatus: typeof $Enums.MailMergeStatus

export type MailboxAuditAction = $Enums.MailboxAuditAction

export const MailboxAuditAction: typeof $Enums.MailboxAuditAction

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.documentItem`: Exposes CRUD operations for the **DocumentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentItems
    * const documentItems = await prisma.documentItem.findMany()
    * ```
    */
  get documentItem(): Prisma.DocumentItemDelegate<ExtArgs>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs>;

  /**
   * `prisma.asset`: Exposes CRUD operations for the **Asset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.asset.findMany()
    * ```
    */
  get asset(): Prisma.AssetDelegate<ExtArgs>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs>;

  /**
   * `prisma.emailAttachment`: Exposes CRUD operations for the **EmailAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAttachments
    * const emailAttachments = await prisma.emailAttachment.findMany()
    * ```
    */
  get emailAttachment(): Prisma.EmailAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.emailOutbox`: Exposes CRUD operations for the **EmailOutbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailOutboxes
    * const emailOutboxes = await prisma.emailOutbox.findMany()
    * ```
    */
  get emailOutbox(): Prisma.EmailOutboxDelegate<ExtArgs>;

  /**
   * `prisma.emailDomain`: Exposes CRUD operations for the **EmailDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailDomains
    * const emailDomains = await prisma.emailDomain.findMany()
    * ```
    */
  get emailDomain(): Prisma.EmailDomainDelegate<ExtArgs>;

  /**
   * `prisma.mailbox`: Exposes CRUD operations for the **Mailbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mailboxes
    * const mailboxes = await prisma.mailbox.findMany()
    * ```
    */
  get mailbox(): Prisma.MailboxDelegate<ExtArgs>;

  /**
   * `prisma.emailAlias`: Exposes CRUD operations for the **EmailAlias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAliases
    * const emailAliases = await prisma.emailAlias.findMany()
    * ```
    */
  get emailAlias(): Prisma.EmailAliasDelegate<ExtArgs>;

  /**
   * `prisma.domainDNS`: Exposes CRUD operations for the **DomainDNS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainDNS
    * const domainDNS = await prisma.domainDNS.findMany()
    * ```
    */
  get domainDNS(): Prisma.DomainDNSDelegate<ExtArgs>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs>;

  /**
   * `prisma.emailQuarantined`: Exposes CRUD operations for the **EmailQuarantined** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailQuarantineds
    * const emailQuarantineds = await prisma.emailQuarantined.findMany()
    * ```
    */
  get emailQuarantined(): Prisma.EmailQuarantinedDelegate<ExtArgs>;

  /**
   * `prisma.emailTemplate`: Exposes CRUD operations for the **EmailTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTemplates
    * const emailTemplates = await prisma.emailTemplate.findMany()
    * ```
    */
  get emailTemplate(): Prisma.EmailTemplateDelegate<ExtArgs>;

  /**
   * `prisma.vacationResponder`: Exposes CRUD operations for the **VacationResponder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VacationResponders
    * const vacationResponders = await prisma.vacationResponder.findMany()
    * ```
    */
  get vacationResponder(): Prisma.VacationResponderDelegate<ExtArgs>;

  /**
   * `prisma.emailTracking`: Exposes CRUD operations for the **EmailTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTrackings
    * const emailTrackings = await prisma.emailTracking.findMany()
    * ```
    */
  get emailTracking(): Prisma.EmailTrackingDelegate<ExtArgs>;

  /**
   * `prisma.emailTrackingEvent`: Exposes CRUD operations for the **EmailTrackingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTrackingEvents
    * const emailTrackingEvents = await prisma.emailTrackingEvent.findMany()
    * ```
    */
  get emailTrackingEvent(): Prisma.EmailTrackingEventDelegate<ExtArgs>;

  /**
   * `prisma.emailLinkClick`: Exposes CRUD operations for the **EmailLinkClick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLinkClicks
    * const emailLinkClicks = await prisma.emailLinkClick.findMany()
    * ```
    */
  get emailLinkClick(): Prisma.EmailLinkClickDelegate<ExtArgs>;

  /**
   * `prisma.mailMerge`: Exposes CRUD operations for the **MailMerge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MailMerges
    * const mailMerges = await prisma.mailMerge.findMany()
    * ```
    */
  get mailMerge(): Prisma.MailMergeDelegate<ExtArgs>;

  /**
   * `prisma.emailHostingSettings`: Exposes CRUD operations for the **EmailHostingSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailHostingSettings
    * const emailHostingSettings = await prisma.emailHostingSettings.findMany()
    * ```
    */
  get emailHostingSettings(): Prisma.EmailHostingSettingsDelegate<ExtArgs>;

  /**
   * `prisma.mailboxAuditLog`: Exposes CRUD operations for the **MailboxAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MailboxAuditLogs
    * const mailboxAuditLogs = await prisma.mailboxAuditLog.findMany()
    * ```
    */
  get mailboxAuditLog(): Prisma.MailboxAuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.10.2
   * Query Engine version: 5a9203d0590c951969e85a7d07215503f4672eb9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Company: 'Company',
    Client: 'Client',
    Document: 'Document',
    DocumentItem: 'DocumentItem',
    Template: 'Template',
    Asset: 'Asset',
    Email: 'Email',
    EmailAttachment: 'EmailAttachment',
    EmailOutbox: 'EmailOutbox',
    EmailDomain: 'EmailDomain',
    Mailbox: 'Mailbox',
    EmailAlias: 'EmailAlias',
    DomainDNS: 'DomainDNS',
    EmailLog: 'EmailLog',
    EmailQuarantined: 'EmailQuarantined',
    EmailTemplate: 'EmailTemplate',
    VacationResponder: 'VacationResponder',
    EmailTracking: 'EmailTracking',
    EmailTrackingEvent: 'EmailTrackingEvent',
    EmailLinkClick: 'EmailLinkClick',
    MailMerge: 'MailMerge',
    EmailHostingSettings: 'EmailHostingSettings',
    MailboxAuditLog: 'MailboxAuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'company' | 'client' | 'document' | 'documentItem' | 'template' | 'asset' | 'email' | 'emailAttachment' | 'emailOutbox' | 'emailDomain' | 'mailbox' | 'emailAlias' | 'domainDNS' | 'emailLog' | 'emailQuarantined' | 'emailTemplate' | 'vacationResponder' | 'emailTracking' | 'emailTrackingEvent' | 'emailLinkClick' | 'mailMerge' | 'emailHostingSettings' | 'mailboxAuditLog'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentItem: {
        payload: Prisma.$DocumentItemPayload<ExtArgs>
        fields: Prisma.DocumentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentItemFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentItemFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>
          }
          findFirst: {
            args: Prisma.DocumentItemFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentItemFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>
          }
          findMany: {
            args: Prisma.DocumentItemFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>[]
          }
          create: {
            args: Prisma.DocumentItemCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>
          }
          createMany: {
            args: Prisma.DocumentItemCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentItemDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>
          }
          update: {
            args: Prisma.DocumentItemUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>
          }
          deleteMany: {
            args: Prisma.DocumentItemDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentItemUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentItemUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentItemPayload>
          }
          aggregate: {
            args: Prisma.DocumentItemAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocumentItem>
          }
          groupBy: {
            args: Prisma.DocumentItemGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentItemCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentItemCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      Asset: {
        payload: Prisma.$AssetPayload<ExtArgs>
        fields: Prisma.AssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findFirst: {
            args: Prisma.AssetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          findMany: {
            args: Prisma.AssetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>[]
          }
          create: {
            args: Prisma.AssetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          createMany: {
            args: Prisma.AssetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AssetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          update: {
            args: Prisma.AssetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          deleteMany: {
            args: Prisma.AssetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AssetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AssetPayload>
          }
          aggregate: {
            args: Prisma.AssetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAsset>
          }
          groupBy: {
            args: Prisma.AssetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetCountArgs<ExtArgs>,
            result: $Utils.Optional<AssetCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      EmailAttachment: {
        payload: Prisma.$EmailAttachmentPayload<ExtArgs>
        fields: Prisma.EmailAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAttachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          findFirst: {
            args: Prisma.EmailAttachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAttachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          findMany: {
            args: Prisma.EmailAttachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>[]
          }
          create: {
            args: Prisma.EmailAttachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          createMany: {
            args: Prisma.EmailAttachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailAttachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          update: {
            args: Prisma.EmailAttachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.EmailAttachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAttachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailAttachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAttachmentPayload>
          }
          aggregate: {
            args: Prisma.EmailAttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailAttachment>
          }
          groupBy: {
            args: Prisma.EmailAttachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAttachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailAttachmentCountAggregateOutputType> | number
          }
        }
      }
      EmailOutbox: {
        payload: Prisma.$EmailOutboxPayload<ExtArgs>
        fields: Prisma.EmailOutboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailOutboxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailOutboxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>
          }
          findFirst: {
            args: Prisma.EmailOutboxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailOutboxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>
          }
          findMany: {
            args: Prisma.EmailOutboxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>[]
          }
          create: {
            args: Prisma.EmailOutboxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>
          }
          createMany: {
            args: Prisma.EmailOutboxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailOutboxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>
          }
          update: {
            args: Prisma.EmailOutboxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>
          }
          deleteMany: {
            args: Prisma.EmailOutboxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailOutboxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailOutboxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailOutboxPayload>
          }
          aggregate: {
            args: Prisma.EmailOutboxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailOutbox>
          }
          groupBy: {
            args: Prisma.EmailOutboxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailOutboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailOutboxCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailOutboxCountAggregateOutputType> | number
          }
        }
      }
      EmailDomain: {
        payload: Prisma.$EmailDomainPayload<ExtArgs>
        fields: Prisma.EmailDomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailDomainFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailDomainFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>
          }
          findFirst: {
            args: Prisma.EmailDomainFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailDomainFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>
          }
          findMany: {
            args: Prisma.EmailDomainFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>[]
          }
          create: {
            args: Prisma.EmailDomainCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>
          }
          createMany: {
            args: Prisma.EmailDomainCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailDomainDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>
          }
          update: {
            args: Prisma.EmailDomainUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>
          }
          deleteMany: {
            args: Prisma.EmailDomainDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailDomainUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailDomainUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailDomainPayload>
          }
          aggregate: {
            args: Prisma.EmailDomainAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailDomain>
          }
          groupBy: {
            args: Prisma.EmailDomainGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailDomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailDomainCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailDomainCountAggregateOutputType> | number
          }
        }
      }
      Mailbox: {
        payload: Prisma.$MailboxPayload<ExtArgs>
        fields: Prisma.MailboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailboxFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailboxFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>
          }
          findFirst: {
            args: Prisma.MailboxFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailboxFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>
          }
          findMany: {
            args: Prisma.MailboxFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>[]
          }
          create: {
            args: Prisma.MailboxCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>
          }
          createMany: {
            args: Prisma.MailboxCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MailboxDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>
          }
          update: {
            args: Prisma.MailboxUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>
          }
          deleteMany: {
            args: Prisma.MailboxDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MailboxUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MailboxUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxPayload>
          }
          aggregate: {
            args: Prisma.MailboxAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMailbox>
          }
          groupBy: {
            args: Prisma.MailboxGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MailboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailboxCountArgs<ExtArgs>,
            result: $Utils.Optional<MailboxCountAggregateOutputType> | number
          }
        }
      }
      EmailAlias: {
        payload: Prisma.$EmailAliasPayload<ExtArgs>
        fields: Prisma.EmailAliasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAliasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAliasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>
          }
          findFirst: {
            args: Prisma.EmailAliasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAliasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>
          }
          findMany: {
            args: Prisma.EmailAliasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>[]
          }
          create: {
            args: Prisma.EmailAliasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>
          }
          createMany: {
            args: Prisma.EmailAliasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailAliasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>
          }
          update: {
            args: Prisma.EmailAliasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>
          }
          deleteMany: {
            args: Prisma.EmailAliasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAliasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailAliasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailAliasPayload>
          }
          aggregate: {
            args: Prisma.EmailAliasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailAlias>
          }
          groupBy: {
            args: Prisma.EmailAliasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailAliasGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAliasCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailAliasCountAggregateOutputType> | number
          }
        }
      }
      DomainDNS: {
        payload: Prisma.$DomainDNSPayload<ExtArgs>
        fields: Prisma.DomainDNSFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainDNSFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainDNSFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>
          }
          findFirst: {
            args: Prisma.DomainDNSFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainDNSFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>
          }
          findMany: {
            args: Prisma.DomainDNSFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>[]
          }
          create: {
            args: Prisma.DomainDNSCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>
          }
          createMany: {
            args: Prisma.DomainDNSCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DomainDNSDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>
          }
          update: {
            args: Prisma.DomainDNSUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>
          }
          deleteMany: {
            args: Prisma.DomainDNSDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DomainDNSUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DomainDNSUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DomainDNSPayload>
          }
          aggregate: {
            args: Prisma.DomainDNSAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDomainDNS>
          }
          groupBy: {
            args: Prisma.DomainDNSGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DomainDNSGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainDNSCountArgs<ExtArgs>,
            result: $Utils.Optional<DomainDNSCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
      EmailQuarantined: {
        payload: Prisma.$EmailQuarantinedPayload<ExtArgs>
        fields: Prisma.EmailQuarantinedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailQuarantinedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailQuarantinedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>
          }
          findFirst: {
            args: Prisma.EmailQuarantinedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailQuarantinedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>
          }
          findMany: {
            args: Prisma.EmailQuarantinedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>[]
          }
          create: {
            args: Prisma.EmailQuarantinedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>
          }
          createMany: {
            args: Prisma.EmailQuarantinedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailQuarantinedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>
          }
          update: {
            args: Prisma.EmailQuarantinedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>
          }
          deleteMany: {
            args: Prisma.EmailQuarantinedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailQuarantinedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailQuarantinedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailQuarantinedPayload>
          }
          aggregate: {
            args: Prisma.EmailQuarantinedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailQuarantined>
          }
          groupBy: {
            args: Prisma.EmailQuarantinedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailQuarantinedGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailQuarantinedCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailQuarantinedCountAggregateOutputType> | number
          }
        }
      }
      EmailTemplate: {
        payload: Prisma.$EmailTemplatePayload<ExtArgs>
        fields: Prisma.EmailTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findFirst: {
            args: Prisma.EmailTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          findMany: {
            args: Prisma.EmailTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>[]
          }
          create: {
            args: Prisma.EmailTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          createMany: {
            args: Prisma.EmailTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          update: {
            args: Prisma.EmailTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          deleteMany: {
            args: Prisma.EmailTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTemplatePayload>
          }
          aggregate: {
            args: Prisma.EmailTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailTemplate>
          }
          groupBy: {
            args: Prisma.EmailTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailTemplateCountAggregateOutputType> | number
          }
        }
      }
      VacationResponder: {
        payload: Prisma.$VacationResponderPayload<ExtArgs>
        fields: Prisma.VacationResponderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VacationResponderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VacationResponderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>
          }
          findFirst: {
            args: Prisma.VacationResponderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VacationResponderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>
          }
          findMany: {
            args: Prisma.VacationResponderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>[]
          }
          create: {
            args: Prisma.VacationResponderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>
          }
          createMany: {
            args: Prisma.VacationResponderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VacationResponderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>
          }
          update: {
            args: Prisma.VacationResponderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>
          }
          deleteMany: {
            args: Prisma.VacationResponderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VacationResponderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VacationResponderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VacationResponderPayload>
          }
          aggregate: {
            args: Prisma.VacationResponderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVacationResponder>
          }
          groupBy: {
            args: Prisma.VacationResponderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VacationResponderGroupByOutputType>[]
          }
          count: {
            args: Prisma.VacationResponderCountArgs<ExtArgs>,
            result: $Utils.Optional<VacationResponderCountAggregateOutputType> | number
          }
        }
      }
      EmailTracking: {
        payload: Prisma.$EmailTrackingPayload<ExtArgs>
        fields: Prisma.EmailTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTrackingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTrackingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          findFirst: {
            args: Prisma.EmailTrackingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTrackingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          findMany: {
            args: Prisma.EmailTrackingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>[]
          }
          create: {
            args: Prisma.EmailTrackingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          createMany: {
            args: Prisma.EmailTrackingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailTrackingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          update: {
            args: Prisma.EmailTrackingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          deleteMany: {
            args: Prisma.EmailTrackingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTrackingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailTrackingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingPayload>
          }
          aggregate: {
            args: Prisma.EmailTrackingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailTracking>
          }
          groupBy: {
            args: Prisma.EmailTrackingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTrackingCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailTrackingCountAggregateOutputType> | number
          }
        }
      }
      EmailTrackingEvent: {
        payload: Prisma.$EmailTrackingEventPayload<ExtArgs>
        fields: Prisma.EmailTrackingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTrackingEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTrackingEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>
          }
          findFirst: {
            args: Prisma.EmailTrackingEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTrackingEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>
          }
          findMany: {
            args: Prisma.EmailTrackingEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>[]
          }
          create: {
            args: Prisma.EmailTrackingEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>
          }
          createMany: {
            args: Prisma.EmailTrackingEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailTrackingEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>
          }
          update: {
            args: Prisma.EmailTrackingEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>
          }
          deleteMany: {
            args: Prisma.EmailTrackingEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTrackingEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailTrackingEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailTrackingEventPayload>
          }
          aggregate: {
            args: Prisma.EmailTrackingEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailTrackingEvent>
          }
          groupBy: {
            args: Prisma.EmailTrackingEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailTrackingEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTrackingEventCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailTrackingEventCountAggregateOutputType> | number
          }
        }
      }
      EmailLinkClick: {
        payload: Prisma.$EmailLinkClickPayload<ExtArgs>
        fields: Prisma.EmailLinkClickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLinkClickFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLinkClickFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>
          }
          findFirst: {
            args: Prisma.EmailLinkClickFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLinkClickFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>
          }
          findMany: {
            args: Prisma.EmailLinkClickFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>[]
          }
          create: {
            args: Prisma.EmailLinkClickCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>
          }
          createMany: {
            args: Prisma.EmailLinkClickCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailLinkClickDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>
          }
          update: {
            args: Prisma.EmailLinkClickUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>
          }
          deleteMany: {
            args: Prisma.EmailLinkClickDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLinkClickUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailLinkClickUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailLinkClickPayload>
          }
          aggregate: {
            args: Prisma.EmailLinkClickAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailLinkClick>
          }
          groupBy: {
            args: Prisma.EmailLinkClickGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailLinkClickGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLinkClickCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailLinkClickCountAggregateOutputType> | number
          }
        }
      }
      MailMerge: {
        payload: Prisma.$MailMergePayload<ExtArgs>
        fields: Prisma.MailMergeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailMergeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailMergeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>
          }
          findFirst: {
            args: Prisma.MailMergeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailMergeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>
          }
          findMany: {
            args: Prisma.MailMergeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>[]
          }
          create: {
            args: Prisma.MailMergeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>
          }
          createMany: {
            args: Prisma.MailMergeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MailMergeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>
          }
          update: {
            args: Prisma.MailMergeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>
          }
          deleteMany: {
            args: Prisma.MailMergeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MailMergeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MailMergeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailMergePayload>
          }
          aggregate: {
            args: Prisma.MailMergeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMailMerge>
          }
          groupBy: {
            args: Prisma.MailMergeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MailMergeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailMergeCountArgs<ExtArgs>,
            result: $Utils.Optional<MailMergeCountAggregateOutputType> | number
          }
        }
      }
      EmailHostingSettings: {
        payload: Prisma.$EmailHostingSettingsPayload<ExtArgs>
        fields: Prisma.EmailHostingSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailHostingSettingsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailHostingSettingsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>
          }
          findFirst: {
            args: Prisma.EmailHostingSettingsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailHostingSettingsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>
          }
          findMany: {
            args: Prisma.EmailHostingSettingsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>[]
          }
          create: {
            args: Prisma.EmailHostingSettingsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>
          }
          createMany: {
            args: Prisma.EmailHostingSettingsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailHostingSettingsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>
          }
          update: {
            args: Prisma.EmailHostingSettingsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>
          }
          deleteMany: {
            args: Prisma.EmailHostingSettingsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailHostingSettingsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailHostingSettingsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailHostingSettingsPayload>
          }
          aggregate: {
            args: Prisma.EmailHostingSettingsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailHostingSettings>
          }
          groupBy: {
            args: Prisma.EmailHostingSettingsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailHostingSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailHostingSettingsCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailHostingSettingsCountAggregateOutputType> | number
          }
        }
      }
      MailboxAuditLog: {
        payload: Prisma.$MailboxAuditLogPayload<ExtArgs>
        fields: Prisma.MailboxAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MailboxAuditLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MailboxAuditLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>
          }
          findFirst: {
            args: Prisma.MailboxAuditLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MailboxAuditLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>
          }
          findMany: {
            args: Prisma.MailboxAuditLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>[]
          }
          create: {
            args: Prisma.MailboxAuditLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>
          }
          createMany: {
            args: Prisma.MailboxAuditLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MailboxAuditLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>
          }
          update: {
            args: Prisma.MailboxAuditLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.MailboxAuditLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MailboxAuditLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MailboxAuditLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MailboxAuditLogPayload>
          }
          aggregate: {
            args: Prisma.MailboxAuditLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMailboxAuditLog>
          }
          groupBy: {
            args: Prisma.MailboxAuditLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MailboxAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MailboxAuditLogCountArgs<ExtArgs>,
            result: $Utils.Optional<MailboxAuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    mailboxes: number
    createdDocuments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailboxes?: boolean | UserCountOutputTypeCountMailboxesArgs
    createdDocuments?: boolean | UserCountOutputTypeCountCreatedDocumentsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMailboxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailboxWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    users: number
    documents: number
    clients: number
    templates: number
    assets: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    documents?: boolean | CompanyCountOutputTypeCountDocumentsArgs
    clients?: boolean | CompanyCountOutputTypeCountClientsArgs
    templates?: boolean | CompanyCountOutputTypeCountTemplatesArgs
    assets?: boolean | CompanyCountOutputTypeCountAssetsArgs
  }

  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
  }



  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    documents: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ClientCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }



  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    items: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | DocumentCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentItemWhereInput
  }



  /**
   * Count Type EmailCountOutputType
   */

  export type EmailCountOutputType = {
    attachments: number
  }

  export type EmailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | EmailCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCountOutputType
     */
    select?: EmailCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAttachmentWhereInput
  }



  /**
   * Count Type EmailDomainCountOutputType
   */

  export type EmailDomainCountOutputType = {
    mailboxes: number
    aliases: number
    dnsRecords: number
  }

  export type EmailDomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailboxes?: boolean | EmailDomainCountOutputTypeCountMailboxesArgs
    aliases?: boolean | EmailDomainCountOutputTypeCountAliasesArgs
    dnsRecords?: boolean | EmailDomainCountOutputTypeCountDnsRecordsArgs
  }

  // Custom InputTypes

  /**
   * EmailDomainCountOutputType without action
   */
  export type EmailDomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomainCountOutputType
     */
    select?: EmailDomainCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailDomainCountOutputType without action
   */
  export type EmailDomainCountOutputTypeCountMailboxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailboxWhereInput
  }


  /**
   * EmailDomainCountOutputType without action
   */
  export type EmailDomainCountOutputTypeCountAliasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAliasWhereInput
  }


  /**
   * EmailDomainCountOutputType without action
   */
  export type EmailDomainCountOutputTypeCountDnsRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainDNSWhereInput
  }



  /**
   * Count Type MailboxCountOutputType
   */

  export type MailboxCountOutputType = {
    targetAliases: number
  }

  export type MailboxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetAliases?: boolean | MailboxCountOutputTypeCountTargetAliasesArgs
  }

  // Custom InputTypes

  /**
   * MailboxCountOutputType without action
   */
  export type MailboxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxCountOutputType
     */
    select?: MailboxCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MailboxCountOutputType without action
   */
  export type MailboxCountOutputTypeCountTargetAliasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAliasWhereInput
  }



  /**
   * Count Type EmailTrackingCountOutputType
   */

  export type EmailTrackingCountOutputType = {
    opens: number
    clicks: number
  }

  export type EmailTrackingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opens?: boolean | EmailTrackingCountOutputTypeCountOpensArgs
    clicks?: boolean | EmailTrackingCountOutputTypeCountClicksArgs
  }

  // Custom InputTypes

  /**
   * EmailTrackingCountOutputType without action
   */
  export type EmailTrackingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingCountOutputType
     */
    select?: EmailTrackingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailTrackingCountOutputType without action
   */
  export type EmailTrackingCountOutputTypeCountOpensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTrackingEventWhereInput
  }


  /**
   * EmailTrackingCountOutputType without action
   */
  export type EmailTrackingCountOutputTypeCountClicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLinkClickWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    jobTitle: string | null
    phone: string | null
    avatarUrl: string | null
    isActive: boolean | null
    signatureEnabled: boolean | null
    signatureStyle: string | null
    signatureHtml: string | null
    linkedinUrl: string | null
    twitterUrl: string | null
    instagramUrl: string | null
    location: string | null
    officeAddress: string | null
    mailPassword: string | null
    totpSecret: string | null
    totpEnabled: boolean | null
    totpLastUsed: Date | null
    ssoProvider: string | null
    ssoExternalId: string | null
    lastSsoLogin: Date | null
    primaryMailboxId: string | null
    autoProvisionEmail: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    jobTitle: string | null
    phone: string | null
    avatarUrl: string | null
    isActive: boolean | null
    signatureEnabled: boolean | null
    signatureStyle: string | null
    signatureHtml: string | null
    linkedinUrl: string | null
    twitterUrl: string | null
    instagramUrl: string | null
    location: string | null
    officeAddress: string | null
    mailPassword: string | null
    totpSecret: string | null
    totpEnabled: boolean | null
    totpLastUsed: Date | null
    ssoProvider: string | null
    ssoExternalId: string | null
    lastSsoLogin: Date | null
    primaryMailboxId: string | null
    autoProvisionEmail: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    jobTitle: number
    phone: number
    avatarUrl: number
    isActive: number
    signatureEnabled: number
    signatureStyle: number
    signatureHtml: number
    linkedinUrl: number
    twitterUrl: number
    instagramUrl: number
    location: number
    officeAddress: number
    mailPassword: number
    totpSecret: number
    totpEnabled: number
    totpBackupCodes: number
    totpLastUsed: number
    ssoProvider: number
    ssoExternalId: number
    lastSsoLogin: number
    primaryMailboxId: number
    autoProvisionEmail: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    jobTitle?: true
    phone?: true
    avatarUrl?: true
    isActive?: true
    signatureEnabled?: true
    signatureStyle?: true
    signatureHtml?: true
    linkedinUrl?: true
    twitterUrl?: true
    instagramUrl?: true
    location?: true
    officeAddress?: true
    mailPassword?: true
    totpSecret?: true
    totpEnabled?: true
    totpLastUsed?: true
    ssoProvider?: true
    ssoExternalId?: true
    lastSsoLogin?: true
    primaryMailboxId?: true
    autoProvisionEmail?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    jobTitle?: true
    phone?: true
    avatarUrl?: true
    isActive?: true
    signatureEnabled?: true
    signatureStyle?: true
    signatureHtml?: true
    linkedinUrl?: true
    twitterUrl?: true
    instagramUrl?: true
    location?: true
    officeAddress?: true
    mailPassword?: true
    totpSecret?: true
    totpEnabled?: true
    totpLastUsed?: true
    ssoProvider?: true
    ssoExternalId?: true
    lastSsoLogin?: true
    primaryMailboxId?: true
    autoProvisionEmail?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    jobTitle?: true
    phone?: true
    avatarUrl?: true
    isActive?: true
    signatureEnabled?: true
    signatureStyle?: true
    signatureHtml?: true
    linkedinUrl?: true
    twitterUrl?: true
    instagramUrl?: true
    location?: true
    officeAddress?: true
    mailPassword?: true
    totpSecret?: true
    totpEnabled?: true
    totpBackupCodes?: true
    totpLastUsed?: true
    ssoProvider?: true
    ssoExternalId?: true
    lastSsoLogin?: true
    primaryMailboxId?: true
    autoProvisionEmail?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    jobTitle: string | null
    phone: string | null
    avatarUrl: string | null
    isActive: boolean
    signatureEnabled: boolean
    signatureStyle: string
    signatureHtml: string | null
    linkedinUrl: string | null
    twitterUrl: string | null
    instagramUrl: string | null
    location: string | null
    officeAddress: string | null
    mailPassword: string | null
    totpSecret: string | null
    totpEnabled: boolean
    totpBackupCodes: string[]
    totpLastUsed: Date | null
    ssoProvider: string | null
    ssoExternalId: string | null
    lastSsoLogin: Date | null
    primaryMailboxId: string | null
    autoProvisionEmail: boolean
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    jobTitle?: boolean
    phone?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: boolean
    signatureHtml?: boolean
    linkedinUrl?: boolean
    twitterUrl?: boolean
    instagramUrl?: boolean
    location?: boolean
    officeAddress?: boolean
    mailPassword?: boolean
    totpSecret?: boolean
    totpEnabled?: boolean
    totpBackupCodes?: boolean
    totpLastUsed?: boolean
    ssoProvider?: boolean
    ssoExternalId?: boolean
    lastSsoLogin?: boolean
    primaryMailboxId?: boolean
    autoProvisionEmail?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mailboxes?: boolean | User$mailboxesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdDocuments?: boolean | User$createdDocumentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    jobTitle?: boolean
    phone?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: boolean
    signatureHtml?: boolean
    linkedinUrl?: boolean
    twitterUrl?: boolean
    instagramUrl?: boolean
    location?: boolean
    officeAddress?: boolean
    mailPassword?: boolean
    totpSecret?: boolean
    totpEnabled?: boolean
    totpBackupCodes?: boolean
    totpLastUsed?: boolean
    ssoProvider?: boolean
    ssoExternalId?: boolean
    lastSsoLogin?: boolean
    primaryMailboxId?: boolean
    autoProvisionEmail?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailboxes?: boolean | User$mailboxesArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    createdDocuments?: boolean | User$createdDocumentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      mailboxes: Prisma.$MailboxPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
      createdDocuments: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      jobTitle: string | null
      phone: string | null
      avatarUrl: string | null
      isActive: boolean
      signatureEnabled: boolean
      signatureStyle: string
      signatureHtml: string | null
      linkedinUrl: string | null
      twitterUrl: string | null
      instagramUrl: string | null
      location: string | null
      officeAddress: string | null
      mailPassword: string | null
      totpSecret: string | null
      totpEnabled: boolean
      totpBackupCodes: string[]
      totpLastUsed: Date | null
      ssoProvider: string | null
      ssoExternalId: string | null
      lastSsoLogin: Date | null
      primaryMailboxId: string | null
      autoProvisionEmail: boolean
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mailboxes<T extends User$mailboxesArgs<ExtArgs> = {}>(args?: Subset<T, User$mailboxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findMany'> | Null>;

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    createdDocuments<T extends User$createdDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly jobTitle: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly signatureEnabled: FieldRef<"User", 'Boolean'>
    readonly signatureStyle: FieldRef<"User", 'String'>
    readonly signatureHtml: FieldRef<"User", 'String'>
    readonly linkedinUrl: FieldRef<"User", 'String'>
    readonly twitterUrl: FieldRef<"User", 'String'>
    readonly instagramUrl: FieldRef<"User", 'String'>
    readonly location: FieldRef<"User", 'String'>
    readonly officeAddress: FieldRef<"User", 'String'>
    readonly mailPassword: FieldRef<"User", 'String'>
    readonly totpSecret: FieldRef<"User", 'String'>
    readonly totpEnabled: FieldRef<"User", 'Boolean'>
    readonly totpBackupCodes: FieldRef<"User", 'String[]'>
    readonly totpLastUsed: FieldRef<"User", 'DateTime'>
    readonly ssoProvider: FieldRef<"User", 'String'>
    readonly ssoExternalId: FieldRef<"User", 'String'>
    readonly lastSsoLogin: FieldRef<"User", 'DateTime'>
    readonly primaryMailboxId: FieldRef<"User", 'String'>
    readonly autoProvisionEmail: FieldRef<"User", 'Boolean'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.mailboxes
   */
  export type User$mailboxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    where?: MailboxWhereInput
    orderBy?: MailboxOrderByWithRelationInput | MailboxOrderByWithRelationInput[]
    cursor?: MailboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailboxScalarFieldEnum | MailboxScalarFieldEnum[]
  }


  /**
   * User.createdDocuments
   */
  export type User$createdDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    tagline: string | null
    email: string | null
    phone: string | null
    website: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    taxId: string | null
    registrationNo: string | null
    bankName: string | null
    bankAccount: string | null
    bankBranch: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    tagline: string | null
    email: string | null
    phone: string | null
    website: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    country: string | null
    postalCode: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    taxId: string | null
    registrationNo: string | null
    bankName: string | null
    bankAccount: string | null
    bankBranch: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    tagline: number
    email: number
    phone: number
    website: number
    addressLine1: number
    addressLine2: number
    city: number
    country: number
    postalCode: number
    logoUrl: number
    primaryColor: number
    secondaryColor: number
    taxId: number
    registrationNo: number
    bankName: number
    bankAccount: number
    bankBranch: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    email?: true
    phone?: true
    website?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    country?: true
    postalCode?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    taxId?: true
    registrationNo?: true
    bankName?: true
    bankAccount?: true
    bankBranch?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    email?: true
    phone?: true
    website?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    country?: true
    postalCode?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    taxId?: true
    registrationNo?: true
    bankName?: true
    bankAccount?: true
    bankBranch?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    tagline?: true
    email?: true
    phone?: true
    website?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    country?: true
    postalCode?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    taxId?: true
    registrationNo?: true
    bankName?: true
    bankAccount?: true
    bankBranch?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    tagline: string | null
    email: string
    phone: string
    website: string | null
    addressLine1: string
    addressLine2: string | null
    city: string
    country: string
    postalCode: string | null
    logoUrl: string | null
    primaryColor: string
    secondaryColor: string
    taxId: string | null
    registrationNo: string | null
    bankName: string | null
    bankAccount: string | null
    bankBranch: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tagline?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    taxId?: boolean
    registrationNo?: boolean
    bankName?: boolean
    bankAccount?: boolean
    bankBranch?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Company$usersArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    clients?: boolean | Company$clientsArgs<ExtArgs>
    templates?: boolean | Company$templatesArgs<ExtArgs>
    assets?: boolean | Company$assetsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    tagline?: boolean
    email?: boolean
    phone?: boolean
    website?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    country?: boolean
    postalCode?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    taxId?: boolean
    registrationNo?: boolean
    bankName?: boolean
    bankAccount?: boolean
    bankBranch?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Company$usersArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    clients?: boolean | Company$clientsArgs<ExtArgs>
    templates?: boolean | Company$templatesArgs<ExtArgs>
    assets?: boolean | Company$assetsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      templates: Prisma.$TemplatePayload<ExtArgs>[]
      assets: Prisma.$AssetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      tagline: string | null
      email: string
      phone: string
      website: string | null
      addressLine1: string
      addressLine2: string | null
      city: string
      country: string
      postalCode: string | null
      logoUrl: string | null
      primaryColor: string
      secondaryColor: string
      taxId: string | null
      registrationNo: string | null
      bankName: string | null
      bankAccount: string | null
      bankBranch: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }


  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>
    ): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    documents<T extends Company$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    clients<T extends Company$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Company$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'> | Null>;

    templates<T extends Company$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findMany'> | Null>;

    assets<T extends Company$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Company$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Company model
   */ 
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly tagline: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly website: FieldRef<"Company", 'String'>
    readonly addressLine1: FieldRef<"Company", 'String'>
    readonly addressLine2: FieldRef<"Company", 'String'>
    readonly city: FieldRef<"Company", 'String'>
    readonly country: FieldRef<"Company", 'String'>
    readonly postalCode: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly primaryColor: FieldRef<"Company", 'String'>
    readonly secondaryColor: FieldRef<"Company", 'String'>
    readonly taxId: FieldRef<"Company", 'String'>
    readonly registrationNo: FieldRef<"Company", 'String'>
    readonly bankName: FieldRef<"Company", 'String'>
    readonly bankAccount: FieldRef<"Company", 'String'>
    readonly bankBranch: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }


  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Company.documents
   */
  export type Company$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Company.clients
   */
  export type Company$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Company.templates
   */
  export type Company$templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Company.assets
   */
  export type Company$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    cursor?: AssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }


  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude<ExtArgs> | null
  }



  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    contactPerson: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    country: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    contactPerson: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    country: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    contactPerson: number
    addressLine1: number
    addressLine2: number
    city: number
    country: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    contactPerson?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    country?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    contactPerson?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    country?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    contactPerson?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    country?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    contactPerson: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    country: string | null
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    contactPerson?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    country?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    contactPerson?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    country?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    documents?: boolean | Client$documentsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      documents: Prisma.$DocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      contactPerson: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      country: string | null
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }


  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     *     @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    documents<T extends Client$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly contactPerson: FieldRef<"Client", 'String'>
    readonly addressLine1: FieldRef<"Client", 'String'>
    readonly addressLine2: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly country: FieldRef<"Client", 'String'>
    readonly companyId: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }


  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }


  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }


  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }


  /**
   * Client.documents
   */
  export type Client$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type DocumentSumAggregateOutputType = {
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    documentNumber: string | null
    type: $Enums.DocumentType | null
    status: $Enums.DocumentStatus | null
    issueDate: Date | null
    dueDate: Date | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    currency: string | null
    notes: string | null
    terms: string | null
    pdfUrl: string | null
    companyId: string | null
    clientId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    documentNumber: string | null
    type: $Enums.DocumentType | null
    status: $Enums.DocumentStatus | null
    issueDate: Date | null
    dueDate: Date | null
    subtotal: Decimal | null
    taxRate: Decimal | null
    taxAmount: Decimal | null
    total: Decimal | null
    currency: string | null
    notes: string | null
    terms: string | null
    pdfUrl: string | null
    companyId: string | null
    clientId: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    documentNumber: number
    type: number
    status: number
    issueDate: number
    dueDate: number
    subtotal: number
    taxRate: number
    taxAmount: number
    total: number
    currency: number
    notes: number
    terms: number
    pdfUrl: number
    companyId: number
    clientId: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
  }

  export type DocumentSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    documentNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    currency?: true
    notes?: true
    terms?: true
    pdfUrl?: true
    companyId?: true
    clientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    documentNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    currency?: true
    notes?: true
    terms?: true
    pdfUrl?: true
    companyId?: true
    clientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    documentNumber?: true
    type?: true
    status?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    currency?: true
    notes?: true
    terms?: true
    pdfUrl?: true
    companyId?: true
    clientId?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    documentNumber: string
    type: $Enums.DocumentType
    status: $Enums.DocumentStatus
    issueDate: Date
    dueDate: Date | null
    subtotal: Decimal
    taxRate: Decimal
    taxAmount: Decimal
    total: Decimal
    currency: string
    notes: string | null
    terms: string | null
    pdfUrl: string | null
    companyId: string
    clientId: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    currency?: boolean
    notes?: boolean
    terms?: boolean
    pdfUrl?: boolean
    companyId?: boolean
    clientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    client?: boolean | Document$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Document$itemsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    documentNumber?: boolean
    type?: boolean
    status?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    currency?: boolean
    notes?: boolean
    terms?: boolean
    pdfUrl?: boolean
    companyId?: boolean
    clientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    client?: boolean | Document$clientArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | Document$itemsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$DocumentItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentNumber: string
      type: $Enums.DocumentType
      status: $Enums.DocumentStatus
      issueDate: Date
      dueDate: Date | null
      subtotal: Prisma.Decimal
      taxRate: Prisma.Decimal
      taxAmount: Prisma.Decimal
      total: Prisma.Decimal
      currency: string
      notes: string | null
      terms: string | null
      pdfUrl: string | null
      companyId: string
      clientId: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    client<T extends Document$clientArgs<ExtArgs> = {}>(args?: Subset<T, Document$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    items<T extends Document$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Document$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly documentNumber: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly status: FieldRef<"Document", 'DocumentStatus'>
    readonly issueDate: FieldRef<"Document", 'DateTime'>
    readonly dueDate: FieldRef<"Document", 'DateTime'>
    readonly subtotal: FieldRef<"Document", 'Decimal'>
    readonly taxRate: FieldRef<"Document", 'Decimal'>
    readonly taxAmount: FieldRef<"Document", 'Decimal'>
    readonly total: FieldRef<"Document", 'Decimal'>
    readonly currency: FieldRef<"Document", 'String'>
    readonly notes: FieldRef<"Document", 'String'>
    readonly terms: FieldRef<"Document", 'String'>
    readonly pdfUrl: FieldRef<"Document", 'String'>
    readonly companyId: FieldRef<"Document", 'String'>
    readonly clientId: FieldRef<"Document", 'String'>
    readonly createdById: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.client
   */
  export type Document$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }


  /**
   * Document.items
   */
  export type Document$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    where?: DocumentItemWhereInput
    orderBy?: DocumentItemOrderByWithRelationInput | DocumentItemOrderByWithRelationInput[]
    cursor?: DocumentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentItemScalarFieldEnum | DocumentItemScalarFieldEnum[]
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model DocumentItem
   */

  export type AggregateDocumentItem = {
    _count: DocumentItemCountAggregateOutputType | null
    _avg: DocumentItemAvgAggregateOutputType | null
    _sum: DocumentItemSumAggregateOutputType | null
    _min: DocumentItemMinAggregateOutputType | null
    _max: DocumentItemMaxAggregateOutputType | null
  }

  export type DocumentItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type DocumentItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type DocumentItemMinAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
    documentId: string | null
    createdAt: Date | null
  }

  export type DocumentItemMaxAggregateOutputType = {
    id: string | null
    description: string | null
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
    documentId: string | null
    createdAt: Date | null
  }

  export type DocumentItemCountAggregateOutputType = {
    id: number
    description: number
    quantity: number
    unitPrice: number
    total: number
    documentId: number
    createdAt: number
    _all: number
  }


  export type DocumentItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type DocumentItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type DocumentItemMinAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    documentId?: true
    createdAt?: true
  }

  export type DocumentItemMaxAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    documentId?: true
    createdAt?: true
  }

  export type DocumentItemCountAggregateInputType = {
    id?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    documentId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentItem to aggregate.
     */
    where?: DocumentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentItems to fetch.
     */
    orderBy?: DocumentItemOrderByWithRelationInput | DocumentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentItems
    **/
    _count?: true | DocumentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentItemMaxAggregateInputType
  }

  export type GetDocumentItemAggregateType<T extends DocumentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentItem[P]>
      : GetScalarType<T[P], AggregateDocumentItem[P]>
  }




  export type DocumentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentItemWhereInput
    orderBy?: DocumentItemOrderByWithAggregationInput | DocumentItemOrderByWithAggregationInput[]
    by: DocumentItemScalarFieldEnum[] | DocumentItemScalarFieldEnum
    having?: DocumentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentItemCountAggregateInputType | true
    _avg?: DocumentItemAvgAggregateInputType
    _sum?: DocumentItemSumAggregateInputType
    _min?: DocumentItemMinAggregateInputType
    _max?: DocumentItemMaxAggregateInputType
  }

  export type DocumentItemGroupByOutputType = {
    id: string
    description: string
    quantity: number
    unitPrice: Decimal
    total: Decimal
    documentId: string
    createdAt: Date
    _count: DocumentItemCountAggregateOutputType | null
    _avg: DocumentItemAvgAggregateOutputType | null
    _sum: DocumentItemSumAggregateOutputType | null
    _min: DocumentItemMinAggregateOutputType | null
    _max: DocumentItemMaxAggregateOutputType | null
  }

  type GetDocumentItemGroupByPayload<T extends DocumentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentItemGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentItemGroupByOutputType[P]>
        }
      >
    >


  export type DocumentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    documentId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentItem"]>

  export type DocumentItemSelectScalar = {
    id?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    documentId?: boolean
    createdAt?: boolean
  }

  export type DocumentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }


  export type $DocumentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentItem"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      quantity: number
      unitPrice: Prisma.Decimal
      total: Prisma.Decimal
      documentId: string
      createdAt: Date
    }, ExtArgs["result"]["documentItem"]>
    composites: {}
  }


  type DocumentItemGetPayload<S extends boolean | null | undefined | DocumentItemDefaultArgs> = $Result.GetResult<Prisma.$DocumentItemPayload, S>

  type DocumentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentItemCountAggregateInputType | true
    }

  export interface DocumentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentItem'], meta: { name: 'DocumentItem' } }
    /**
     * Find zero or one DocumentItem that matches the filter.
     * @param {DocumentItemFindUniqueArgs} args - Arguments to find a DocumentItem
     * @example
     * // Get one DocumentItem
     * const documentItem = await prisma.documentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentItemFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentItemFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DocumentItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentItemFindUniqueOrThrowArgs} args - Arguments to find a DocumentItem
     * @example
     * // Get one DocumentItem
     * const documentItem = await prisma.documentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentItemFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentItemFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DocumentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemFindFirstArgs} args - Arguments to find a DocumentItem
     * @example
     * // Get one DocumentItem
     * const documentItem = await prisma.documentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentItemFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentItemFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DocumentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemFindFirstOrThrowArgs} args - Arguments to find a DocumentItem
     * @example
     * // Get one DocumentItem
     * const documentItem = await prisma.documentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentItemFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentItemFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DocumentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentItems
     * const documentItems = await prisma.documentItem.findMany()
     * 
     * // Get first 10 DocumentItems
     * const documentItems = await prisma.documentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentItemWithIdOnly = await prisma.documentItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentItemFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentItemFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DocumentItem.
     * @param {DocumentItemCreateArgs} args - Arguments to create a DocumentItem.
     * @example
     * // Create one DocumentItem
     * const DocumentItem = await prisma.documentItem.create({
     *   data: {
     *     // ... data to create a DocumentItem
     *   }
     * })
     * 
    **/
    create<T extends DocumentItemCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentItemCreateArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DocumentItems.
     *     @param {DocumentItemCreateManyArgs} args - Arguments to create many DocumentItems.
     *     @example
     *     // Create many DocumentItems
     *     const documentItem = await prisma.documentItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentItemCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentItemCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentItem.
     * @param {DocumentItemDeleteArgs} args - Arguments to delete one DocumentItem.
     * @example
     * // Delete one DocumentItem
     * const DocumentItem = await prisma.documentItem.delete({
     *   where: {
     *     // ... filter to delete one DocumentItem
     *   }
     * })
     * 
    **/
    delete<T extends DocumentItemDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentItemDeleteArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DocumentItem.
     * @param {DocumentItemUpdateArgs} args - Arguments to update one DocumentItem.
     * @example
     * // Update one DocumentItem
     * const documentItem = await prisma.documentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentItemUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentItemUpdateArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DocumentItems.
     * @param {DocumentItemDeleteManyArgs} args - Arguments to filter DocumentItems to delete.
     * @example
     * // Delete a few DocumentItems
     * const { count } = await prisma.documentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentItemDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentItemDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentItems
     * const documentItem = await prisma.documentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentItemUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentItemUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentItem.
     * @param {DocumentItemUpsertArgs} args - Arguments to update or create a DocumentItem.
     * @example
     * // Update or create a DocumentItem
     * const documentItem = await prisma.documentItem.upsert({
     *   create: {
     *     // ... data to create a DocumentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentItem we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentItemUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentItemUpsertArgs<ExtArgs>>
    ): Prisma__DocumentItemClient<$Result.GetResult<Prisma.$DocumentItemPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DocumentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemCountArgs} args - Arguments to filter DocumentItems to count.
     * @example
     * // Count the number of DocumentItems
     * const count = await prisma.documentItem.count({
     *   where: {
     *     // ... the filter for the DocumentItems we want to count
     *   }
     * })
    **/
    count<T extends DocumentItemCountArgs>(
      args?: Subset<T, DocumentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentItemAggregateArgs>(args: Subset<T, DocumentItemAggregateArgs>): Prisma.PrismaPromise<GetDocumentItemAggregateType<T>>

    /**
     * Group by DocumentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentItemGroupByArgs['orderBy'] }
        : { orderBy?: DocumentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentItem model
   */
  readonly fields: DocumentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DocumentItem model
   */ 
  interface DocumentItemFieldRefs {
    readonly id: FieldRef<"DocumentItem", 'String'>
    readonly description: FieldRef<"DocumentItem", 'String'>
    readonly quantity: FieldRef<"DocumentItem", 'Int'>
    readonly unitPrice: FieldRef<"DocumentItem", 'Decimal'>
    readonly total: FieldRef<"DocumentItem", 'Decimal'>
    readonly documentId: FieldRef<"DocumentItem", 'String'>
    readonly createdAt: FieldRef<"DocumentItem", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DocumentItem findUnique
   */
  export type DocumentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * Filter, which DocumentItem to fetch.
     */
    where: DocumentItemWhereUniqueInput
  }


  /**
   * DocumentItem findUniqueOrThrow
   */
  export type DocumentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * Filter, which DocumentItem to fetch.
     */
    where: DocumentItemWhereUniqueInput
  }


  /**
   * DocumentItem findFirst
   */
  export type DocumentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * Filter, which DocumentItem to fetch.
     */
    where?: DocumentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentItems to fetch.
     */
    orderBy?: DocumentItemOrderByWithRelationInput | DocumentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentItems.
     */
    cursor?: DocumentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentItems.
     */
    distinct?: DocumentItemScalarFieldEnum | DocumentItemScalarFieldEnum[]
  }


  /**
   * DocumentItem findFirstOrThrow
   */
  export type DocumentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * Filter, which DocumentItem to fetch.
     */
    where?: DocumentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentItems to fetch.
     */
    orderBy?: DocumentItemOrderByWithRelationInput | DocumentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentItems.
     */
    cursor?: DocumentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentItems.
     */
    distinct?: DocumentItemScalarFieldEnum | DocumentItemScalarFieldEnum[]
  }


  /**
   * DocumentItem findMany
   */
  export type DocumentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * Filter, which DocumentItems to fetch.
     */
    where?: DocumentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentItems to fetch.
     */
    orderBy?: DocumentItemOrderByWithRelationInput | DocumentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentItems.
     */
    cursor?: DocumentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentItems.
     */
    skip?: number
    distinct?: DocumentItemScalarFieldEnum | DocumentItemScalarFieldEnum[]
  }


  /**
   * DocumentItem create
   */
  export type DocumentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentItem.
     */
    data: XOR<DocumentItemCreateInput, DocumentItemUncheckedCreateInput>
  }


  /**
   * DocumentItem createMany
   */
  export type DocumentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentItems.
     */
    data: DocumentItemCreateManyInput | DocumentItemCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DocumentItem update
   */
  export type DocumentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentItem.
     */
    data: XOR<DocumentItemUpdateInput, DocumentItemUncheckedUpdateInput>
    /**
     * Choose, which DocumentItem to update.
     */
    where: DocumentItemWhereUniqueInput
  }


  /**
   * DocumentItem updateMany
   */
  export type DocumentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentItems.
     */
    data: XOR<DocumentItemUpdateManyMutationInput, DocumentItemUncheckedUpdateManyInput>
    /**
     * Filter which DocumentItems to update
     */
    where?: DocumentItemWhereInput
  }


  /**
   * DocumentItem upsert
   */
  export type DocumentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentItem to update in case it exists.
     */
    where: DocumentItemWhereUniqueInput
    /**
     * In case the DocumentItem found by the `where` argument doesn't exist, create a new DocumentItem with this data.
     */
    create: XOR<DocumentItemCreateInput, DocumentItemUncheckedCreateInput>
    /**
     * In case the DocumentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentItemUpdateInput, DocumentItemUncheckedUpdateInput>
  }


  /**
   * DocumentItem delete
   */
  export type DocumentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
    /**
     * Filter which DocumentItem to delete.
     */
    where: DocumentItemWhereUniqueInput
  }


  /**
   * DocumentItem deleteMany
   */
  export type DocumentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentItems to delete
     */
    where?: DocumentItemWhereInput
  }


  /**
   * DocumentItem without action
   */
  export type DocumentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentItem
     */
    select?: DocumentItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentItemInclude<ExtArgs> | null
  }



  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DocumentType | null
    description: string | null
    isDefault: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DocumentType | null
    description: string | null
    isDefault: boolean | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    isDefault: number
    config: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDefault?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDefault?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    isDefault?: true
    config?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DocumentType
    description: string | null
    isDefault: boolean
    config: JsonValue | null
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isDefault?: boolean
    config?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    isDefault?: boolean
    config?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DocumentType
      description: string | null
      isDefault: boolean
      config: Prisma.JsonValue | null
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }


  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Template that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
    **/
    create<T extends TemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Templates.
     *     @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     *     @example
     *     // Create many Templates
     *     const template = await prisma.template.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
    **/
    delete<T extends TemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly name: FieldRef<"Template", 'String'>
    readonly type: FieldRef<"Template", 'DocumentType'>
    readonly description: FieldRef<"Template", 'String'>
    readonly isDefault: FieldRef<"Template", 'Boolean'>
    readonly config: FieldRef<"Template", 'Json'>
    readonly companyId: FieldRef<"Template", 'String'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }


  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }


  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }


  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }


  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }


  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
  }



  /**
   * Model Asset
   */

  export type AggregateAsset = {
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  export type AssetAvgAggregateOutputType = {
    size: number | null
  }

  export type AssetSumAggregateOutputType = {
    size: number | null
  }

  export type AssetMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AssetType | null
    mimeType: string | null
    size: number | null
    url: string | null
    companyId: string | null
    createdAt: Date | null
  }

  export type AssetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.AssetType | null
    mimeType: string | null
    size: number | null
    url: string | null
    companyId: string | null
    createdAt: Date | null
  }

  export type AssetCountAggregateOutputType = {
    id: number
    name: number
    type: number
    mimeType: number
    size: number
    url: number
    companyId: number
    createdAt: number
    _all: number
  }


  export type AssetAvgAggregateInputType = {
    size?: true
  }

  export type AssetSumAggregateInputType = {
    size?: true
  }

  export type AssetMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mimeType?: true
    size?: true
    url?: true
    companyId?: true
    createdAt?: true
  }

  export type AssetMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mimeType?: true
    size?: true
    url?: true
    companyId?: true
    createdAt?: true
  }

  export type AssetCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    mimeType?: true
    size?: true
    url?: true
    companyId?: true
    createdAt?: true
    _all?: true
  }

  export type AssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asset to aggregate.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assets
    **/
    _count?: true | AssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetMaxAggregateInputType
  }

  export type GetAssetAggregateType<T extends AssetAggregateArgs> = {
        [P in keyof T & keyof AggregateAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsset[P]>
      : GetScalarType<T[P], AggregateAsset[P]>
  }




  export type AssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetWhereInput
    orderBy?: AssetOrderByWithAggregationInput | AssetOrderByWithAggregationInput[]
    by: AssetScalarFieldEnum[] | AssetScalarFieldEnum
    having?: AssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetCountAggregateInputType | true
    _avg?: AssetAvgAggregateInputType
    _sum?: AssetSumAggregateInputType
    _min?: AssetMinAggregateInputType
    _max?: AssetMaxAggregateInputType
  }

  export type AssetGroupByOutputType = {
    id: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    companyId: string
    createdAt: Date
    _count: AssetCountAggregateOutputType | null
    _avg: AssetAvgAggregateOutputType | null
    _sum: AssetSumAggregateOutputType | null
    _min: AssetMinAggregateOutputType | null
    _max: AssetMaxAggregateOutputType | null
  }

  type GetAssetGroupByPayload<T extends AssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetGroupByOutputType[P]>
            : GetScalarType<T[P], AssetGroupByOutputType[P]>
        }
      >
    >


  export type AssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    companyId?: boolean
    createdAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["asset"]>

  export type AssetSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    companyId?: boolean
    createdAt?: boolean
  }

  export type AssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }


  export type $AssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Asset"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.AssetType
      mimeType: string
      size: number
      url: string
      companyId: string
      createdAt: Date
    }, ExtArgs["result"]["asset"]>
    composites: {}
  }


  type AssetGetPayload<S extends boolean | null | undefined | AssetDefaultArgs> = $Result.GetResult<Prisma.$AssetPayload, S>

  type AssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssetCountAggregateInputType | true
    }

  export interface AssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asset'], meta: { name: 'Asset' } }
    /**
     * Find zero or one Asset that matches the filter.
     * @param {AssetFindUniqueArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AssetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AssetFindUniqueArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Asset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AssetFindUniqueOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AssetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Asset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AssetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindFirstArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Asset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindFirstOrThrowArgs} args - Arguments to find a Asset
     * @example
     * // Get one Asset
     * const asset = await prisma.asset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AssetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.asset.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.asset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetWithIdOnly = await prisma.asset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AssetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Asset.
     * @param {AssetCreateArgs} args - Arguments to create a Asset.
     * @example
     * // Create one Asset
     * const Asset = await prisma.asset.create({
     *   data: {
     *     // ... data to create a Asset
     *   }
     * })
     * 
    **/
    create<T extends AssetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetCreateArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Assets.
     *     @param {AssetCreateManyArgs} args - Arguments to create many Assets.
     *     @example
     *     // Create many Assets
     *     const asset = await prisma.asset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AssetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Asset.
     * @param {AssetDeleteArgs} args - Arguments to delete one Asset.
     * @example
     * // Delete one Asset
     * const Asset = await prisma.asset.delete({
     *   where: {
     *     // ... filter to delete one Asset
     *   }
     * })
     * 
    **/
    delete<T extends AssetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AssetDeleteArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Asset.
     * @param {AssetUpdateArgs} args - Arguments to update one Asset.
     * @example
     * // Update one Asset
     * const asset = await prisma.asset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AssetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpdateArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Assets.
     * @param {AssetDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.asset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AssetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AssetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const asset = await prisma.asset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AssetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asset.
     * @param {AssetUpsertArgs} args - Arguments to update or create a Asset.
     * @example
     * // Update or create a Asset
     * const asset = await prisma.asset.upsert({
     *   create: {
     *     // ... data to create a Asset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asset we want to update
     *   }
     * })
    **/
    upsert<T extends AssetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AssetUpsertArgs<ExtArgs>>
    ): Prisma__AssetClient<$Result.GetResult<Prisma.$AssetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.asset.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends AssetCountArgs>(
      args?: Subset<T, AssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetAggregateArgs>(args: Subset<T, AssetAggregateArgs>): Prisma.PrismaPromise<GetAssetAggregateType<T>>

    /**
     * Group by Asset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetGroupByArgs['orderBy'] }
        : { orderBy?: AssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Asset model
   */
  readonly fields: AssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Asset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Asset model
   */ 
  interface AssetFieldRefs {
    readonly id: FieldRef<"Asset", 'String'>
    readonly name: FieldRef<"Asset", 'String'>
    readonly type: FieldRef<"Asset", 'AssetType'>
    readonly mimeType: FieldRef<"Asset", 'String'>
    readonly size: FieldRef<"Asset", 'Int'>
    readonly url: FieldRef<"Asset", 'String'>
    readonly companyId: FieldRef<"Asset", 'String'>
    readonly createdAt: FieldRef<"Asset", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Asset findUnique
   */
  export type AssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }


  /**
   * Asset findUniqueOrThrow
   */
  export type AssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where: AssetWhereUniqueInput
  }


  /**
   * Asset findFirst
   */
  export type AssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }


  /**
   * Asset findFirstOrThrow
   */
  export type AssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Asset to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assets.
     */
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }


  /**
   * Asset findMany
   */
  export type AssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter, which Assets to fetch.
     */
    where?: AssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assets to fetch.
     */
    orderBy?: AssetOrderByWithRelationInput | AssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assets.
     */
    cursor?: AssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assets.
     */
    skip?: number
    distinct?: AssetScalarFieldEnum | AssetScalarFieldEnum[]
  }


  /**
   * Asset create
   */
  export type AssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to create a Asset.
     */
    data: XOR<AssetCreateInput, AssetUncheckedCreateInput>
  }


  /**
   * Asset createMany
   */
  export type AssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assets.
     */
    data: AssetCreateManyInput | AssetCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Asset update
   */
  export type AssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The data needed to update a Asset.
     */
    data: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
    /**
     * Choose, which Asset to update.
     */
    where: AssetWhereUniqueInput
  }


  /**
   * Asset updateMany
   */
  export type AssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assets.
     */
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyInput>
    /**
     * Filter which Assets to update
     */
    where?: AssetWhereInput
  }


  /**
   * Asset upsert
   */
  export type AssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * The filter to search for the Asset to update in case it exists.
     */
    where: AssetWhereUniqueInput
    /**
     * In case the Asset found by the `where` argument doesn't exist, create a new Asset with this data.
     */
    create: XOR<AssetCreateInput, AssetUncheckedCreateInput>
    /**
     * In case the Asset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUpdateInput, AssetUncheckedUpdateInput>
  }


  /**
   * Asset delete
   */
  export type AssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
    /**
     * Filter which Asset to delete.
     */
    where: AssetWhereUniqueInput
  }


  /**
   * Asset deleteMany
   */
  export type AssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assets to delete
     */
    where?: AssetWhereInput
  }


  /**
   * Asset without action
   */
  export type AssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asset
     */
    select?: AssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AssetInclude<ExtArgs> | null
  }



  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    folder: $Enums.EmailFolder | null
    fromName: string | null
    fromAddress: string | null
    subject: string | null
    textBody: string | null
    htmlBody: string | null
    snippet: string | null
    isRead: boolean | null
    isStarred: boolean | null
    hasAttachments: boolean | null
    priority: string | null
    snoozedUntil: Date | null
    snoozedFromFolder: string | null
    userId: string | null
    sentAt: Date | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    folder: $Enums.EmailFolder | null
    fromName: string | null
    fromAddress: string | null
    subject: string | null
    textBody: string | null
    htmlBody: string | null
    snippet: string | null
    isRead: boolean | null
    isStarred: boolean | null
    hasAttachments: boolean | null
    priority: string | null
    snoozedUntil: Date | null
    snoozedFromFolder: string | null
    userId: string | null
    sentAt: Date | null
    scheduledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    messageId: number
    folder: number
    fromName: number
    fromAddress: number
    toAddresses: number
    ccAddresses: number
    bccAddresses: number
    subject: number
    textBody: number
    htmlBody: number
    snippet: number
    isRead: number
    isStarred: number
    hasAttachments: number
    labels: number
    priority: number
    snoozedUntil: number
    snoozedFromFolder: number
    userId: number
    sentAt: number
    scheduledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailMinAggregateInputType = {
    id?: true
    messageId?: true
    folder?: true
    fromName?: true
    fromAddress?: true
    subject?: true
    textBody?: true
    htmlBody?: true
    snippet?: true
    isRead?: true
    isStarred?: true
    hasAttachments?: true
    priority?: true
    snoozedUntil?: true
    snoozedFromFolder?: true
    userId?: true
    sentAt?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    messageId?: true
    folder?: true
    fromName?: true
    fromAddress?: true
    subject?: true
    textBody?: true
    htmlBody?: true
    snippet?: true
    isRead?: true
    isStarred?: true
    hasAttachments?: true
    priority?: true
    snoozedUntil?: true
    snoozedFromFolder?: true
    userId?: true
    sentAt?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    messageId?: true
    folder?: true
    fromName?: true
    fromAddress?: true
    toAddresses?: true
    ccAddresses?: true
    bccAddresses?: true
    subject?: true
    textBody?: true
    htmlBody?: true
    snippet?: true
    isRead?: true
    isStarred?: true
    hasAttachments?: true
    labels?: true
    priority?: true
    snoozedUntil?: true
    snoozedFromFolder?: true
    userId?: true
    sentAt?: true
    scheduledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: string
    messageId: string
    folder: $Enums.EmailFolder
    fromName: string | null
    fromAddress: string
    toAddresses: string[]
    ccAddresses: string[]
    bccAddresses: string[]
    subject: string
    textBody: string | null
    htmlBody: string | null
    snippet: string | null
    isRead: boolean
    isStarred: boolean
    hasAttachments: boolean
    labels: string[]
    priority: string
    snoozedUntil: Date | null
    snoozedFromFolder: string | null
    userId: string
    sentAt: Date
    scheduledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    folder?: boolean
    fromName?: boolean
    fromAddress?: boolean
    toAddresses?: boolean
    ccAddresses?: boolean
    bccAddresses?: boolean
    subject?: boolean
    textBody?: boolean
    htmlBody?: boolean
    snippet?: boolean
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: boolean
    priority?: boolean
    snoozedUntil?: boolean
    snoozedFromFolder?: boolean
    userId?: boolean
    sentAt?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attachments?: boolean | Email$attachmentsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectScalar = {
    id?: boolean
    messageId?: boolean
    folder?: boolean
    fromName?: boolean
    fromAddress?: boolean
    toAddresses?: boolean
    ccAddresses?: boolean
    bccAddresses?: boolean
    subject?: boolean
    textBody?: boolean
    htmlBody?: boolean
    snippet?: boolean
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: boolean
    priority?: boolean
    snoozedUntil?: boolean
    snoozedFromFolder?: boolean
    userId?: boolean
    sentAt?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | Email$attachmentsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      attachments: Prisma.$EmailAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      folder: $Enums.EmailFolder
      fromName: string | null
      fromAddress: string
      toAddresses: string[]
      ccAddresses: string[]
      bccAddresses: string[]
      subject: string
      textBody: string | null
      htmlBody: string | null
      snippet: string | null
      isRead: boolean
      isStarred: boolean
      hasAttachments: boolean
      labels: string[]
      priority: string
      snoozedUntil: Date | null
      snoozedFromFolder: string | null
      userId: string
      sentAt: Date
      scheduledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["email"]>
    composites: {}
  }


  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Email that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
    **/
    create<T extends EmailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCreateArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Emails.
     *     @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     *     @example
     *     // Create many Emails
     *     const email = await prisma.email.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
    **/
    delete<T extends EmailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
    **/
    upsert<T extends EmailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    attachments<T extends Email$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Email$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Email model
   */ 
  interface EmailFieldRefs {
    readonly id: FieldRef<"Email", 'String'>
    readonly messageId: FieldRef<"Email", 'String'>
    readonly folder: FieldRef<"Email", 'EmailFolder'>
    readonly fromName: FieldRef<"Email", 'String'>
    readonly fromAddress: FieldRef<"Email", 'String'>
    readonly toAddresses: FieldRef<"Email", 'String[]'>
    readonly ccAddresses: FieldRef<"Email", 'String[]'>
    readonly bccAddresses: FieldRef<"Email", 'String[]'>
    readonly subject: FieldRef<"Email", 'String'>
    readonly textBody: FieldRef<"Email", 'String'>
    readonly htmlBody: FieldRef<"Email", 'String'>
    readonly snippet: FieldRef<"Email", 'String'>
    readonly isRead: FieldRef<"Email", 'Boolean'>
    readonly isStarred: FieldRef<"Email", 'Boolean'>
    readonly hasAttachments: FieldRef<"Email", 'Boolean'>
    readonly labels: FieldRef<"Email", 'String[]'>
    readonly priority: FieldRef<"Email", 'String'>
    readonly snoozedUntil: FieldRef<"Email", 'DateTime'>
    readonly snoozedFromFolder: FieldRef<"Email", 'String'>
    readonly userId: FieldRef<"Email", 'String'>
    readonly sentAt: FieldRef<"Email", 'DateTime'>
    readonly scheduledAt: FieldRef<"Email", 'DateTime'>
    readonly createdAt: FieldRef<"Email", 'DateTime'>
    readonly updatedAt: FieldRef<"Email", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data: XOR<EmailCreateInput, EmailUncheckedCreateInput>
  }


  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
  }


  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
  }


  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
  }


  /**
   * Email.attachments
   */
  export type Email$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    where?: EmailAttachmentWhereInput
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    cursor?: EmailAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }


  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
  }



  /**
   * Model EmailAttachment
   */

  export type AggregateEmailAttachment = {
    _count: EmailAttachmentCountAggregateOutputType | null
    _avg: EmailAttachmentAvgAggregateOutputType | null
    _sum: EmailAttachmentSumAggregateOutputType | null
    _min: EmailAttachmentMinAggregateOutputType | null
    _max: EmailAttachmentMaxAggregateOutputType | null
  }

  export type EmailAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type EmailAttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type EmailAttachmentMinAggregateOutputType = {
    id: string | null
    filename: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    emailId: string | null
    createdAt: Date | null
  }

  export type EmailAttachmentMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    emailId: string | null
    createdAt: Date | null
  }

  export type EmailAttachmentCountAggregateOutputType = {
    id: number
    filename: number
    mimeType: number
    size: number
    url: number
    emailId: number
    createdAt: number
    _all: number
  }


  export type EmailAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type EmailAttachmentSumAggregateInputType = {
    size?: true
  }

  export type EmailAttachmentMinAggregateInputType = {
    id?: true
    filename?: true
    mimeType?: true
    size?: true
    url?: true
    emailId?: true
    createdAt?: true
  }

  export type EmailAttachmentMaxAggregateInputType = {
    id?: true
    filename?: true
    mimeType?: true
    size?: true
    url?: true
    emailId?: true
    createdAt?: true
  }

  export type EmailAttachmentCountAggregateInputType = {
    id?: true
    filename?: true
    mimeType?: true
    size?: true
    url?: true
    emailId?: true
    createdAt?: true
    _all?: true
  }

  export type EmailAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAttachment to aggregate.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAttachments
    **/
    _count?: true | EmailAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAttachmentMaxAggregateInputType
  }

  export type GetEmailAttachmentAggregateType<T extends EmailAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAttachment[P]>
      : GetScalarType<T[P], AggregateEmailAttachment[P]>
  }




  export type EmailAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAttachmentWhereInput
    orderBy?: EmailAttachmentOrderByWithAggregationInput | EmailAttachmentOrderByWithAggregationInput[]
    by: EmailAttachmentScalarFieldEnum[] | EmailAttachmentScalarFieldEnum
    having?: EmailAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAttachmentCountAggregateInputType | true
    _avg?: EmailAttachmentAvgAggregateInputType
    _sum?: EmailAttachmentSumAggregateInputType
    _min?: EmailAttachmentMinAggregateInputType
    _max?: EmailAttachmentMaxAggregateInputType
  }

  export type EmailAttachmentGroupByOutputType = {
    id: string
    filename: string
    mimeType: string
    size: number
    url: string | null
    emailId: string
    createdAt: Date
    _count: EmailAttachmentCountAggregateOutputType | null
    _avg: EmailAttachmentAvgAggregateOutputType | null
    _sum: EmailAttachmentSumAggregateOutputType | null
    _min: EmailAttachmentMinAggregateOutputType | null
    _max: EmailAttachmentMaxAggregateOutputType | null
  }

  type GetEmailAttachmentGroupByPayload<T extends EmailAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type EmailAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    emailId?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAttachment"]>

  export type EmailAttachmentSelectScalar = {
    id?: boolean
    filename?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    emailId?: boolean
    createdAt?: boolean
  }

  export type EmailAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }


  export type $EmailAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAttachment"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      mimeType: string
      size: number
      url: string | null
      emailId: string
      createdAt: Date
    }, ExtArgs["result"]["emailAttachment"]>
    composites: {}
  }


  type EmailAttachmentGetPayload<S extends boolean | null | undefined | EmailAttachmentDefaultArgs> = $Result.GetResult<Prisma.$EmailAttachmentPayload, S>

  type EmailAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailAttachmentCountAggregateInputType | true
    }

  export interface EmailAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAttachment'], meta: { name: 'EmailAttachment' } }
    /**
     * Find zero or one EmailAttachment that matches the filter.
     * @param {EmailAttachmentFindUniqueArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailAttachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailAttachmentFindUniqueOrThrowArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindFirstArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailAttachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindFirstOrThrowArgs} args - Arguments to find a EmailAttachment
     * @example
     * // Get one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailAttachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAttachments
     * const emailAttachments = await prisma.emailAttachment.findMany()
     * 
     * // Get first 10 EmailAttachments
     * const emailAttachments = await prisma.emailAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAttachmentWithIdOnly = await prisma.emailAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailAttachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailAttachment.
     * @param {EmailAttachmentCreateArgs} args - Arguments to create a EmailAttachment.
     * @example
     * // Create one EmailAttachment
     * const EmailAttachment = await prisma.emailAttachment.create({
     *   data: {
     *     // ... data to create a EmailAttachment
     *   }
     * })
     * 
    **/
    create<T extends EmailAttachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAttachmentCreateArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailAttachments.
     *     @param {EmailAttachmentCreateManyArgs} args - Arguments to create many EmailAttachments.
     *     @example
     *     // Create many EmailAttachments
     *     const emailAttachment = await prisma.emailAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailAttachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailAttachment.
     * @param {EmailAttachmentDeleteArgs} args - Arguments to delete one EmailAttachment.
     * @example
     * // Delete one EmailAttachment
     * const EmailAttachment = await prisma.emailAttachment.delete({
     *   where: {
     *     // ... filter to delete one EmailAttachment
     *   }
     * })
     * 
    **/
    delete<T extends EmailAttachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailAttachment.
     * @param {EmailAttachmentUpdateArgs} args - Arguments to update one EmailAttachment.
     * @example
     * // Update one EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailAttachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailAttachments.
     * @param {EmailAttachmentDeleteManyArgs} args - Arguments to filter EmailAttachments to delete.
     * @example
     * // Delete a few EmailAttachments
     * const { count } = await prisma.emailAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailAttachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAttachments
     * const emailAttachment = await prisma.emailAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailAttachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailAttachment.
     * @param {EmailAttachmentUpsertArgs} args - Arguments to update or create a EmailAttachment.
     * @example
     * // Update or create a EmailAttachment
     * const emailAttachment = await prisma.emailAttachment.upsert({
     *   create: {
     *     // ... data to create a EmailAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends EmailAttachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__EmailAttachmentClient<$Result.GetResult<Prisma.$EmailAttachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentCountArgs} args - Arguments to filter EmailAttachments to count.
     * @example
     * // Count the number of EmailAttachments
     * const count = await prisma.emailAttachment.count({
     *   where: {
     *     // ... the filter for the EmailAttachments we want to count
     *   }
     * })
    **/
    count<T extends EmailAttachmentCountArgs>(
      args?: Subset<T, EmailAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAttachmentAggregateArgs>(args: Subset<T, EmailAttachmentAggregateArgs>): Prisma.PrismaPromise<GetEmailAttachmentAggregateType<T>>

    /**
     * Group by EmailAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: EmailAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAttachment model
   */
  readonly fields: EmailAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailAttachment model
   */ 
  interface EmailAttachmentFieldRefs {
    readonly id: FieldRef<"EmailAttachment", 'String'>
    readonly filename: FieldRef<"EmailAttachment", 'String'>
    readonly mimeType: FieldRef<"EmailAttachment", 'String'>
    readonly size: FieldRef<"EmailAttachment", 'Int'>
    readonly url: FieldRef<"EmailAttachment", 'String'>
    readonly emailId: FieldRef<"EmailAttachment", 'String'>
    readonly createdAt: FieldRef<"EmailAttachment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailAttachment findUnique
   */
  export type EmailAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where: EmailAttachmentWhereUniqueInput
  }


  /**
   * EmailAttachment findUniqueOrThrow
   */
  export type EmailAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where: EmailAttachmentWhereUniqueInput
  }


  /**
   * EmailAttachment findFirst
   */
  export type EmailAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAttachments.
     */
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }


  /**
   * EmailAttachment findFirstOrThrow
   */
  export type EmailAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachment to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAttachments.
     */
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }


  /**
   * EmailAttachment findMany
   */
  export type EmailAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which EmailAttachments to fetch.
     */
    where?: EmailAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAttachments to fetch.
     */
    orderBy?: EmailAttachmentOrderByWithRelationInput | EmailAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAttachments.
     */
    cursor?: EmailAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAttachments.
     */
    skip?: number
    distinct?: EmailAttachmentScalarFieldEnum | EmailAttachmentScalarFieldEnum[]
  }


  /**
   * EmailAttachment create
   */
  export type EmailAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAttachment.
     */
    data: XOR<EmailAttachmentCreateInput, EmailAttachmentUncheckedCreateInput>
  }


  /**
   * EmailAttachment createMany
   */
  export type EmailAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAttachments.
     */
    data: EmailAttachmentCreateManyInput | EmailAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailAttachment update
   */
  export type EmailAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAttachment.
     */
    data: XOR<EmailAttachmentUpdateInput, EmailAttachmentUncheckedUpdateInput>
    /**
     * Choose, which EmailAttachment to update.
     */
    where: EmailAttachmentWhereUniqueInput
  }


  /**
   * EmailAttachment updateMany
   */
  export type EmailAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAttachments.
     */
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which EmailAttachments to update
     */
    where?: EmailAttachmentWhereInput
  }


  /**
   * EmailAttachment upsert
   */
  export type EmailAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAttachment to update in case it exists.
     */
    where: EmailAttachmentWhereUniqueInput
    /**
     * In case the EmailAttachment found by the `where` argument doesn't exist, create a new EmailAttachment with this data.
     */
    create: XOR<EmailAttachmentCreateInput, EmailAttachmentUncheckedCreateInput>
    /**
     * In case the EmailAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAttachmentUpdateInput, EmailAttachmentUncheckedUpdateInput>
  }


  /**
   * EmailAttachment delete
   */
  export type EmailAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
    /**
     * Filter which EmailAttachment to delete.
     */
    where: EmailAttachmentWhereUniqueInput
  }


  /**
   * EmailAttachment deleteMany
   */
  export type EmailAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAttachments to delete
     */
    where?: EmailAttachmentWhereInput
  }


  /**
   * EmailAttachment without action
   */
  export type EmailAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAttachment
     */
    select?: EmailAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAttachmentInclude<ExtArgs> | null
  }



  /**
   * Model EmailOutbox
   */

  export type AggregateEmailOutbox = {
    _count: EmailOutboxCountAggregateOutputType | null
    _avg: EmailOutboxAvgAggregateOutputType | null
    _sum: EmailOutboxSumAggregateOutputType | null
    _min: EmailOutboxMinAggregateOutputType | null
    _max: EmailOutboxMaxAggregateOutputType | null
  }

  export type EmailOutboxAvgAggregateOutputType = {
    attempts: number | null
  }

  export type EmailOutboxSumAggregateOutputType = {
    attempts: number | null
  }

  export type EmailOutboxMinAggregateOutputType = {
    id: string | null
    fromName: string | null
    fromAddress: string | null
    subject: string | null
    textBody: string | null
    htmlBody: string | null
    sendAt: Date | null
    status: $Enums.OutboxStatus | null
    sentEmailId: string | null
    errorMessage: string | null
    attempts: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailOutboxMaxAggregateOutputType = {
    id: string | null
    fromName: string | null
    fromAddress: string | null
    subject: string | null
    textBody: string | null
    htmlBody: string | null
    sendAt: Date | null
    status: $Enums.OutboxStatus | null
    sentEmailId: string | null
    errorMessage: string | null
    attempts: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailOutboxCountAggregateOutputType = {
    id: number
    fromName: number
    fromAddress: number
    toAddresses: number
    ccAddresses: number
    bccAddresses: number
    subject: number
    textBody: number
    htmlBody: number
    sendAt: number
    status: number
    sentEmailId: number
    errorMessage: number
    attempts: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailOutboxAvgAggregateInputType = {
    attempts?: true
  }

  export type EmailOutboxSumAggregateInputType = {
    attempts?: true
  }

  export type EmailOutboxMinAggregateInputType = {
    id?: true
    fromName?: true
    fromAddress?: true
    subject?: true
    textBody?: true
    htmlBody?: true
    sendAt?: true
    status?: true
    sentEmailId?: true
    errorMessage?: true
    attempts?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailOutboxMaxAggregateInputType = {
    id?: true
    fromName?: true
    fromAddress?: true
    subject?: true
    textBody?: true
    htmlBody?: true
    sendAt?: true
    status?: true
    sentEmailId?: true
    errorMessage?: true
    attempts?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailOutboxCountAggregateInputType = {
    id?: true
    fromName?: true
    fromAddress?: true
    toAddresses?: true
    ccAddresses?: true
    bccAddresses?: true
    subject?: true
    textBody?: true
    htmlBody?: true
    sendAt?: true
    status?: true
    sentEmailId?: true
    errorMessage?: true
    attempts?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailOutboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailOutbox to aggregate.
     */
    where?: EmailOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOutboxes to fetch.
     */
    orderBy?: EmailOutboxOrderByWithRelationInput | EmailOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOutboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailOutboxes
    **/
    _count?: true | EmailOutboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailOutboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailOutboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailOutboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailOutboxMaxAggregateInputType
  }

  export type GetEmailOutboxAggregateType<T extends EmailOutboxAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailOutbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailOutbox[P]>
      : GetScalarType<T[P], AggregateEmailOutbox[P]>
  }




  export type EmailOutboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailOutboxWhereInput
    orderBy?: EmailOutboxOrderByWithAggregationInput | EmailOutboxOrderByWithAggregationInput[]
    by: EmailOutboxScalarFieldEnum[] | EmailOutboxScalarFieldEnum
    having?: EmailOutboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailOutboxCountAggregateInputType | true
    _avg?: EmailOutboxAvgAggregateInputType
    _sum?: EmailOutboxSumAggregateInputType
    _min?: EmailOutboxMinAggregateInputType
    _max?: EmailOutboxMaxAggregateInputType
  }

  export type EmailOutboxGroupByOutputType = {
    id: string
    fromName: string | null
    fromAddress: string
    toAddresses: string[]
    ccAddresses: string[]
    bccAddresses: string[]
    subject: string
    textBody: string | null
    htmlBody: string | null
    sendAt: Date
    status: $Enums.OutboxStatus
    sentEmailId: string | null
    errorMessage: string | null
    attempts: number
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailOutboxCountAggregateOutputType | null
    _avg: EmailOutboxAvgAggregateOutputType | null
    _sum: EmailOutboxSumAggregateOutputType | null
    _min: EmailOutboxMinAggregateOutputType | null
    _max: EmailOutboxMaxAggregateOutputType | null
  }

  type GetEmailOutboxGroupByPayload<T extends EmailOutboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailOutboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailOutboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailOutboxGroupByOutputType[P]>
            : GetScalarType<T[P], EmailOutboxGroupByOutputType[P]>
        }
      >
    >


  export type EmailOutboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromName?: boolean
    fromAddress?: boolean
    toAddresses?: boolean
    ccAddresses?: boolean
    bccAddresses?: boolean
    subject?: boolean
    textBody?: boolean
    htmlBody?: boolean
    sendAt?: boolean
    status?: boolean
    sentEmailId?: boolean
    errorMessage?: boolean
    attempts?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailOutbox"]>

  export type EmailOutboxSelectScalar = {
    id?: boolean
    fromName?: boolean
    fromAddress?: boolean
    toAddresses?: boolean
    ccAddresses?: boolean
    bccAddresses?: boolean
    subject?: boolean
    textBody?: boolean
    htmlBody?: boolean
    sendAt?: boolean
    status?: boolean
    sentEmailId?: boolean
    errorMessage?: boolean
    attempts?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EmailOutboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailOutbox"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromName: string | null
      fromAddress: string
      toAddresses: string[]
      ccAddresses: string[]
      bccAddresses: string[]
      subject: string
      textBody: string | null
      htmlBody: string | null
      sendAt: Date
      status: $Enums.OutboxStatus
      sentEmailId: string | null
      errorMessage: string | null
      attempts: number
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailOutbox"]>
    composites: {}
  }


  type EmailOutboxGetPayload<S extends boolean | null | undefined | EmailOutboxDefaultArgs> = $Result.GetResult<Prisma.$EmailOutboxPayload, S>

  type EmailOutboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailOutboxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailOutboxCountAggregateInputType | true
    }

  export interface EmailOutboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailOutbox'], meta: { name: 'EmailOutbox' } }
    /**
     * Find zero or one EmailOutbox that matches the filter.
     * @param {EmailOutboxFindUniqueArgs} args - Arguments to find a EmailOutbox
     * @example
     * // Get one EmailOutbox
     * const emailOutbox = await prisma.emailOutbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailOutboxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailOutboxFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailOutbox that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailOutboxFindUniqueOrThrowArgs} args - Arguments to find a EmailOutbox
     * @example
     * // Get one EmailOutbox
     * const emailOutbox = await prisma.emailOutbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailOutboxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailOutboxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailOutbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxFindFirstArgs} args - Arguments to find a EmailOutbox
     * @example
     * // Get one EmailOutbox
     * const emailOutbox = await prisma.emailOutbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailOutboxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailOutboxFindFirstArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailOutbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxFindFirstOrThrowArgs} args - Arguments to find a EmailOutbox
     * @example
     * // Get one EmailOutbox
     * const emailOutbox = await prisma.emailOutbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailOutboxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailOutboxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailOutboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailOutboxes
     * const emailOutboxes = await prisma.emailOutbox.findMany()
     * 
     * // Get first 10 EmailOutboxes
     * const emailOutboxes = await prisma.emailOutbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailOutboxWithIdOnly = await prisma.emailOutbox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailOutboxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailOutboxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailOutbox.
     * @param {EmailOutboxCreateArgs} args - Arguments to create a EmailOutbox.
     * @example
     * // Create one EmailOutbox
     * const EmailOutbox = await prisma.emailOutbox.create({
     *   data: {
     *     // ... data to create a EmailOutbox
     *   }
     * })
     * 
    **/
    create<T extends EmailOutboxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailOutboxCreateArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailOutboxes.
     *     @param {EmailOutboxCreateManyArgs} args - Arguments to create many EmailOutboxes.
     *     @example
     *     // Create many EmailOutboxes
     *     const emailOutbox = await prisma.emailOutbox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailOutboxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailOutboxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailOutbox.
     * @param {EmailOutboxDeleteArgs} args - Arguments to delete one EmailOutbox.
     * @example
     * // Delete one EmailOutbox
     * const EmailOutbox = await prisma.emailOutbox.delete({
     *   where: {
     *     // ... filter to delete one EmailOutbox
     *   }
     * })
     * 
    **/
    delete<T extends EmailOutboxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailOutboxDeleteArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailOutbox.
     * @param {EmailOutboxUpdateArgs} args - Arguments to update one EmailOutbox.
     * @example
     * // Update one EmailOutbox
     * const emailOutbox = await prisma.emailOutbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailOutboxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailOutboxUpdateArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailOutboxes.
     * @param {EmailOutboxDeleteManyArgs} args - Arguments to filter EmailOutboxes to delete.
     * @example
     * // Delete a few EmailOutboxes
     * const { count } = await prisma.emailOutbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailOutboxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailOutboxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailOutboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailOutboxes
     * const emailOutbox = await prisma.emailOutbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailOutboxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailOutboxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailOutbox.
     * @param {EmailOutboxUpsertArgs} args - Arguments to update or create a EmailOutbox.
     * @example
     * // Update or create a EmailOutbox
     * const emailOutbox = await prisma.emailOutbox.upsert({
     *   create: {
     *     // ... data to create a EmailOutbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailOutbox we want to update
     *   }
     * })
    **/
    upsert<T extends EmailOutboxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailOutboxUpsertArgs<ExtArgs>>
    ): Prisma__EmailOutboxClient<$Result.GetResult<Prisma.$EmailOutboxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailOutboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxCountArgs} args - Arguments to filter EmailOutboxes to count.
     * @example
     * // Count the number of EmailOutboxes
     * const count = await prisma.emailOutbox.count({
     *   where: {
     *     // ... the filter for the EmailOutboxes we want to count
     *   }
     * })
    **/
    count<T extends EmailOutboxCountArgs>(
      args?: Subset<T, EmailOutboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailOutboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailOutbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailOutboxAggregateArgs>(args: Subset<T, EmailOutboxAggregateArgs>): Prisma.PrismaPromise<GetEmailOutboxAggregateType<T>>

    /**
     * Group by EmailOutbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailOutboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailOutboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailOutboxGroupByArgs['orderBy'] }
        : { orderBy?: EmailOutboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailOutboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailOutboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailOutbox model
   */
  readonly fields: EmailOutboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailOutbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailOutboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailOutbox model
   */ 
  interface EmailOutboxFieldRefs {
    readonly id: FieldRef<"EmailOutbox", 'String'>
    readonly fromName: FieldRef<"EmailOutbox", 'String'>
    readonly fromAddress: FieldRef<"EmailOutbox", 'String'>
    readonly toAddresses: FieldRef<"EmailOutbox", 'String[]'>
    readonly ccAddresses: FieldRef<"EmailOutbox", 'String[]'>
    readonly bccAddresses: FieldRef<"EmailOutbox", 'String[]'>
    readonly subject: FieldRef<"EmailOutbox", 'String'>
    readonly textBody: FieldRef<"EmailOutbox", 'String'>
    readonly htmlBody: FieldRef<"EmailOutbox", 'String'>
    readonly sendAt: FieldRef<"EmailOutbox", 'DateTime'>
    readonly status: FieldRef<"EmailOutbox", 'OutboxStatus'>
    readonly sentEmailId: FieldRef<"EmailOutbox", 'String'>
    readonly errorMessage: FieldRef<"EmailOutbox", 'String'>
    readonly attempts: FieldRef<"EmailOutbox", 'Int'>
    readonly userId: FieldRef<"EmailOutbox", 'String'>
    readonly createdAt: FieldRef<"EmailOutbox", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailOutbox", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailOutbox findUnique
   */
  export type EmailOutboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * Filter, which EmailOutbox to fetch.
     */
    where: EmailOutboxWhereUniqueInput
  }


  /**
   * EmailOutbox findUniqueOrThrow
   */
  export type EmailOutboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * Filter, which EmailOutbox to fetch.
     */
    where: EmailOutboxWhereUniqueInput
  }


  /**
   * EmailOutbox findFirst
   */
  export type EmailOutboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * Filter, which EmailOutbox to fetch.
     */
    where?: EmailOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOutboxes to fetch.
     */
    orderBy?: EmailOutboxOrderByWithRelationInput | EmailOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailOutboxes.
     */
    cursor?: EmailOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOutboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailOutboxes.
     */
    distinct?: EmailOutboxScalarFieldEnum | EmailOutboxScalarFieldEnum[]
  }


  /**
   * EmailOutbox findFirstOrThrow
   */
  export type EmailOutboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * Filter, which EmailOutbox to fetch.
     */
    where?: EmailOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOutboxes to fetch.
     */
    orderBy?: EmailOutboxOrderByWithRelationInput | EmailOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailOutboxes.
     */
    cursor?: EmailOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOutboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailOutboxes.
     */
    distinct?: EmailOutboxScalarFieldEnum | EmailOutboxScalarFieldEnum[]
  }


  /**
   * EmailOutbox findMany
   */
  export type EmailOutboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * Filter, which EmailOutboxes to fetch.
     */
    where?: EmailOutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailOutboxes to fetch.
     */
    orderBy?: EmailOutboxOrderByWithRelationInput | EmailOutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailOutboxes.
     */
    cursor?: EmailOutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailOutboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailOutboxes.
     */
    skip?: number
    distinct?: EmailOutboxScalarFieldEnum | EmailOutboxScalarFieldEnum[]
  }


  /**
   * EmailOutbox create
   */
  export type EmailOutboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailOutbox.
     */
    data: XOR<EmailOutboxCreateInput, EmailOutboxUncheckedCreateInput>
  }


  /**
   * EmailOutbox createMany
   */
  export type EmailOutboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailOutboxes.
     */
    data: EmailOutboxCreateManyInput | EmailOutboxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailOutbox update
   */
  export type EmailOutboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailOutbox.
     */
    data: XOR<EmailOutboxUpdateInput, EmailOutboxUncheckedUpdateInput>
    /**
     * Choose, which EmailOutbox to update.
     */
    where: EmailOutboxWhereUniqueInput
  }


  /**
   * EmailOutbox updateMany
   */
  export type EmailOutboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailOutboxes.
     */
    data: XOR<EmailOutboxUpdateManyMutationInput, EmailOutboxUncheckedUpdateManyInput>
    /**
     * Filter which EmailOutboxes to update
     */
    where?: EmailOutboxWhereInput
  }


  /**
   * EmailOutbox upsert
   */
  export type EmailOutboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailOutbox to update in case it exists.
     */
    where: EmailOutboxWhereUniqueInput
    /**
     * In case the EmailOutbox found by the `where` argument doesn't exist, create a new EmailOutbox with this data.
     */
    create: XOR<EmailOutboxCreateInput, EmailOutboxUncheckedCreateInput>
    /**
     * In case the EmailOutbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailOutboxUpdateInput, EmailOutboxUncheckedUpdateInput>
  }


  /**
   * EmailOutbox delete
   */
  export type EmailOutboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
    /**
     * Filter which EmailOutbox to delete.
     */
    where: EmailOutboxWhereUniqueInput
  }


  /**
   * EmailOutbox deleteMany
   */
  export type EmailOutboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailOutboxes to delete
     */
    where?: EmailOutboxWhereInput
  }


  /**
   * EmailOutbox without action
   */
  export type EmailOutboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailOutbox
     */
    select?: EmailOutboxSelect<ExtArgs> | null
  }



  /**
   * Model EmailDomain
   */

  export type AggregateEmailDomain = {
    _count: EmailDomainCountAggregateOutputType | null
    _avg: EmailDomainAvgAggregateOutputType | null
    _sum: EmailDomainSumAggregateOutputType | null
    _min: EmailDomainMinAggregateOutputType | null
    _max: EmailDomainMaxAggregateOutputType | null
  }

  export type EmailDomainAvgAggregateOutputType = {
    maxMailboxes: number | null
    maxAliases: number | null
    totalStorageQuotaMb: number | null
    usedStorageMb: number | null
  }

  export type EmailDomainSumAggregateOutputType = {
    maxMailboxes: number | null
    maxAliases: number | null
    totalStorageQuotaMb: number | null
    usedStorageMb: number | null
  }

  export type EmailDomainMinAggregateOutputType = {
    id: string | null
    domain: string | null
    isVerified: boolean | null
    isActive: boolean | null
    verificationCode: string | null
    verificationMethod: string | null
    verifiedAt: Date | null
    dkimSelector: string | null
    dkimPublicKey: string | null
    dkimPrivateKey: string | null
    dkimVerified: boolean | null
    spfRecord: string | null
    spfVerified: boolean | null
    dmarcPolicy: string | null
    dmarcRecord: string | null
    dmarcVerified: boolean | null
    mxVerified: boolean | null
    catchAllEnabled: boolean | null
    catchAllMailboxId: string | null
    maxMailboxes: number | null
    maxAliases: number | null
    totalStorageQuotaMb: number | null
    usedStorageMb: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailDomainMaxAggregateOutputType = {
    id: string | null
    domain: string | null
    isVerified: boolean | null
    isActive: boolean | null
    verificationCode: string | null
    verificationMethod: string | null
    verifiedAt: Date | null
    dkimSelector: string | null
    dkimPublicKey: string | null
    dkimPrivateKey: string | null
    dkimVerified: boolean | null
    spfRecord: string | null
    spfVerified: boolean | null
    dmarcPolicy: string | null
    dmarcRecord: string | null
    dmarcVerified: boolean | null
    mxVerified: boolean | null
    catchAllEnabled: boolean | null
    catchAllMailboxId: string | null
    maxMailboxes: number | null
    maxAliases: number | null
    totalStorageQuotaMb: number | null
    usedStorageMb: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailDomainCountAggregateOutputType = {
    id: number
    domain: number
    isVerified: number
    isActive: number
    verificationCode: number
    verificationMethod: number
    verifiedAt: number
    dkimSelector: number
    dkimPublicKey: number
    dkimPrivateKey: number
    dkimVerified: number
    spfRecord: number
    spfVerified: number
    dmarcPolicy: number
    dmarcRecord: number
    dmarcVerified: number
    mxVerified: number
    catchAllEnabled: number
    catchAllMailboxId: number
    maxMailboxes: number
    maxAliases: number
    totalStorageQuotaMb: number
    usedStorageMb: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailDomainAvgAggregateInputType = {
    maxMailboxes?: true
    maxAliases?: true
    totalStorageQuotaMb?: true
    usedStorageMb?: true
  }

  export type EmailDomainSumAggregateInputType = {
    maxMailboxes?: true
    maxAliases?: true
    totalStorageQuotaMb?: true
    usedStorageMb?: true
  }

  export type EmailDomainMinAggregateInputType = {
    id?: true
    domain?: true
    isVerified?: true
    isActive?: true
    verificationCode?: true
    verificationMethod?: true
    verifiedAt?: true
    dkimSelector?: true
    dkimPublicKey?: true
    dkimPrivateKey?: true
    dkimVerified?: true
    spfRecord?: true
    spfVerified?: true
    dmarcPolicy?: true
    dmarcRecord?: true
    dmarcVerified?: true
    mxVerified?: true
    catchAllEnabled?: true
    catchAllMailboxId?: true
    maxMailboxes?: true
    maxAliases?: true
    totalStorageQuotaMb?: true
    usedStorageMb?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailDomainMaxAggregateInputType = {
    id?: true
    domain?: true
    isVerified?: true
    isActive?: true
    verificationCode?: true
    verificationMethod?: true
    verifiedAt?: true
    dkimSelector?: true
    dkimPublicKey?: true
    dkimPrivateKey?: true
    dkimVerified?: true
    spfRecord?: true
    spfVerified?: true
    dmarcPolicy?: true
    dmarcRecord?: true
    dmarcVerified?: true
    mxVerified?: true
    catchAllEnabled?: true
    catchAllMailboxId?: true
    maxMailboxes?: true
    maxAliases?: true
    totalStorageQuotaMb?: true
    usedStorageMb?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailDomainCountAggregateInputType = {
    id?: true
    domain?: true
    isVerified?: true
    isActive?: true
    verificationCode?: true
    verificationMethod?: true
    verifiedAt?: true
    dkimSelector?: true
    dkimPublicKey?: true
    dkimPrivateKey?: true
    dkimVerified?: true
    spfRecord?: true
    spfVerified?: true
    dmarcPolicy?: true
    dmarcRecord?: true
    dmarcVerified?: true
    mxVerified?: true
    catchAllEnabled?: true
    catchAllMailboxId?: true
    maxMailboxes?: true
    maxAliases?: true
    totalStorageQuotaMb?: true
    usedStorageMb?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailDomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailDomain to aggregate.
     */
    where?: EmailDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailDomains to fetch.
     */
    orderBy?: EmailDomainOrderByWithRelationInput | EmailDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailDomains
    **/
    _count?: true | EmailDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailDomainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailDomainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailDomainMaxAggregateInputType
  }

  export type GetEmailDomainAggregateType<T extends EmailDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailDomain[P]>
      : GetScalarType<T[P], AggregateEmailDomain[P]>
  }




  export type EmailDomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailDomainWhereInput
    orderBy?: EmailDomainOrderByWithAggregationInput | EmailDomainOrderByWithAggregationInput[]
    by: EmailDomainScalarFieldEnum[] | EmailDomainScalarFieldEnum
    having?: EmailDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailDomainCountAggregateInputType | true
    _avg?: EmailDomainAvgAggregateInputType
    _sum?: EmailDomainSumAggregateInputType
    _min?: EmailDomainMinAggregateInputType
    _max?: EmailDomainMaxAggregateInputType
  }

  export type EmailDomainGroupByOutputType = {
    id: string
    domain: string
    isVerified: boolean
    isActive: boolean
    verificationCode: string | null
    verificationMethod: string
    verifiedAt: Date | null
    dkimSelector: string | null
    dkimPublicKey: string | null
    dkimPrivateKey: string | null
    dkimVerified: boolean
    spfRecord: string | null
    spfVerified: boolean
    dmarcPolicy: string
    dmarcRecord: string | null
    dmarcVerified: boolean
    mxVerified: boolean
    catchAllEnabled: boolean
    catchAllMailboxId: string | null
    maxMailboxes: number
    maxAliases: number
    totalStorageQuotaMb: number
    usedStorageMb: number
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailDomainCountAggregateOutputType | null
    _avg: EmailDomainAvgAggregateOutputType | null
    _sum: EmailDomainSumAggregateOutputType | null
    _min: EmailDomainMinAggregateOutputType | null
    _max: EmailDomainMaxAggregateOutputType | null
  }

  type GetEmailDomainGroupByPayload<T extends EmailDomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailDomainGroupByOutputType[P]>
            : GetScalarType<T[P], EmailDomainGroupByOutputType[P]>
        }
      >
    >


  export type EmailDomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: boolean
    verificationMethod?: boolean
    verifiedAt?: boolean
    dkimSelector?: boolean
    dkimPublicKey?: boolean
    dkimPrivateKey?: boolean
    dkimVerified?: boolean
    spfRecord?: boolean
    spfVerified?: boolean
    dmarcPolicy?: boolean
    dmarcRecord?: boolean
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: boolean
    maxMailboxes?: boolean
    maxAliases?: boolean
    totalStorageQuotaMb?: boolean
    usedStorageMb?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mailboxes?: boolean | EmailDomain$mailboxesArgs<ExtArgs>
    aliases?: boolean | EmailDomain$aliasesArgs<ExtArgs>
    dnsRecords?: boolean | EmailDomain$dnsRecordsArgs<ExtArgs>
    _count?: boolean | EmailDomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailDomain"]>

  export type EmailDomainSelectScalar = {
    id?: boolean
    domain?: boolean
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: boolean
    verificationMethod?: boolean
    verifiedAt?: boolean
    dkimSelector?: boolean
    dkimPublicKey?: boolean
    dkimPrivateKey?: boolean
    dkimVerified?: boolean
    spfRecord?: boolean
    spfVerified?: boolean
    dmarcPolicy?: boolean
    dmarcRecord?: boolean
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: boolean
    maxMailboxes?: boolean
    maxAliases?: boolean
    totalStorageQuotaMb?: boolean
    usedStorageMb?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailDomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mailboxes?: boolean | EmailDomain$mailboxesArgs<ExtArgs>
    aliases?: boolean | EmailDomain$aliasesArgs<ExtArgs>
    dnsRecords?: boolean | EmailDomain$dnsRecordsArgs<ExtArgs>
    _count?: boolean | EmailDomainCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailDomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailDomain"
    objects: {
      mailboxes: Prisma.$MailboxPayload<ExtArgs>[]
      aliases: Prisma.$EmailAliasPayload<ExtArgs>[]
      dnsRecords: Prisma.$DomainDNSPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domain: string
      isVerified: boolean
      isActive: boolean
      verificationCode: string | null
      verificationMethod: string
      verifiedAt: Date | null
      dkimSelector: string | null
      dkimPublicKey: string | null
      dkimPrivateKey: string | null
      dkimVerified: boolean
      spfRecord: string | null
      spfVerified: boolean
      dmarcPolicy: string
      dmarcRecord: string | null
      dmarcVerified: boolean
      mxVerified: boolean
      catchAllEnabled: boolean
      catchAllMailboxId: string | null
      maxMailboxes: number
      maxAliases: number
      totalStorageQuotaMb: number
      usedStorageMb: number
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailDomain"]>
    composites: {}
  }


  type EmailDomainGetPayload<S extends boolean | null | undefined | EmailDomainDefaultArgs> = $Result.GetResult<Prisma.$EmailDomainPayload, S>

  type EmailDomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailDomainFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailDomainCountAggregateInputType | true
    }

  export interface EmailDomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailDomain'], meta: { name: 'EmailDomain' } }
    /**
     * Find zero or one EmailDomain that matches the filter.
     * @param {EmailDomainFindUniqueArgs} args - Arguments to find a EmailDomain
     * @example
     * // Get one EmailDomain
     * const emailDomain = await prisma.emailDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailDomainFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDomainFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailDomain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailDomainFindUniqueOrThrowArgs} args - Arguments to find a EmailDomain
     * @example
     * // Get one EmailDomain
     * const emailDomain = await prisma.emailDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailDomainFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDomainFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainFindFirstArgs} args - Arguments to find a EmailDomain
     * @example
     * // Get one EmailDomain
     * const emailDomain = await prisma.emailDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailDomainFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDomainFindFirstArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailDomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainFindFirstOrThrowArgs} args - Arguments to find a EmailDomain
     * @example
     * // Get one EmailDomain
     * const emailDomain = await prisma.emailDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailDomainFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDomainFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailDomains
     * const emailDomains = await prisma.emailDomain.findMany()
     * 
     * // Get first 10 EmailDomains
     * const emailDomains = await prisma.emailDomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailDomainWithIdOnly = await prisma.emailDomain.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailDomainFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDomainFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailDomain.
     * @param {EmailDomainCreateArgs} args - Arguments to create a EmailDomain.
     * @example
     * // Create one EmailDomain
     * const EmailDomain = await prisma.emailDomain.create({
     *   data: {
     *     // ... data to create a EmailDomain
     *   }
     * })
     * 
    **/
    create<T extends EmailDomainCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDomainCreateArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailDomains.
     *     @param {EmailDomainCreateManyArgs} args - Arguments to create many EmailDomains.
     *     @example
     *     // Create many EmailDomains
     *     const emailDomain = await prisma.emailDomain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailDomainCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDomainCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailDomain.
     * @param {EmailDomainDeleteArgs} args - Arguments to delete one EmailDomain.
     * @example
     * // Delete one EmailDomain
     * const EmailDomain = await prisma.emailDomain.delete({
     *   where: {
     *     // ... filter to delete one EmailDomain
     *   }
     * })
     * 
    **/
    delete<T extends EmailDomainDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDomainDeleteArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailDomain.
     * @param {EmailDomainUpdateArgs} args - Arguments to update one EmailDomain.
     * @example
     * // Update one EmailDomain
     * const emailDomain = await prisma.emailDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailDomainUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDomainUpdateArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailDomains.
     * @param {EmailDomainDeleteManyArgs} args - Arguments to filter EmailDomains to delete.
     * @example
     * // Delete a few EmailDomains
     * const { count } = await prisma.emailDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailDomainDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDomainDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailDomains
     * const emailDomain = await prisma.emailDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailDomainUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDomainUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailDomain.
     * @param {EmailDomainUpsertArgs} args - Arguments to update or create a EmailDomain.
     * @example
     * // Update or create a EmailDomain
     * const emailDomain = await prisma.emailDomain.upsert({
     *   create: {
     *     // ... data to create a EmailDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailDomain we want to update
     *   }
     * })
    **/
    upsert<T extends EmailDomainUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDomainUpsertArgs<ExtArgs>>
    ): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainCountArgs} args - Arguments to filter EmailDomains to count.
     * @example
     * // Count the number of EmailDomains
     * const count = await prisma.emailDomain.count({
     *   where: {
     *     // ... the filter for the EmailDomains we want to count
     *   }
     * })
    **/
    count<T extends EmailDomainCountArgs>(
      args?: Subset<T, EmailDomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailDomainAggregateArgs>(args: Subset<T, EmailDomainAggregateArgs>): Prisma.PrismaPromise<GetEmailDomainAggregateType<T>>

    /**
     * Group by EmailDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailDomainGroupByArgs['orderBy'] }
        : { orderBy?: EmailDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailDomain model
   */
  readonly fields: EmailDomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailDomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    mailboxes<T extends EmailDomain$mailboxesArgs<ExtArgs> = {}>(args?: Subset<T, EmailDomain$mailboxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findMany'> | Null>;

    aliases<T extends EmailDomain$aliasesArgs<ExtArgs> = {}>(args?: Subset<T, EmailDomain$aliasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findMany'> | Null>;

    dnsRecords<T extends EmailDomain$dnsRecordsArgs<ExtArgs> = {}>(args?: Subset<T, EmailDomain$dnsRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailDomain model
   */ 
  interface EmailDomainFieldRefs {
    readonly id: FieldRef<"EmailDomain", 'String'>
    readonly domain: FieldRef<"EmailDomain", 'String'>
    readonly isVerified: FieldRef<"EmailDomain", 'Boolean'>
    readonly isActive: FieldRef<"EmailDomain", 'Boolean'>
    readonly verificationCode: FieldRef<"EmailDomain", 'String'>
    readonly verificationMethod: FieldRef<"EmailDomain", 'String'>
    readonly verifiedAt: FieldRef<"EmailDomain", 'DateTime'>
    readonly dkimSelector: FieldRef<"EmailDomain", 'String'>
    readonly dkimPublicKey: FieldRef<"EmailDomain", 'String'>
    readonly dkimPrivateKey: FieldRef<"EmailDomain", 'String'>
    readonly dkimVerified: FieldRef<"EmailDomain", 'Boolean'>
    readonly spfRecord: FieldRef<"EmailDomain", 'String'>
    readonly spfVerified: FieldRef<"EmailDomain", 'Boolean'>
    readonly dmarcPolicy: FieldRef<"EmailDomain", 'String'>
    readonly dmarcRecord: FieldRef<"EmailDomain", 'String'>
    readonly dmarcVerified: FieldRef<"EmailDomain", 'Boolean'>
    readonly mxVerified: FieldRef<"EmailDomain", 'Boolean'>
    readonly catchAllEnabled: FieldRef<"EmailDomain", 'Boolean'>
    readonly catchAllMailboxId: FieldRef<"EmailDomain", 'String'>
    readonly maxMailboxes: FieldRef<"EmailDomain", 'Int'>
    readonly maxAliases: FieldRef<"EmailDomain", 'Int'>
    readonly totalStorageQuotaMb: FieldRef<"EmailDomain", 'Int'>
    readonly usedStorageMb: FieldRef<"EmailDomain", 'Int'>
    readonly companyId: FieldRef<"EmailDomain", 'String'>
    readonly createdAt: FieldRef<"EmailDomain", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailDomain", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailDomain findUnique
   */
  export type EmailDomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * Filter, which EmailDomain to fetch.
     */
    where: EmailDomainWhereUniqueInput
  }


  /**
   * EmailDomain findUniqueOrThrow
   */
  export type EmailDomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * Filter, which EmailDomain to fetch.
     */
    where: EmailDomainWhereUniqueInput
  }


  /**
   * EmailDomain findFirst
   */
  export type EmailDomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * Filter, which EmailDomain to fetch.
     */
    where?: EmailDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailDomains to fetch.
     */
    orderBy?: EmailDomainOrderByWithRelationInput | EmailDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailDomains.
     */
    cursor?: EmailDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailDomains.
     */
    distinct?: EmailDomainScalarFieldEnum | EmailDomainScalarFieldEnum[]
  }


  /**
   * EmailDomain findFirstOrThrow
   */
  export type EmailDomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * Filter, which EmailDomain to fetch.
     */
    where?: EmailDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailDomains to fetch.
     */
    orderBy?: EmailDomainOrderByWithRelationInput | EmailDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailDomains.
     */
    cursor?: EmailDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailDomains.
     */
    distinct?: EmailDomainScalarFieldEnum | EmailDomainScalarFieldEnum[]
  }


  /**
   * EmailDomain findMany
   */
  export type EmailDomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * Filter, which EmailDomains to fetch.
     */
    where?: EmailDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailDomains to fetch.
     */
    orderBy?: EmailDomainOrderByWithRelationInput | EmailDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailDomains.
     */
    cursor?: EmailDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailDomains.
     */
    skip?: number
    distinct?: EmailDomainScalarFieldEnum | EmailDomainScalarFieldEnum[]
  }


  /**
   * EmailDomain create
   */
  export type EmailDomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailDomain.
     */
    data: XOR<EmailDomainCreateInput, EmailDomainUncheckedCreateInput>
  }


  /**
   * EmailDomain createMany
   */
  export type EmailDomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailDomains.
     */
    data: EmailDomainCreateManyInput | EmailDomainCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailDomain update
   */
  export type EmailDomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailDomain.
     */
    data: XOR<EmailDomainUpdateInput, EmailDomainUncheckedUpdateInput>
    /**
     * Choose, which EmailDomain to update.
     */
    where: EmailDomainWhereUniqueInput
  }


  /**
   * EmailDomain updateMany
   */
  export type EmailDomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailDomains.
     */
    data: XOR<EmailDomainUpdateManyMutationInput, EmailDomainUncheckedUpdateManyInput>
    /**
     * Filter which EmailDomains to update
     */
    where?: EmailDomainWhereInput
  }


  /**
   * EmailDomain upsert
   */
  export type EmailDomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailDomain to update in case it exists.
     */
    where: EmailDomainWhereUniqueInput
    /**
     * In case the EmailDomain found by the `where` argument doesn't exist, create a new EmailDomain with this data.
     */
    create: XOR<EmailDomainCreateInput, EmailDomainUncheckedCreateInput>
    /**
     * In case the EmailDomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailDomainUpdateInput, EmailDomainUncheckedUpdateInput>
  }


  /**
   * EmailDomain delete
   */
  export type EmailDomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
    /**
     * Filter which EmailDomain to delete.
     */
    where: EmailDomainWhereUniqueInput
  }


  /**
   * EmailDomain deleteMany
   */
  export type EmailDomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailDomains to delete
     */
    where?: EmailDomainWhereInput
  }


  /**
   * EmailDomain.mailboxes
   */
  export type EmailDomain$mailboxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    where?: MailboxWhereInput
    orderBy?: MailboxOrderByWithRelationInput | MailboxOrderByWithRelationInput[]
    cursor?: MailboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MailboxScalarFieldEnum | MailboxScalarFieldEnum[]
  }


  /**
   * EmailDomain.aliases
   */
  export type EmailDomain$aliasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    where?: EmailAliasWhereInput
    orderBy?: EmailAliasOrderByWithRelationInput | EmailAliasOrderByWithRelationInput[]
    cursor?: EmailAliasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAliasScalarFieldEnum | EmailAliasScalarFieldEnum[]
  }


  /**
   * EmailDomain.dnsRecords
   */
  export type EmailDomain$dnsRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    where?: DomainDNSWhereInput
    orderBy?: DomainDNSOrderByWithRelationInput | DomainDNSOrderByWithRelationInput[]
    cursor?: DomainDNSWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainDNSScalarFieldEnum | DomainDNSScalarFieldEnum[]
  }


  /**
   * EmailDomain without action
   */
  export type EmailDomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailDomain
     */
    select?: EmailDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailDomainInclude<ExtArgs> | null
  }



  /**
   * Model Mailbox
   */

  export type AggregateMailbox = {
    _count: MailboxCountAggregateOutputType | null
    _avg: MailboxAvgAggregateOutputType | null
    _sum: MailboxSumAggregateOutputType | null
    _min: MailboxMinAggregateOutputType | null
    _max: MailboxMaxAggregateOutputType | null
  }

  export type MailboxAvgAggregateOutputType = {
    quotaMb: number | null
    usedMb: number | null
    maxSendPerDay: number | null
    sentToday: number | null
  }

  export type MailboxSumAggregateOutputType = {
    quotaMb: number | null
    usedMb: number | null
    maxSendPerDay: number | null
    sentToday: number | null
  }

  export type MailboxMinAggregateOutputType = {
    id: string | null
    localPart: string | null
    displayName: string | null
    passwordHash: string | null
    quotaMb: number | null
    usedMb: number | null
    maxSendPerDay: number | null
    sentToday: number | null
    lastSentReset: Date | null
    isActive: boolean | null
    isAdmin: boolean | null
    autoReply: boolean | null
    autoReplySubject: string | null
    autoReplyMessage: string | null
    autoReplyStart: Date | null
    autoReplyEnd: Date | null
    forwardingEnabled: boolean | null
    forwardingAddress: string | null
    keepCopy: boolean | null
    spamFilterLevel: string | null
    spamAction: string | null
    signatureHtml: string | null
    signatureText: string | null
    userId: string | null
    domainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailboxMaxAggregateOutputType = {
    id: string | null
    localPart: string | null
    displayName: string | null
    passwordHash: string | null
    quotaMb: number | null
    usedMb: number | null
    maxSendPerDay: number | null
    sentToday: number | null
    lastSentReset: Date | null
    isActive: boolean | null
    isAdmin: boolean | null
    autoReply: boolean | null
    autoReplySubject: string | null
    autoReplyMessage: string | null
    autoReplyStart: Date | null
    autoReplyEnd: Date | null
    forwardingEnabled: boolean | null
    forwardingAddress: string | null
    keepCopy: boolean | null
    spamFilterLevel: string | null
    spamAction: string | null
    signatureHtml: string | null
    signatureText: string | null
    userId: string | null
    domainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailboxCountAggregateOutputType = {
    id: number
    localPart: number
    displayName: number
    passwordHash: number
    quotaMb: number
    usedMb: number
    maxSendPerDay: number
    sentToday: number
    lastSentReset: number
    isActive: number
    isAdmin: number
    autoReply: number
    autoReplySubject: number
    autoReplyMessage: number
    autoReplyStart: number
    autoReplyEnd: number
    forwardingEnabled: number
    forwardingAddress: number
    keepCopy: number
    spamFilterLevel: number
    spamAction: number
    signatureHtml: number
    signatureText: number
    userId: number
    domainId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MailboxAvgAggregateInputType = {
    quotaMb?: true
    usedMb?: true
    maxSendPerDay?: true
    sentToday?: true
  }

  export type MailboxSumAggregateInputType = {
    quotaMb?: true
    usedMb?: true
    maxSendPerDay?: true
    sentToday?: true
  }

  export type MailboxMinAggregateInputType = {
    id?: true
    localPart?: true
    displayName?: true
    passwordHash?: true
    quotaMb?: true
    usedMb?: true
    maxSendPerDay?: true
    sentToday?: true
    lastSentReset?: true
    isActive?: true
    isAdmin?: true
    autoReply?: true
    autoReplySubject?: true
    autoReplyMessage?: true
    autoReplyStart?: true
    autoReplyEnd?: true
    forwardingEnabled?: true
    forwardingAddress?: true
    keepCopy?: true
    spamFilterLevel?: true
    spamAction?: true
    signatureHtml?: true
    signatureText?: true
    userId?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailboxMaxAggregateInputType = {
    id?: true
    localPart?: true
    displayName?: true
    passwordHash?: true
    quotaMb?: true
    usedMb?: true
    maxSendPerDay?: true
    sentToday?: true
    lastSentReset?: true
    isActive?: true
    isAdmin?: true
    autoReply?: true
    autoReplySubject?: true
    autoReplyMessage?: true
    autoReplyStart?: true
    autoReplyEnd?: true
    forwardingEnabled?: true
    forwardingAddress?: true
    keepCopy?: true
    spamFilterLevel?: true
    spamAction?: true
    signatureHtml?: true
    signatureText?: true
    userId?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailboxCountAggregateInputType = {
    id?: true
    localPart?: true
    displayName?: true
    passwordHash?: true
    quotaMb?: true
    usedMb?: true
    maxSendPerDay?: true
    sentToday?: true
    lastSentReset?: true
    isActive?: true
    isAdmin?: true
    autoReply?: true
    autoReplySubject?: true
    autoReplyMessage?: true
    autoReplyStart?: true
    autoReplyEnd?: true
    forwardingEnabled?: true
    forwardingAddress?: true
    keepCopy?: true
    spamFilterLevel?: true
    spamAction?: true
    signatureHtml?: true
    signatureText?: true
    userId?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MailboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mailbox to aggregate.
     */
    where?: MailboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mailboxes to fetch.
     */
    orderBy?: MailboxOrderByWithRelationInput | MailboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mailboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mailboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mailboxes
    **/
    _count?: true | MailboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MailboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MailboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailboxMaxAggregateInputType
  }

  export type GetMailboxAggregateType<T extends MailboxAggregateArgs> = {
        [P in keyof T & keyof AggregateMailbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailbox[P]>
      : GetScalarType<T[P], AggregateMailbox[P]>
  }




  export type MailboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailboxWhereInput
    orderBy?: MailboxOrderByWithAggregationInput | MailboxOrderByWithAggregationInput[]
    by: MailboxScalarFieldEnum[] | MailboxScalarFieldEnum
    having?: MailboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailboxCountAggregateInputType | true
    _avg?: MailboxAvgAggregateInputType
    _sum?: MailboxSumAggregateInputType
    _min?: MailboxMinAggregateInputType
    _max?: MailboxMaxAggregateInputType
  }

  export type MailboxGroupByOutputType = {
    id: string
    localPart: string
    displayName: string | null
    passwordHash: string
    quotaMb: number
    usedMb: number
    maxSendPerDay: number
    sentToday: number
    lastSentReset: Date
    isActive: boolean
    isAdmin: boolean
    autoReply: boolean
    autoReplySubject: string | null
    autoReplyMessage: string | null
    autoReplyStart: Date | null
    autoReplyEnd: Date | null
    forwardingEnabled: boolean
    forwardingAddress: string | null
    keepCopy: boolean
    spamFilterLevel: string
    spamAction: string
    signatureHtml: string | null
    signatureText: string | null
    userId: string | null
    domainId: string
    createdAt: Date
    updatedAt: Date
    _count: MailboxCountAggregateOutputType | null
    _avg: MailboxAvgAggregateOutputType | null
    _sum: MailboxSumAggregateOutputType | null
    _min: MailboxMinAggregateOutputType | null
    _max: MailboxMaxAggregateOutputType | null
  }

  type GetMailboxGroupByPayload<T extends MailboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailboxGroupByOutputType[P]>
            : GetScalarType<T[P], MailboxGroupByOutputType[P]>
        }
      >
    >


  export type MailboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localPart?: boolean
    displayName?: boolean
    passwordHash?: boolean
    quotaMb?: boolean
    usedMb?: boolean
    maxSendPerDay?: boolean
    sentToday?: boolean
    lastSentReset?: boolean
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: boolean
    autoReplyMessage?: boolean
    autoReplyStart?: boolean
    autoReplyEnd?: boolean
    forwardingEnabled?: boolean
    forwardingAddress?: boolean
    keepCopy?: boolean
    spamFilterLevel?: boolean
    spamAction?: boolean
    signatureHtml?: boolean
    signatureText?: boolean
    userId?: boolean
    domainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Mailbox$userArgs<ExtArgs>
    domain?: boolean | EmailDomainDefaultArgs<ExtArgs>
    targetAliases?: boolean | Mailbox$targetAliasesArgs<ExtArgs>
    _count?: boolean | MailboxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mailbox"]>

  export type MailboxSelectScalar = {
    id?: boolean
    localPart?: boolean
    displayName?: boolean
    passwordHash?: boolean
    quotaMb?: boolean
    usedMb?: boolean
    maxSendPerDay?: boolean
    sentToday?: boolean
    lastSentReset?: boolean
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: boolean
    autoReplyMessage?: boolean
    autoReplyStart?: boolean
    autoReplyEnd?: boolean
    forwardingEnabled?: boolean
    forwardingAddress?: boolean
    keepCopy?: boolean
    spamFilterLevel?: boolean
    spamAction?: boolean
    signatureHtml?: boolean
    signatureText?: boolean
    userId?: boolean
    domainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MailboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Mailbox$userArgs<ExtArgs>
    domain?: boolean | EmailDomainDefaultArgs<ExtArgs>
    targetAliases?: boolean | Mailbox$targetAliasesArgs<ExtArgs>
    _count?: boolean | MailboxCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $MailboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mailbox"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      domain: Prisma.$EmailDomainPayload<ExtArgs>
      targetAliases: Prisma.$EmailAliasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      localPart: string
      displayName: string | null
      passwordHash: string
      quotaMb: number
      usedMb: number
      maxSendPerDay: number
      sentToday: number
      lastSentReset: Date
      isActive: boolean
      isAdmin: boolean
      autoReply: boolean
      autoReplySubject: string | null
      autoReplyMessage: string | null
      autoReplyStart: Date | null
      autoReplyEnd: Date | null
      forwardingEnabled: boolean
      forwardingAddress: string | null
      keepCopy: boolean
      spamFilterLevel: string
      spamAction: string
      signatureHtml: string | null
      signatureText: string | null
      userId: string | null
      domainId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mailbox"]>
    composites: {}
  }


  type MailboxGetPayload<S extends boolean | null | undefined | MailboxDefaultArgs> = $Result.GetResult<Prisma.$MailboxPayload, S>

  type MailboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MailboxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MailboxCountAggregateInputType | true
    }

  export interface MailboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mailbox'], meta: { name: 'Mailbox' } }
    /**
     * Find zero or one Mailbox that matches the filter.
     * @param {MailboxFindUniqueArgs} args - Arguments to find a Mailbox
     * @example
     * // Get one Mailbox
     * const mailbox = await prisma.mailbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MailboxFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxFindUniqueArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Mailbox that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MailboxFindUniqueOrThrowArgs} args - Arguments to find a Mailbox
     * @example
     * // Get one Mailbox
     * const mailbox = await prisma.mailbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MailboxFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Mailbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxFindFirstArgs} args - Arguments to find a Mailbox
     * @example
     * // Get one Mailbox
     * const mailbox = await prisma.mailbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MailboxFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxFindFirstArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Mailbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxFindFirstOrThrowArgs} args - Arguments to find a Mailbox
     * @example
     * // Get one Mailbox
     * const mailbox = await prisma.mailbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MailboxFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Mailboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mailboxes
     * const mailboxes = await prisma.mailbox.findMany()
     * 
     * // Get first 10 Mailboxes
     * const mailboxes = await prisma.mailbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailboxWithIdOnly = await prisma.mailbox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MailboxFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Mailbox.
     * @param {MailboxCreateArgs} args - Arguments to create a Mailbox.
     * @example
     * // Create one Mailbox
     * const Mailbox = await prisma.mailbox.create({
     *   data: {
     *     // ... data to create a Mailbox
     *   }
     * })
     * 
    **/
    create<T extends MailboxCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxCreateArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Mailboxes.
     *     @param {MailboxCreateManyArgs} args - Arguments to create many Mailboxes.
     *     @example
     *     // Create many Mailboxes
     *     const mailbox = await prisma.mailbox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MailboxCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mailbox.
     * @param {MailboxDeleteArgs} args - Arguments to delete one Mailbox.
     * @example
     * // Delete one Mailbox
     * const Mailbox = await prisma.mailbox.delete({
     *   where: {
     *     // ... filter to delete one Mailbox
     *   }
     * })
     * 
    **/
    delete<T extends MailboxDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxDeleteArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Mailbox.
     * @param {MailboxUpdateArgs} args - Arguments to update one Mailbox.
     * @example
     * // Update one Mailbox
     * const mailbox = await prisma.mailbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MailboxUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxUpdateArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Mailboxes.
     * @param {MailboxDeleteManyArgs} args - Arguments to filter Mailboxes to delete.
     * @example
     * // Delete a few Mailboxes
     * const { count } = await prisma.mailbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MailboxDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mailboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mailboxes
     * const mailbox = await prisma.mailbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MailboxUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mailbox.
     * @param {MailboxUpsertArgs} args - Arguments to update or create a Mailbox.
     * @example
     * // Update or create a Mailbox
     * const mailbox = await prisma.mailbox.upsert({
     *   create: {
     *     // ... data to create a Mailbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mailbox we want to update
     *   }
     * })
    **/
    upsert<T extends MailboxUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxUpsertArgs<ExtArgs>>
    ): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Mailboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxCountArgs} args - Arguments to filter Mailboxes to count.
     * @example
     * // Count the number of Mailboxes
     * const count = await prisma.mailbox.count({
     *   where: {
     *     // ... the filter for the Mailboxes we want to count
     *   }
     * })
    **/
    count<T extends MailboxCountArgs>(
      args?: Subset<T, MailboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mailbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailboxAggregateArgs>(args: Subset<T, MailboxAggregateArgs>): Prisma.PrismaPromise<GetMailboxAggregateType<T>>

    /**
     * Group by Mailbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailboxGroupByArgs['orderBy'] }
        : { orderBy?: MailboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mailbox model
   */
  readonly fields: MailboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mailbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Mailbox$userArgs<ExtArgs> = {}>(args?: Subset<T, Mailbox$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    domain<T extends EmailDomainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDomainDefaultArgs<ExtArgs>>): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    targetAliases<T extends Mailbox$targetAliasesArgs<ExtArgs> = {}>(args?: Subset<T, Mailbox$targetAliasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Mailbox model
   */ 
  interface MailboxFieldRefs {
    readonly id: FieldRef<"Mailbox", 'String'>
    readonly localPart: FieldRef<"Mailbox", 'String'>
    readonly displayName: FieldRef<"Mailbox", 'String'>
    readonly passwordHash: FieldRef<"Mailbox", 'String'>
    readonly quotaMb: FieldRef<"Mailbox", 'Int'>
    readonly usedMb: FieldRef<"Mailbox", 'Int'>
    readonly maxSendPerDay: FieldRef<"Mailbox", 'Int'>
    readonly sentToday: FieldRef<"Mailbox", 'Int'>
    readonly lastSentReset: FieldRef<"Mailbox", 'DateTime'>
    readonly isActive: FieldRef<"Mailbox", 'Boolean'>
    readonly isAdmin: FieldRef<"Mailbox", 'Boolean'>
    readonly autoReply: FieldRef<"Mailbox", 'Boolean'>
    readonly autoReplySubject: FieldRef<"Mailbox", 'String'>
    readonly autoReplyMessage: FieldRef<"Mailbox", 'String'>
    readonly autoReplyStart: FieldRef<"Mailbox", 'DateTime'>
    readonly autoReplyEnd: FieldRef<"Mailbox", 'DateTime'>
    readonly forwardingEnabled: FieldRef<"Mailbox", 'Boolean'>
    readonly forwardingAddress: FieldRef<"Mailbox", 'String'>
    readonly keepCopy: FieldRef<"Mailbox", 'Boolean'>
    readonly spamFilterLevel: FieldRef<"Mailbox", 'String'>
    readonly spamAction: FieldRef<"Mailbox", 'String'>
    readonly signatureHtml: FieldRef<"Mailbox", 'String'>
    readonly signatureText: FieldRef<"Mailbox", 'String'>
    readonly userId: FieldRef<"Mailbox", 'String'>
    readonly domainId: FieldRef<"Mailbox", 'String'>
    readonly createdAt: FieldRef<"Mailbox", 'DateTime'>
    readonly updatedAt: FieldRef<"Mailbox", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Mailbox findUnique
   */
  export type MailboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * Filter, which Mailbox to fetch.
     */
    where: MailboxWhereUniqueInput
  }


  /**
   * Mailbox findUniqueOrThrow
   */
  export type MailboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * Filter, which Mailbox to fetch.
     */
    where: MailboxWhereUniqueInput
  }


  /**
   * Mailbox findFirst
   */
  export type MailboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * Filter, which Mailbox to fetch.
     */
    where?: MailboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mailboxes to fetch.
     */
    orderBy?: MailboxOrderByWithRelationInput | MailboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mailboxes.
     */
    cursor?: MailboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mailboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mailboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mailboxes.
     */
    distinct?: MailboxScalarFieldEnum | MailboxScalarFieldEnum[]
  }


  /**
   * Mailbox findFirstOrThrow
   */
  export type MailboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * Filter, which Mailbox to fetch.
     */
    where?: MailboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mailboxes to fetch.
     */
    orderBy?: MailboxOrderByWithRelationInput | MailboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mailboxes.
     */
    cursor?: MailboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mailboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mailboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mailboxes.
     */
    distinct?: MailboxScalarFieldEnum | MailboxScalarFieldEnum[]
  }


  /**
   * Mailbox findMany
   */
  export type MailboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * Filter, which Mailboxes to fetch.
     */
    where?: MailboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mailboxes to fetch.
     */
    orderBy?: MailboxOrderByWithRelationInput | MailboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mailboxes.
     */
    cursor?: MailboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mailboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mailboxes.
     */
    skip?: number
    distinct?: MailboxScalarFieldEnum | MailboxScalarFieldEnum[]
  }


  /**
   * Mailbox create
   */
  export type MailboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * The data needed to create a Mailbox.
     */
    data: XOR<MailboxCreateInput, MailboxUncheckedCreateInput>
  }


  /**
   * Mailbox createMany
   */
  export type MailboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mailboxes.
     */
    data: MailboxCreateManyInput | MailboxCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Mailbox update
   */
  export type MailboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * The data needed to update a Mailbox.
     */
    data: XOR<MailboxUpdateInput, MailboxUncheckedUpdateInput>
    /**
     * Choose, which Mailbox to update.
     */
    where: MailboxWhereUniqueInput
  }


  /**
   * Mailbox updateMany
   */
  export type MailboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mailboxes.
     */
    data: XOR<MailboxUpdateManyMutationInput, MailboxUncheckedUpdateManyInput>
    /**
     * Filter which Mailboxes to update
     */
    where?: MailboxWhereInput
  }


  /**
   * Mailbox upsert
   */
  export type MailboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * The filter to search for the Mailbox to update in case it exists.
     */
    where: MailboxWhereUniqueInput
    /**
     * In case the Mailbox found by the `where` argument doesn't exist, create a new Mailbox with this data.
     */
    create: XOR<MailboxCreateInput, MailboxUncheckedCreateInput>
    /**
     * In case the Mailbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailboxUpdateInput, MailboxUncheckedUpdateInput>
  }


  /**
   * Mailbox delete
   */
  export type MailboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    /**
     * Filter which Mailbox to delete.
     */
    where: MailboxWhereUniqueInput
  }


  /**
   * Mailbox deleteMany
   */
  export type MailboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mailboxes to delete
     */
    where?: MailboxWhereInput
  }


  /**
   * Mailbox.user
   */
  export type Mailbox$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Mailbox.targetAliases
   */
  export type Mailbox$targetAliasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    where?: EmailAliasWhereInput
    orderBy?: EmailAliasOrderByWithRelationInput | EmailAliasOrderByWithRelationInput[]
    cursor?: EmailAliasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAliasScalarFieldEnum | EmailAliasScalarFieldEnum[]
  }


  /**
   * Mailbox without action
   */
  export type MailboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
  }



  /**
   * Model EmailAlias
   */

  export type AggregateEmailAlias = {
    _count: EmailAliasCountAggregateOutputType | null
    _min: EmailAliasMinAggregateOutputType | null
    _max: EmailAliasMaxAggregateOutputType | null
  }

  export type EmailAliasMinAggregateOutputType = {
    id: string | null
    localPart: string | null
    targetMailboxId: string | null
    externalTarget: string | null
    isActive: boolean | null
    domainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAliasMaxAggregateOutputType = {
    id: string | null
    localPart: string | null
    targetMailboxId: string | null
    externalTarget: string | null
    isActive: boolean | null
    domainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailAliasCountAggregateOutputType = {
    id: number
    localPart: number
    targetMailboxId: number
    externalTarget: number
    isActive: number
    domainId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailAliasMinAggregateInputType = {
    id?: true
    localPart?: true
    targetMailboxId?: true
    externalTarget?: true
    isActive?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAliasMaxAggregateInputType = {
    id?: true
    localPart?: true
    targetMailboxId?: true
    externalTarget?: true
    isActive?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailAliasCountAggregateInputType = {
    id?: true
    localPart?: true
    targetMailboxId?: true
    externalTarget?: true
    isActive?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailAliasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAlias to aggregate.
     */
    where?: EmailAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAliases to fetch.
     */
    orderBy?: EmailAliasOrderByWithRelationInput | EmailAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAliases
    **/
    _count?: true | EmailAliasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAliasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAliasMaxAggregateInputType
  }

  export type GetEmailAliasAggregateType<T extends EmailAliasAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAlias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAlias[P]>
      : GetScalarType<T[P], AggregateEmailAlias[P]>
  }




  export type EmailAliasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAliasWhereInput
    orderBy?: EmailAliasOrderByWithAggregationInput | EmailAliasOrderByWithAggregationInput[]
    by: EmailAliasScalarFieldEnum[] | EmailAliasScalarFieldEnum
    having?: EmailAliasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAliasCountAggregateInputType | true
    _min?: EmailAliasMinAggregateInputType
    _max?: EmailAliasMaxAggregateInputType
  }

  export type EmailAliasGroupByOutputType = {
    id: string
    localPart: string
    targetMailboxId: string | null
    externalTarget: string | null
    isActive: boolean
    domainId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailAliasCountAggregateOutputType | null
    _min: EmailAliasMinAggregateOutputType | null
    _max: EmailAliasMaxAggregateOutputType | null
  }

  type GetEmailAliasGroupByPayload<T extends EmailAliasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAliasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAliasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAliasGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAliasGroupByOutputType[P]>
        }
      >
    >


  export type EmailAliasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localPart?: boolean
    targetMailboxId?: boolean
    externalTarget?: boolean
    isActive?: boolean
    domainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    targetMailbox?: boolean | EmailAlias$targetMailboxArgs<ExtArgs>
    domain?: boolean | EmailDomainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAlias"]>

  export type EmailAliasSelectScalar = {
    id?: boolean
    localPart?: boolean
    targetMailboxId?: boolean
    externalTarget?: boolean
    isActive?: boolean
    domainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailAliasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targetMailbox?: boolean | EmailAlias$targetMailboxArgs<ExtArgs>
    domain?: boolean | EmailDomainDefaultArgs<ExtArgs>
  }


  export type $EmailAliasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAlias"
    objects: {
      targetMailbox: Prisma.$MailboxPayload<ExtArgs> | null
      domain: Prisma.$EmailDomainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      localPart: string
      targetMailboxId: string | null
      externalTarget: string | null
      isActive: boolean
      domainId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailAlias"]>
    composites: {}
  }


  type EmailAliasGetPayload<S extends boolean | null | undefined | EmailAliasDefaultArgs> = $Result.GetResult<Prisma.$EmailAliasPayload, S>

  type EmailAliasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailAliasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailAliasCountAggregateInputType | true
    }

  export interface EmailAliasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAlias'], meta: { name: 'EmailAlias' } }
    /**
     * Find zero or one EmailAlias that matches the filter.
     * @param {EmailAliasFindUniqueArgs} args - Arguments to find a EmailAlias
     * @example
     * // Get one EmailAlias
     * const emailAlias = await prisma.emailAlias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailAliasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAliasFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailAlias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailAliasFindUniqueOrThrowArgs} args - Arguments to find a EmailAlias
     * @example
     * // Get one EmailAlias
     * const emailAlias = await prisma.emailAlias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailAliasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAliasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailAlias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasFindFirstArgs} args - Arguments to find a EmailAlias
     * @example
     * // Get one EmailAlias
     * const emailAlias = await prisma.emailAlias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailAliasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAliasFindFirstArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailAlias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasFindFirstOrThrowArgs} args - Arguments to find a EmailAlias
     * @example
     * // Get one EmailAlias
     * const emailAlias = await prisma.emailAlias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailAliasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAliasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailAliases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAliases
     * const emailAliases = await prisma.emailAlias.findMany()
     * 
     * // Get first 10 EmailAliases
     * const emailAliases = await prisma.emailAlias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAliasWithIdOnly = await prisma.emailAlias.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailAliasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAliasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailAlias.
     * @param {EmailAliasCreateArgs} args - Arguments to create a EmailAlias.
     * @example
     * // Create one EmailAlias
     * const EmailAlias = await prisma.emailAlias.create({
     *   data: {
     *     // ... data to create a EmailAlias
     *   }
     * })
     * 
    **/
    create<T extends EmailAliasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAliasCreateArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailAliases.
     *     @param {EmailAliasCreateManyArgs} args - Arguments to create many EmailAliases.
     *     @example
     *     // Create many EmailAliases
     *     const emailAlias = await prisma.emailAlias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailAliasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAliasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailAlias.
     * @param {EmailAliasDeleteArgs} args - Arguments to delete one EmailAlias.
     * @example
     * // Delete one EmailAlias
     * const EmailAlias = await prisma.emailAlias.delete({
     *   where: {
     *     // ... filter to delete one EmailAlias
     *   }
     * })
     * 
    **/
    delete<T extends EmailAliasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAliasDeleteArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailAlias.
     * @param {EmailAliasUpdateArgs} args - Arguments to update one EmailAlias.
     * @example
     * // Update one EmailAlias
     * const emailAlias = await prisma.emailAlias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailAliasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAliasUpdateArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailAliases.
     * @param {EmailAliasDeleteManyArgs} args - Arguments to filter EmailAliases to delete.
     * @example
     * // Delete a few EmailAliases
     * const { count } = await prisma.emailAlias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailAliasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailAliasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAliases
     * const emailAlias = await prisma.emailAlias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailAliasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAliasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailAlias.
     * @param {EmailAliasUpsertArgs} args - Arguments to update or create a EmailAlias.
     * @example
     * // Update or create a EmailAlias
     * const emailAlias = await prisma.emailAlias.upsert({
     *   create: {
     *     // ... data to create a EmailAlias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAlias we want to update
     *   }
     * })
    **/
    upsert<T extends EmailAliasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailAliasUpsertArgs<ExtArgs>>
    ): Prisma__EmailAliasClient<$Result.GetResult<Prisma.$EmailAliasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasCountArgs} args - Arguments to filter EmailAliases to count.
     * @example
     * // Count the number of EmailAliases
     * const count = await prisma.emailAlias.count({
     *   where: {
     *     // ... the filter for the EmailAliases we want to count
     *   }
     * })
    **/
    count<T extends EmailAliasCountArgs>(
      args?: Subset<T, EmailAliasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAliasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAliasAggregateArgs>(args: Subset<T, EmailAliasAggregateArgs>): Prisma.PrismaPromise<GetEmailAliasAggregateType<T>>

    /**
     * Group by EmailAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAliasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAliasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAliasGroupByArgs['orderBy'] }
        : { orderBy?: EmailAliasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAliasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAliasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAlias model
   */
  readonly fields: EmailAliasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAlias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAliasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    targetMailbox<T extends EmailAlias$targetMailboxArgs<ExtArgs> = {}>(args?: Subset<T, EmailAlias$targetMailboxArgs<ExtArgs>>): Prisma__MailboxClient<$Result.GetResult<Prisma.$MailboxPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    domain<T extends EmailDomainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDomainDefaultArgs<ExtArgs>>): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailAlias model
   */ 
  interface EmailAliasFieldRefs {
    readonly id: FieldRef<"EmailAlias", 'String'>
    readonly localPart: FieldRef<"EmailAlias", 'String'>
    readonly targetMailboxId: FieldRef<"EmailAlias", 'String'>
    readonly externalTarget: FieldRef<"EmailAlias", 'String'>
    readonly isActive: FieldRef<"EmailAlias", 'Boolean'>
    readonly domainId: FieldRef<"EmailAlias", 'String'>
    readonly createdAt: FieldRef<"EmailAlias", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAlias", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailAlias findUnique
   */
  export type EmailAliasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * Filter, which EmailAlias to fetch.
     */
    where: EmailAliasWhereUniqueInput
  }


  /**
   * EmailAlias findUniqueOrThrow
   */
  export type EmailAliasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * Filter, which EmailAlias to fetch.
     */
    where: EmailAliasWhereUniqueInput
  }


  /**
   * EmailAlias findFirst
   */
  export type EmailAliasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * Filter, which EmailAlias to fetch.
     */
    where?: EmailAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAliases to fetch.
     */
    orderBy?: EmailAliasOrderByWithRelationInput | EmailAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAliases.
     */
    cursor?: EmailAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAliases.
     */
    distinct?: EmailAliasScalarFieldEnum | EmailAliasScalarFieldEnum[]
  }


  /**
   * EmailAlias findFirstOrThrow
   */
  export type EmailAliasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * Filter, which EmailAlias to fetch.
     */
    where?: EmailAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAliases to fetch.
     */
    orderBy?: EmailAliasOrderByWithRelationInput | EmailAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAliases.
     */
    cursor?: EmailAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAliases.
     */
    distinct?: EmailAliasScalarFieldEnum | EmailAliasScalarFieldEnum[]
  }


  /**
   * EmailAlias findMany
   */
  export type EmailAliasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * Filter, which EmailAliases to fetch.
     */
    where?: EmailAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAliases to fetch.
     */
    orderBy?: EmailAliasOrderByWithRelationInput | EmailAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAliases.
     */
    cursor?: EmailAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAliases.
     */
    skip?: number
    distinct?: EmailAliasScalarFieldEnum | EmailAliasScalarFieldEnum[]
  }


  /**
   * EmailAlias create
   */
  export type EmailAliasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAlias.
     */
    data: XOR<EmailAliasCreateInput, EmailAliasUncheckedCreateInput>
  }


  /**
   * EmailAlias createMany
   */
  export type EmailAliasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAliases.
     */
    data: EmailAliasCreateManyInput | EmailAliasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailAlias update
   */
  export type EmailAliasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAlias.
     */
    data: XOR<EmailAliasUpdateInput, EmailAliasUncheckedUpdateInput>
    /**
     * Choose, which EmailAlias to update.
     */
    where: EmailAliasWhereUniqueInput
  }


  /**
   * EmailAlias updateMany
   */
  export type EmailAliasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAliases.
     */
    data: XOR<EmailAliasUpdateManyMutationInput, EmailAliasUncheckedUpdateManyInput>
    /**
     * Filter which EmailAliases to update
     */
    where?: EmailAliasWhereInput
  }


  /**
   * EmailAlias upsert
   */
  export type EmailAliasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAlias to update in case it exists.
     */
    where: EmailAliasWhereUniqueInput
    /**
     * In case the EmailAlias found by the `where` argument doesn't exist, create a new EmailAlias with this data.
     */
    create: XOR<EmailAliasCreateInput, EmailAliasUncheckedCreateInput>
    /**
     * In case the EmailAlias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAliasUpdateInput, EmailAliasUncheckedUpdateInput>
  }


  /**
   * EmailAlias delete
   */
  export type EmailAliasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
    /**
     * Filter which EmailAlias to delete.
     */
    where: EmailAliasWhereUniqueInput
  }


  /**
   * EmailAlias deleteMany
   */
  export type EmailAliasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAliases to delete
     */
    where?: EmailAliasWhereInput
  }


  /**
   * EmailAlias.targetMailbox
   */
  export type EmailAlias$targetMailboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mailbox
     */
    select?: MailboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MailboxInclude<ExtArgs> | null
    where?: MailboxWhereInput
  }


  /**
   * EmailAlias without action
   */
  export type EmailAliasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAlias
     */
    select?: EmailAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailAliasInclude<ExtArgs> | null
  }



  /**
   * Model DomainDNS
   */

  export type AggregateDomainDNS = {
    _count: DomainDNSCountAggregateOutputType | null
    _avg: DomainDNSAvgAggregateOutputType | null
    _sum: DomainDNSSumAggregateOutputType | null
    _min: DomainDNSMinAggregateOutputType | null
    _max: DomainDNSMaxAggregateOutputType | null
  }

  export type DomainDNSAvgAggregateOutputType = {
    priority: number | null
    ttl: number | null
  }

  export type DomainDNSSumAggregateOutputType = {
    priority: number | null
    ttl: number | null
  }

  export type DomainDNSMinAggregateOutputType = {
    id: string | null
    recordType: $Enums.DNSRecordType | null
    name: string | null
    value: string | null
    priority: number | null
    ttl: number | null
    description: string | null
    isRequired: boolean | null
    isVerified: boolean | null
    lastCheckedAt: Date | null
    domainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainDNSMaxAggregateOutputType = {
    id: string | null
    recordType: $Enums.DNSRecordType | null
    name: string | null
    value: string | null
    priority: number | null
    ttl: number | null
    description: string | null
    isRequired: boolean | null
    isVerified: boolean | null
    lastCheckedAt: Date | null
    domainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainDNSCountAggregateOutputType = {
    id: number
    recordType: number
    name: number
    value: number
    priority: number
    ttl: number
    description: number
    isRequired: number
    isVerified: number
    lastCheckedAt: number
    domainId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainDNSAvgAggregateInputType = {
    priority?: true
    ttl?: true
  }

  export type DomainDNSSumAggregateInputType = {
    priority?: true
    ttl?: true
  }

  export type DomainDNSMinAggregateInputType = {
    id?: true
    recordType?: true
    name?: true
    value?: true
    priority?: true
    ttl?: true
    description?: true
    isRequired?: true
    isVerified?: true
    lastCheckedAt?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainDNSMaxAggregateInputType = {
    id?: true
    recordType?: true
    name?: true
    value?: true
    priority?: true
    ttl?: true
    description?: true
    isRequired?: true
    isVerified?: true
    lastCheckedAt?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainDNSCountAggregateInputType = {
    id?: true
    recordType?: true
    name?: true
    value?: true
    priority?: true
    ttl?: true
    description?: true
    isRequired?: true
    isVerified?: true
    lastCheckedAt?: true
    domainId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainDNSAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainDNS to aggregate.
     */
    where?: DomainDNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDNS to fetch.
     */
    orderBy?: DomainDNSOrderByWithRelationInput | DomainDNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainDNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainDNS
    **/
    _count?: true | DomainDNSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainDNSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainDNSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainDNSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainDNSMaxAggregateInputType
  }

  export type GetDomainDNSAggregateType<T extends DomainDNSAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainDNS]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainDNS[P]>
      : GetScalarType<T[P], AggregateDomainDNS[P]>
  }




  export type DomainDNSGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainDNSWhereInput
    orderBy?: DomainDNSOrderByWithAggregationInput | DomainDNSOrderByWithAggregationInput[]
    by: DomainDNSScalarFieldEnum[] | DomainDNSScalarFieldEnum
    having?: DomainDNSScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainDNSCountAggregateInputType | true
    _avg?: DomainDNSAvgAggregateInputType
    _sum?: DomainDNSSumAggregateInputType
    _min?: DomainDNSMinAggregateInputType
    _max?: DomainDNSMaxAggregateInputType
  }

  export type DomainDNSGroupByOutputType = {
    id: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority: number | null
    ttl: number
    description: string | null
    isRequired: boolean
    isVerified: boolean
    lastCheckedAt: Date | null
    domainId: string
    createdAt: Date
    updatedAt: Date
    _count: DomainDNSCountAggregateOutputType | null
    _avg: DomainDNSAvgAggregateOutputType | null
    _sum: DomainDNSSumAggregateOutputType | null
    _min: DomainDNSMinAggregateOutputType | null
    _max: DomainDNSMaxAggregateOutputType | null
  }

  type GetDomainDNSGroupByPayload<T extends DomainDNSGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainDNSGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainDNSGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainDNSGroupByOutputType[P]>
            : GetScalarType<T[P], DomainDNSGroupByOutputType[P]>
        }
      >
    >


  export type DomainDNSSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recordType?: boolean
    name?: boolean
    value?: boolean
    priority?: boolean
    ttl?: boolean
    description?: boolean
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: boolean
    domainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domain?: boolean | EmailDomainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainDNS"]>

  export type DomainDNSSelectScalar = {
    id?: boolean
    recordType?: boolean
    name?: boolean
    value?: boolean
    priority?: boolean
    ttl?: boolean
    description?: boolean
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: boolean
    domainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainDNSInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | EmailDomainDefaultArgs<ExtArgs>
  }


  export type $DomainDNSPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainDNS"
    objects: {
      domain: Prisma.$EmailDomainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recordType: $Enums.DNSRecordType
      name: string
      value: string
      priority: number | null
      ttl: number
      description: string | null
      isRequired: boolean
      isVerified: boolean
      lastCheckedAt: Date | null
      domainId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domainDNS"]>
    composites: {}
  }


  type DomainDNSGetPayload<S extends boolean | null | undefined | DomainDNSDefaultArgs> = $Result.GetResult<Prisma.$DomainDNSPayload, S>

  type DomainDNSCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DomainDNSFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DomainDNSCountAggregateInputType | true
    }

  export interface DomainDNSDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainDNS'], meta: { name: 'DomainDNS' } }
    /**
     * Find zero or one DomainDNS that matches the filter.
     * @param {DomainDNSFindUniqueArgs} args - Arguments to find a DomainDNS
     * @example
     * // Get one DomainDNS
     * const domainDNS = await prisma.domainDNS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DomainDNSFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DomainDNSFindUniqueArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DomainDNS that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DomainDNSFindUniqueOrThrowArgs} args - Arguments to find a DomainDNS
     * @example
     * // Get one DomainDNS
     * const domainDNS = await prisma.domainDNS.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DomainDNSFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DomainDNSFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DomainDNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSFindFirstArgs} args - Arguments to find a DomainDNS
     * @example
     * // Get one DomainDNS
     * const domainDNS = await prisma.domainDNS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DomainDNSFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DomainDNSFindFirstArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DomainDNS that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSFindFirstOrThrowArgs} args - Arguments to find a DomainDNS
     * @example
     * // Get one DomainDNS
     * const domainDNS = await prisma.domainDNS.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DomainDNSFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DomainDNSFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DomainDNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainDNS
     * const domainDNS = await prisma.domainDNS.findMany()
     * 
     * // Get first 10 DomainDNS
     * const domainDNS = await prisma.domainDNS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainDNSWithIdOnly = await prisma.domainDNS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DomainDNSFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DomainDNSFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DomainDNS.
     * @param {DomainDNSCreateArgs} args - Arguments to create a DomainDNS.
     * @example
     * // Create one DomainDNS
     * const DomainDNS = await prisma.domainDNS.create({
     *   data: {
     *     // ... data to create a DomainDNS
     *   }
     * })
     * 
    **/
    create<T extends DomainDNSCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DomainDNSCreateArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DomainDNS.
     *     @param {DomainDNSCreateManyArgs} args - Arguments to create many DomainDNS.
     *     @example
     *     // Create many DomainDNS
     *     const domainDNS = await prisma.domainDNS.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DomainDNSCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DomainDNSCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DomainDNS.
     * @param {DomainDNSDeleteArgs} args - Arguments to delete one DomainDNS.
     * @example
     * // Delete one DomainDNS
     * const DomainDNS = await prisma.domainDNS.delete({
     *   where: {
     *     // ... filter to delete one DomainDNS
     *   }
     * })
     * 
    **/
    delete<T extends DomainDNSDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DomainDNSDeleteArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DomainDNS.
     * @param {DomainDNSUpdateArgs} args - Arguments to update one DomainDNS.
     * @example
     * // Update one DomainDNS
     * const domainDNS = await prisma.domainDNS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DomainDNSUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DomainDNSUpdateArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DomainDNS.
     * @param {DomainDNSDeleteManyArgs} args - Arguments to filter DomainDNS to delete.
     * @example
     * // Delete a few DomainDNS
     * const { count } = await prisma.domainDNS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DomainDNSDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DomainDNSDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainDNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainDNS
     * const domainDNS = await prisma.domainDNS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DomainDNSUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DomainDNSUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DomainDNS.
     * @param {DomainDNSUpsertArgs} args - Arguments to update or create a DomainDNS.
     * @example
     * // Update or create a DomainDNS
     * const domainDNS = await prisma.domainDNS.upsert({
     *   create: {
     *     // ... data to create a DomainDNS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainDNS we want to update
     *   }
     * })
    **/
    upsert<T extends DomainDNSUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DomainDNSUpsertArgs<ExtArgs>>
    ): Prisma__DomainDNSClient<$Result.GetResult<Prisma.$DomainDNSPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DomainDNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSCountArgs} args - Arguments to filter DomainDNS to count.
     * @example
     * // Count the number of DomainDNS
     * const count = await prisma.domainDNS.count({
     *   where: {
     *     // ... the filter for the DomainDNS we want to count
     *   }
     * })
    **/
    count<T extends DomainDNSCountArgs>(
      args?: Subset<T, DomainDNSCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainDNSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainDNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainDNSAggregateArgs>(args: Subset<T, DomainDNSAggregateArgs>): Prisma.PrismaPromise<GetDomainDNSAggregateType<T>>

    /**
     * Group by DomainDNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainDNSGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainDNSGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainDNSGroupByArgs['orderBy'] }
        : { orderBy?: DomainDNSGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainDNSGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainDNSGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainDNS model
   */
  readonly fields: DomainDNSFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainDNS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainDNSClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    domain<T extends EmailDomainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDomainDefaultArgs<ExtArgs>>): Prisma__EmailDomainClient<$Result.GetResult<Prisma.$EmailDomainPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DomainDNS model
   */ 
  interface DomainDNSFieldRefs {
    readonly id: FieldRef<"DomainDNS", 'String'>
    readonly recordType: FieldRef<"DomainDNS", 'DNSRecordType'>
    readonly name: FieldRef<"DomainDNS", 'String'>
    readonly value: FieldRef<"DomainDNS", 'String'>
    readonly priority: FieldRef<"DomainDNS", 'Int'>
    readonly ttl: FieldRef<"DomainDNS", 'Int'>
    readonly description: FieldRef<"DomainDNS", 'String'>
    readonly isRequired: FieldRef<"DomainDNS", 'Boolean'>
    readonly isVerified: FieldRef<"DomainDNS", 'Boolean'>
    readonly lastCheckedAt: FieldRef<"DomainDNS", 'DateTime'>
    readonly domainId: FieldRef<"DomainDNS", 'String'>
    readonly createdAt: FieldRef<"DomainDNS", 'DateTime'>
    readonly updatedAt: FieldRef<"DomainDNS", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DomainDNS findUnique
   */
  export type DomainDNSFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * Filter, which DomainDNS to fetch.
     */
    where: DomainDNSWhereUniqueInput
  }


  /**
   * DomainDNS findUniqueOrThrow
   */
  export type DomainDNSFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * Filter, which DomainDNS to fetch.
     */
    where: DomainDNSWhereUniqueInput
  }


  /**
   * DomainDNS findFirst
   */
  export type DomainDNSFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * Filter, which DomainDNS to fetch.
     */
    where?: DomainDNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDNS to fetch.
     */
    orderBy?: DomainDNSOrderByWithRelationInput | DomainDNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainDNS.
     */
    cursor?: DomainDNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainDNS.
     */
    distinct?: DomainDNSScalarFieldEnum | DomainDNSScalarFieldEnum[]
  }


  /**
   * DomainDNS findFirstOrThrow
   */
  export type DomainDNSFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * Filter, which DomainDNS to fetch.
     */
    where?: DomainDNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDNS to fetch.
     */
    orderBy?: DomainDNSOrderByWithRelationInput | DomainDNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainDNS.
     */
    cursor?: DomainDNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainDNS.
     */
    distinct?: DomainDNSScalarFieldEnum | DomainDNSScalarFieldEnum[]
  }


  /**
   * DomainDNS findMany
   */
  export type DomainDNSFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * Filter, which DomainDNS to fetch.
     */
    where?: DomainDNSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainDNS to fetch.
     */
    orderBy?: DomainDNSOrderByWithRelationInput | DomainDNSOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainDNS.
     */
    cursor?: DomainDNSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainDNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainDNS.
     */
    skip?: number
    distinct?: DomainDNSScalarFieldEnum | DomainDNSScalarFieldEnum[]
  }


  /**
   * DomainDNS create
   */
  export type DomainDNSCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainDNS.
     */
    data: XOR<DomainDNSCreateInput, DomainDNSUncheckedCreateInput>
  }


  /**
   * DomainDNS createMany
   */
  export type DomainDNSCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainDNS.
     */
    data: DomainDNSCreateManyInput | DomainDNSCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DomainDNS update
   */
  export type DomainDNSUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainDNS.
     */
    data: XOR<DomainDNSUpdateInput, DomainDNSUncheckedUpdateInput>
    /**
     * Choose, which DomainDNS to update.
     */
    where: DomainDNSWhereUniqueInput
  }


  /**
   * DomainDNS updateMany
   */
  export type DomainDNSUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainDNS.
     */
    data: XOR<DomainDNSUpdateManyMutationInput, DomainDNSUncheckedUpdateManyInput>
    /**
     * Filter which DomainDNS to update
     */
    where?: DomainDNSWhereInput
  }


  /**
   * DomainDNS upsert
   */
  export type DomainDNSUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainDNS to update in case it exists.
     */
    where: DomainDNSWhereUniqueInput
    /**
     * In case the DomainDNS found by the `where` argument doesn't exist, create a new DomainDNS with this data.
     */
    create: XOR<DomainDNSCreateInput, DomainDNSUncheckedCreateInput>
    /**
     * In case the DomainDNS was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainDNSUpdateInput, DomainDNSUncheckedUpdateInput>
  }


  /**
   * DomainDNS delete
   */
  export type DomainDNSDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
    /**
     * Filter which DomainDNS to delete.
     */
    where: DomainDNSWhereUniqueInput
  }


  /**
   * DomainDNS deleteMany
   */
  export type DomainDNSDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainDNS to delete
     */
    where?: DomainDNSWhereInput
  }


  /**
   * DomainDNS without action
   */
  export type DomainDNSDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainDNS
     */
    select?: DomainDNSSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DomainDNSInclude<ExtArgs> | null
  }



  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _avg: EmailLogAvgAggregateOutputType | null
    _sum: EmailLogSumAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogAvgAggregateOutputType = {
    sizeBytes: number | null
    smtpCode: number | null
    spamScore: number | null
  }

  export type EmailLogSumAggregateOutputType = {
    sizeBytes: number | null
    smtpCode: number | null
    spamScore: number | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    direction: string | null
    fromAddress: string | null
    toAddress: string | null
    subject: string | null
    status: $Enums.EmailLogStatus | null
    errorMessage: string | null
    sizeBytes: number | null
    hasAttachments: boolean | null
    smtpCode: number | null
    smtpResponse: string | null
    spamScore: number | null
    spamAction: string | null
    processedAt: Date | null
    deliveredAt: Date | null
    domainId: string | null
    mailboxId: string | null
    createdAt: Date | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    direction: string | null
    fromAddress: string | null
    toAddress: string | null
    subject: string | null
    status: $Enums.EmailLogStatus | null
    errorMessage: string | null
    sizeBytes: number | null
    hasAttachments: boolean | null
    smtpCode: number | null
    smtpResponse: string | null
    spamScore: number | null
    spamAction: string | null
    processedAt: Date | null
    deliveredAt: Date | null
    domainId: string | null
    mailboxId: string | null
    createdAt: Date | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    messageId: number
    direction: number
    fromAddress: number
    toAddress: number
    subject: number
    status: number
    errorMessage: number
    sizeBytes: number
    hasAttachments: number
    smtpCode: number
    smtpResponse: number
    spamScore: number
    spamAction: number
    processedAt: number
    deliveredAt: number
    domainId: number
    mailboxId: number
    createdAt: number
    _all: number
  }


  export type EmailLogAvgAggregateInputType = {
    sizeBytes?: true
    smtpCode?: true
    spamScore?: true
  }

  export type EmailLogSumAggregateInputType = {
    sizeBytes?: true
    smtpCode?: true
    spamScore?: true
  }

  export type EmailLogMinAggregateInputType = {
    id?: true
    messageId?: true
    direction?: true
    fromAddress?: true
    toAddress?: true
    subject?: true
    status?: true
    errorMessage?: true
    sizeBytes?: true
    hasAttachments?: true
    smtpCode?: true
    smtpResponse?: true
    spamScore?: true
    spamAction?: true
    processedAt?: true
    deliveredAt?: true
    domainId?: true
    mailboxId?: true
    createdAt?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    messageId?: true
    direction?: true
    fromAddress?: true
    toAddress?: true
    subject?: true
    status?: true
    errorMessage?: true
    sizeBytes?: true
    hasAttachments?: true
    smtpCode?: true
    smtpResponse?: true
    spamScore?: true
    spamAction?: true
    processedAt?: true
    deliveredAt?: true
    domainId?: true
    mailboxId?: true
    createdAt?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    messageId?: true
    direction?: true
    fromAddress?: true
    toAddress?: true
    subject?: true
    status?: true
    errorMessage?: true
    sizeBytes?: true
    hasAttachments?: true
    smtpCode?: true
    smtpResponse?: true
    spamScore?: true
    spamAction?: true
    processedAt?: true
    deliveredAt?: true
    domainId?: true
    mailboxId?: true
    createdAt?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _avg?: EmailLogAvgAggregateInputType
    _sum?: EmailLogSumAggregateInputType
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    messageId: string | null
    direction: string
    fromAddress: string
    toAddress: string
    subject: string | null
    status: $Enums.EmailLogStatus
    errorMessage: string | null
    sizeBytes: number | null
    hasAttachments: boolean
    smtpCode: number | null
    smtpResponse: string | null
    spamScore: number | null
    spamAction: string | null
    processedAt: Date
    deliveredAt: Date | null
    domainId: string | null
    mailboxId: string | null
    createdAt: Date
    _count: EmailLogCountAggregateOutputType | null
    _avg: EmailLogAvgAggregateOutputType | null
    _sum: EmailLogSumAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    direction?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    subject?: boolean
    status?: boolean
    errorMessage?: boolean
    sizeBytes?: boolean
    hasAttachments?: boolean
    smtpCode?: boolean
    smtpResponse?: boolean
    spamScore?: boolean
    spamAction?: boolean
    processedAt?: boolean
    deliveredAt?: boolean
    domainId?: boolean
    mailboxId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["emailLog"]>

  export type EmailLogSelectScalar = {
    id?: boolean
    messageId?: boolean
    direction?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    subject?: boolean
    status?: boolean
    errorMessage?: boolean
    sizeBytes?: boolean
    hasAttachments?: boolean
    smtpCode?: boolean
    smtpResponse?: boolean
    spamScore?: boolean
    spamAction?: boolean
    processedAt?: boolean
    deliveredAt?: boolean
    domainId?: boolean
    mailboxId?: boolean
    createdAt?: boolean
  }


  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string | null
      direction: string
      fromAddress: string
      toAddress: string
      subject: string | null
      status: $Enums.EmailLogStatus
      errorMessage: string | null
      sizeBytes: number | null
      hasAttachments: boolean
      smtpCode: number | null
      smtpResponse: string | null
      spamScore: number | null
      spamAction: string | null
      processedAt: Date
      deliveredAt: Date | null
      domainId: string | null
      mailboxId: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }


  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
    **/
    create<T extends EmailLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailLogs.
     *     @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     *     @example
     *     // Create many EmailLogs
     *     const emailLog = await prisma.emailLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
    **/
    delete<T extends EmailLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
    **/
    upsert<T extends EmailLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>
    ): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailLog model
   */ 
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly messageId: FieldRef<"EmailLog", 'String'>
    readonly direction: FieldRef<"EmailLog", 'String'>
    readonly fromAddress: FieldRef<"EmailLog", 'String'>
    readonly toAddress: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly status: FieldRef<"EmailLog", 'EmailLogStatus'>
    readonly errorMessage: FieldRef<"EmailLog", 'String'>
    readonly sizeBytes: FieldRef<"EmailLog", 'Int'>
    readonly hasAttachments: FieldRef<"EmailLog", 'Boolean'>
    readonly smtpCode: FieldRef<"EmailLog", 'Int'>
    readonly smtpResponse: FieldRef<"EmailLog", 'String'>
    readonly spamScore: FieldRef<"EmailLog", 'Float'>
    readonly spamAction: FieldRef<"EmailLog", 'String'>
    readonly processedAt: FieldRef<"EmailLog", 'DateTime'>
    readonly deliveredAt: FieldRef<"EmailLog", 'DateTime'>
    readonly domainId: FieldRef<"EmailLog", 'String'>
    readonly mailboxId: FieldRef<"EmailLog", 'String'>
    readonly createdAt: FieldRef<"EmailLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }


  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }


  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }


  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }


  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }


  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }


  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }


  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
  }


  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }


  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }


  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
  }


  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
  }



  /**
   * Model EmailQuarantined
   */

  export type AggregateEmailQuarantined = {
    _count: EmailQuarantinedCountAggregateOutputType | null
    _avg: EmailQuarantinedAvgAggregateOutputType | null
    _sum: EmailQuarantinedSumAggregateOutputType | null
    _min: EmailQuarantinedMinAggregateOutputType | null
    _max: EmailQuarantinedMaxAggregateOutputType | null
  }

  export type EmailQuarantinedAvgAggregateOutputType = {
    spamScore: number | null
  }

  export type EmailQuarantinedSumAggregateOutputType = {
    spamScore: number | null
  }

  export type EmailQuarantinedMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    fromAddress: string | null
    toAddress: string | null
    subject: string | null
    reason: string | null
    spamScore: number | null
    rawHeaders: string | null
    previewText: string | null
    releasedAt: Date | null
    releasedBy: string | null
    deletedAt: Date | null
    domainId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type EmailQuarantinedMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    fromAddress: string | null
    toAddress: string | null
    subject: string | null
    reason: string | null
    spamScore: number | null
    rawHeaders: string | null
    previewText: string | null
    releasedAt: Date | null
    releasedBy: string | null
    deletedAt: Date | null
    domainId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type EmailQuarantinedCountAggregateOutputType = {
    id: number
    messageId: number
    fromAddress: number
    toAddress: number
    subject: number
    reason: number
    spamScore: number
    rawHeaders: number
    previewText: number
    releasedAt: number
    releasedBy: number
    deletedAt: number
    domainId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type EmailQuarantinedAvgAggregateInputType = {
    spamScore?: true
  }

  export type EmailQuarantinedSumAggregateInputType = {
    spamScore?: true
  }

  export type EmailQuarantinedMinAggregateInputType = {
    id?: true
    messageId?: true
    fromAddress?: true
    toAddress?: true
    subject?: true
    reason?: true
    spamScore?: true
    rawHeaders?: true
    previewText?: true
    releasedAt?: true
    releasedBy?: true
    deletedAt?: true
    domainId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type EmailQuarantinedMaxAggregateInputType = {
    id?: true
    messageId?: true
    fromAddress?: true
    toAddress?: true
    subject?: true
    reason?: true
    spamScore?: true
    rawHeaders?: true
    previewText?: true
    releasedAt?: true
    releasedBy?: true
    deletedAt?: true
    domainId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type EmailQuarantinedCountAggregateInputType = {
    id?: true
    messageId?: true
    fromAddress?: true
    toAddress?: true
    subject?: true
    reason?: true
    spamScore?: true
    rawHeaders?: true
    previewText?: true
    releasedAt?: true
    releasedBy?: true
    deletedAt?: true
    domainId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type EmailQuarantinedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailQuarantined to aggregate.
     */
    where?: EmailQuarantinedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailQuarantineds to fetch.
     */
    orderBy?: EmailQuarantinedOrderByWithRelationInput | EmailQuarantinedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailQuarantinedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailQuarantineds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailQuarantineds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailQuarantineds
    **/
    _count?: true | EmailQuarantinedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailQuarantinedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailQuarantinedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailQuarantinedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailQuarantinedMaxAggregateInputType
  }

  export type GetEmailQuarantinedAggregateType<T extends EmailQuarantinedAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailQuarantined]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailQuarantined[P]>
      : GetScalarType<T[P], AggregateEmailQuarantined[P]>
  }




  export type EmailQuarantinedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailQuarantinedWhereInput
    orderBy?: EmailQuarantinedOrderByWithAggregationInput | EmailQuarantinedOrderByWithAggregationInput[]
    by: EmailQuarantinedScalarFieldEnum[] | EmailQuarantinedScalarFieldEnum
    having?: EmailQuarantinedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailQuarantinedCountAggregateInputType | true
    _avg?: EmailQuarantinedAvgAggregateInputType
    _sum?: EmailQuarantinedSumAggregateInputType
    _min?: EmailQuarantinedMinAggregateInputType
    _max?: EmailQuarantinedMaxAggregateInputType
  }

  export type EmailQuarantinedGroupByOutputType = {
    id: string
    messageId: string
    fromAddress: string
    toAddress: string
    subject: string | null
    reason: string
    spamScore: number | null
    rawHeaders: string | null
    previewText: string | null
    releasedAt: Date | null
    releasedBy: string | null
    deletedAt: Date | null
    domainId: string
    createdAt: Date
    expiresAt: Date
    _count: EmailQuarantinedCountAggregateOutputType | null
    _avg: EmailQuarantinedAvgAggregateOutputType | null
    _sum: EmailQuarantinedSumAggregateOutputType | null
    _min: EmailQuarantinedMinAggregateOutputType | null
    _max: EmailQuarantinedMaxAggregateOutputType | null
  }

  type GetEmailQuarantinedGroupByPayload<T extends EmailQuarantinedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailQuarantinedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailQuarantinedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailQuarantinedGroupByOutputType[P]>
            : GetScalarType<T[P], EmailQuarantinedGroupByOutputType[P]>
        }
      >
    >


  export type EmailQuarantinedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    subject?: boolean
    reason?: boolean
    spamScore?: boolean
    rawHeaders?: boolean
    previewText?: boolean
    releasedAt?: boolean
    releasedBy?: boolean
    deletedAt?: boolean
    domainId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["emailQuarantined"]>

  export type EmailQuarantinedSelectScalar = {
    id?: boolean
    messageId?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    subject?: boolean
    reason?: boolean
    spamScore?: boolean
    rawHeaders?: boolean
    previewText?: boolean
    releasedAt?: boolean
    releasedBy?: boolean
    deletedAt?: boolean
    domainId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }


  export type $EmailQuarantinedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailQuarantined"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      fromAddress: string
      toAddress: string
      subject: string | null
      reason: string
      spamScore: number | null
      rawHeaders: string | null
      previewText: string | null
      releasedAt: Date | null
      releasedBy: string | null
      deletedAt: Date | null
      domainId: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["emailQuarantined"]>
    composites: {}
  }


  type EmailQuarantinedGetPayload<S extends boolean | null | undefined | EmailQuarantinedDefaultArgs> = $Result.GetResult<Prisma.$EmailQuarantinedPayload, S>

  type EmailQuarantinedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailQuarantinedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailQuarantinedCountAggregateInputType | true
    }

  export interface EmailQuarantinedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailQuarantined'], meta: { name: 'EmailQuarantined' } }
    /**
     * Find zero or one EmailQuarantined that matches the filter.
     * @param {EmailQuarantinedFindUniqueArgs} args - Arguments to find a EmailQuarantined
     * @example
     * // Get one EmailQuarantined
     * const emailQuarantined = await prisma.emailQuarantined.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailQuarantinedFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailQuarantinedFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailQuarantined that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailQuarantinedFindUniqueOrThrowArgs} args - Arguments to find a EmailQuarantined
     * @example
     * // Get one EmailQuarantined
     * const emailQuarantined = await prisma.emailQuarantined.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailQuarantinedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailQuarantinedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailQuarantined that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedFindFirstArgs} args - Arguments to find a EmailQuarantined
     * @example
     * // Get one EmailQuarantined
     * const emailQuarantined = await prisma.emailQuarantined.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailQuarantinedFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailQuarantinedFindFirstArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailQuarantined that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedFindFirstOrThrowArgs} args - Arguments to find a EmailQuarantined
     * @example
     * // Get one EmailQuarantined
     * const emailQuarantined = await prisma.emailQuarantined.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailQuarantinedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailQuarantinedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailQuarantineds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailQuarantineds
     * const emailQuarantineds = await prisma.emailQuarantined.findMany()
     * 
     * // Get first 10 EmailQuarantineds
     * const emailQuarantineds = await prisma.emailQuarantined.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailQuarantinedWithIdOnly = await prisma.emailQuarantined.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailQuarantinedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailQuarantinedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailQuarantined.
     * @param {EmailQuarantinedCreateArgs} args - Arguments to create a EmailQuarantined.
     * @example
     * // Create one EmailQuarantined
     * const EmailQuarantined = await prisma.emailQuarantined.create({
     *   data: {
     *     // ... data to create a EmailQuarantined
     *   }
     * })
     * 
    **/
    create<T extends EmailQuarantinedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailQuarantinedCreateArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailQuarantineds.
     *     @param {EmailQuarantinedCreateManyArgs} args - Arguments to create many EmailQuarantineds.
     *     @example
     *     // Create many EmailQuarantineds
     *     const emailQuarantined = await prisma.emailQuarantined.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailQuarantinedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailQuarantinedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailQuarantined.
     * @param {EmailQuarantinedDeleteArgs} args - Arguments to delete one EmailQuarantined.
     * @example
     * // Delete one EmailQuarantined
     * const EmailQuarantined = await prisma.emailQuarantined.delete({
     *   where: {
     *     // ... filter to delete one EmailQuarantined
     *   }
     * })
     * 
    **/
    delete<T extends EmailQuarantinedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailQuarantinedDeleteArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailQuarantined.
     * @param {EmailQuarantinedUpdateArgs} args - Arguments to update one EmailQuarantined.
     * @example
     * // Update one EmailQuarantined
     * const emailQuarantined = await prisma.emailQuarantined.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailQuarantinedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailQuarantinedUpdateArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailQuarantineds.
     * @param {EmailQuarantinedDeleteManyArgs} args - Arguments to filter EmailQuarantineds to delete.
     * @example
     * // Delete a few EmailQuarantineds
     * const { count } = await prisma.emailQuarantined.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailQuarantinedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailQuarantinedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailQuarantineds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailQuarantineds
     * const emailQuarantined = await prisma.emailQuarantined.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailQuarantinedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailQuarantinedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailQuarantined.
     * @param {EmailQuarantinedUpsertArgs} args - Arguments to update or create a EmailQuarantined.
     * @example
     * // Update or create a EmailQuarantined
     * const emailQuarantined = await prisma.emailQuarantined.upsert({
     *   create: {
     *     // ... data to create a EmailQuarantined
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailQuarantined we want to update
     *   }
     * })
    **/
    upsert<T extends EmailQuarantinedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailQuarantinedUpsertArgs<ExtArgs>>
    ): Prisma__EmailQuarantinedClient<$Result.GetResult<Prisma.$EmailQuarantinedPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailQuarantineds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedCountArgs} args - Arguments to filter EmailQuarantineds to count.
     * @example
     * // Count the number of EmailQuarantineds
     * const count = await prisma.emailQuarantined.count({
     *   where: {
     *     // ... the filter for the EmailQuarantineds we want to count
     *   }
     * })
    **/
    count<T extends EmailQuarantinedCountArgs>(
      args?: Subset<T, EmailQuarantinedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailQuarantinedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailQuarantined.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailQuarantinedAggregateArgs>(args: Subset<T, EmailQuarantinedAggregateArgs>): Prisma.PrismaPromise<GetEmailQuarantinedAggregateType<T>>

    /**
     * Group by EmailQuarantined.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailQuarantinedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailQuarantinedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailQuarantinedGroupByArgs['orderBy'] }
        : { orderBy?: EmailQuarantinedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailQuarantinedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailQuarantinedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailQuarantined model
   */
  readonly fields: EmailQuarantinedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailQuarantined.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailQuarantinedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailQuarantined model
   */ 
  interface EmailQuarantinedFieldRefs {
    readonly id: FieldRef<"EmailQuarantined", 'String'>
    readonly messageId: FieldRef<"EmailQuarantined", 'String'>
    readonly fromAddress: FieldRef<"EmailQuarantined", 'String'>
    readonly toAddress: FieldRef<"EmailQuarantined", 'String'>
    readonly subject: FieldRef<"EmailQuarantined", 'String'>
    readonly reason: FieldRef<"EmailQuarantined", 'String'>
    readonly spamScore: FieldRef<"EmailQuarantined", 'Float'>
    readonly rawHeaders: FieldRef<"EmailQuarantined", 'String'>
    readonly previewText: FieldRef<"EmailQuarantined", 'String'>
    readonly releasedAt: FieldRef<"EmailQuarantined", 'DateTime'>
    readonly releasedBy: FieldRef<"EmailQuarantined", 'String'>
    readonly deletedAt: FieldRef<"EmailQuarantined", 'DateTime'>
    readonly domainId: FieldRef<"EmailQuarantined", 'String'>
    readonly createdAt: FieldRef<"EmailQuarantined", 'DateTime'>
    readonly expiresAt: FieldRef<"EmailQuarantined", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailQuarantined findUnique
   */
  export type EmailQuarantinedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * Filter, which EmailQuarantined to fetch.
     */
    where: EmailQuarantinedWhereUniqueInput
  }


  /**
   * EmailQuarantined findUniqueOrThrow
   */
  export type EmailQuarantinedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * Filter, which EmailQuarantined to fetch.
     */
    where: EmailQuarantinedWhereUniqueInput
  }


  /**
   * EmailQuarantined findFirst
   */
  export type EmailQuarantinedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * Filter, which EmailQuarantined to fetch.
     */
    where?: EmailQuarantinedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailQuarantineds to fetch.
     */
    orderBy?: EmailQuarantinedOrderByWithRelationInput | EmailQuarantinedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailQuarantineds.
     */
    cursor?: EmailQuarantinedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailQuarantineds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailQuarantineds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailQuarantineds.
     */
    distinct?: EmailQuarantinedScalarFieldEnum | EmailQuarantinedScalarFieldEnum[]
  }


  /**
   * EmailQuarantined findFirstOrThrow
   */
  export type EmailQuarantinedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * Filter, which EmailQuarantined to fetch.
     */
    where?: EmailQuarantinedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailQuarantineds to fetch.
     */
    orderBy?: EmailQuarantinedOrderByWithRelationInput | EmailQuarantinedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailQuarantineds.
     */
    cursor?: EmailQuarantinedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailQuarantineds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailQuarantineds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailQuarantineds.
     */
    distinct?: EmailQuarantinedScalarFieldEnum | EmailQuarantinedScalarFieldEnum[]
  }


  /**
   * EmailQuarantined findMany
   */
  export type EmailQuarantinedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * Filter, which EmailQuarantineds to fetch.
     */
    where?: EmailQuarantinedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailQuarantineds to fetch.
     */
    orderBy?: EmailQuarantinedOrderByWithRelationInput | EmailQuarantinedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailQuarantineds.
     */
    cursor?: EmailQuarantinedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailQuarantineds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailQuarantineds.
     */
    skip?: number
    distinct?: EmailQuarantinedScalarFieldEnum | EmailQuarantinedScalarFieldEnum[]
  }


  /**
   * EmailQuarantined create
   */
  export type EmailQuarantinedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailQuarantined.
     */
    data: XOR<EmailQuarantinedCreateInput, EmailQuarantinedUncheckedCreateInput>
  }


  /**
   * EmailQuarantined createMany
   */
  export type EmailQuarantinedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailQuarantineds.
     */
    data: EmailQuarantinedCreateManyInput | EmailQuarantinedCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailQuarantined update
   */
  export type EmailQuarantinedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailQuarantined.
     */
    data: XOR<EmailQuarantinedUpdateInput, EmailQuarantinedUncheckedUpdateInput>
    /**
     * Choose, which EmailQuarantined to update.
     */
    where: EmailQuarantinedWhereUniqueInput
  }


  /**
   * EmailQuarantined updateMany
   */
  export type EmailQuarantinedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailQuarantineds.
     */
    data: XOR<EmailQuarantinedUpdateManyMutationInput, EmailQuarantinedUncheckedUpdateManyInput>
    /**
     * Filter which EmailQuarantineds to update
     */
    where?: EmailQuarantinedWhereInput
  }


  /**
   * EmailQuarantined upsert
   */
  export type EmailQuarantinedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailQuarantined to update in case it exists.
     */
    where: EmailQuarantinedWhereUniqueInput
    /**
     * In case the EmailQuarantined found by the `where` argument doesn't exist, create a new EmailQuarantined with this data.
     */
    create: XOR<EmailQuarantinedCreateInput, EmailQuarantinedUncheckedCreateInput>
    /**
     * In case the EmailQuarantined was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailQuarantinedUpdateInput, EmailQuarantinedUncheckedUpdateInput>
  }


  /**
   * EmailQuarantined delete
   */
  export type EmailQuarantinedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
    /**
     * Filter which EmailQuarantined to delete.
     */
    where: EmailQuarantinedWhereUniqueInput
  }


  /**
   * EmailQuarantined deleteMany
   */
  export type EmailQuarantinedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailQuarantineds to delete
     */
    where?: EmailQuarantinedWhereInput
  }


  /**
   * EmailQuarantined without action
   */
  export type EmailQuarantinedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailQuarantined
     */
    select?: EmailQuarantinedSelect<ExtArgs> | null
  }



  /**
   * Model EmailTemplate
   */

  export type AggregateEmailTemplate = {
    _count: EmailTemplateCountAggregateOutputType | null
    _avg: EmailTemplateAvgAggregateOutputType | null
    _sum: EmailTemplateSumAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  export type EmailTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type EmailTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type EmailTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    htmlBody: string | null
    textBody: string | null
    category: $Enums.EmailTemplateCategory | null
    usageCount: number | null
    lastUsedAt: Date | null
    isShared: boolean | null
    userId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    htmlBody: string | null
    textBody: string | null
    category: $Enums.EmailTemplateCategory | null
    usageCount: number | null
    lastUsedAt: Date | null
    isShared: boolean | null
    userId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTemplateCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    htmlBody: number
    textBody: number
    category: number
    placeholders: number
    usageCount: number
    lastUsedAt: number
    isShared: number
    userId: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type EmailTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type EmailTemplateMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlBody?: true
    textBody?: true
    category?: true
    usageCount?: true
    lastUsedAt?: true
    isShared?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlBody?: true
    textBody?: true
    category?: true
    usageCount?: true
    lastUsedAt?: true
    isShared?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTemplateCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlBody?: true
    textBody?: true
    category?: true
    placeholders?: true
    usageCount?: true
    lastUsedAt?: true
    isShared?: true
    userId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplate to aggregate.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTemplates
    **/
    _count?: true | EmailTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type GetEmailTemplateAggregateType<T extends EmailTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTemplate[P]>
      : GetScalarType<T[P], AggregateEmailTemplate[P]>
  }




  export type EmailTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTemplateWhereInput
    orderBy?: EmailTemplateOrderByWithAggregationInput | EmailTemplateOrderByWithAggregationInput[]
    by: EmailTemplateScalarFieldEnum[] | EmailTemplateScalarFieldEnum
    having?: EmailTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTemplateCountAggregateInputType | true
    _avg?: EmailTemplateAvgAggregateInputType
    _sum?: EmailTemplateSumAggregateInputType
    _min?: EmailTemplateMinAggregateInputType
    _max?: EmailTemplateMaxAggregateInputType
  }

  export type EmailTemplateGroupByOutputType = {
    id: string
    name: string
    subject: string
    htmlBody: string | null
    textBody: string | null
    category: $Enums.EmailTemplateCategory
    placeholders: string[]
    usageCount: number
    lastUsedAt: Date | null
    isShared: boolean
    userId: string
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailTemplateCountAggregateOutputType | null
    _avg: EmailTemplateAvgAggregateOutputType | null
    _sum: EmailTemplateSumAggregateOutputType | null
    _min: EmailTemplateMinAggregateOutputType | null
    _max: EmailTemplateMaxAggregateOutputType | null
  }

  type GetEmailTemplateGroupByPayload<T extends EmailTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTemplateGroupByOutputType[P]>
        }
      >
    >


  export type EmailTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlBody?: boolean
    textBody?: boolean
    category?: boolean
    placeholders?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    isShared?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailTemplate"]>

  export type EmailTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlBody?: boolean
    textBody?: boolean
    category?: boolean
    placeholders?: boolean
    usageCount?: boolean
    lastUsedAt?: boolean
    isShared?: boolean
    userId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EmailTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      htmlBody: string | null
      textBody: string | null
      category: $Enums.EmailTemplateCategory
      placeholders: string[]
      usageCount: number
      lastUsedAt: Date | null
      isShared: boolean
      userId: string
      companyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTemplate"]>
    composites: {}
  }


  type EmailTemplateGetPayload<S extends boolean | null | undefined | EmailTemplateDefaultArgs> = $Result.GetResult<Prisma.$EmailTemplatePayload, S>

  type EmailTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTemplateCountAggregateInputType | true
    }

  export interface EmailTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTemplate'], meta: { name: 'EmailTemplate' } }
    /**
     * Find zero or one EmailTemplate that matches the filter.
     * @param {EmailTemplateFindUniqueArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailTemplateFindUniqueOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindFirstOrThrowArgs} args - Arguments to find a EmailTemplate
     * @example
     * // Get one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany()
     * 
     * // Get first 10 EmailTemplates
     * const emailTemplates = await prisma.emailTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTemplateWithIdOnly = await prisma.emailTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailTemplate.
     * @param {EmailTemplateCreateArgs} args - Arguments to create a EmailTemplate.
     * @example
     * // Create one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.create({
     *   data: {
     *     // ... data to create a EmailTemplate
     *   }
     * })
     * 
    **/
    create<T extends EmailTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateCreateArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailTemplates.
     *     @param {EmailTemplateCreateManyArgs} args - Arguments to create many EmailTemplates.
     *     @example
     *     // Create many EmailTemplates
     *     const emailTemplate = await prisma.emailTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailTemplate.
     * @param {EmailTemplateDeleteArgs} args - Arguments to delete one EmailTemplate.
     * @example
     * // Delete one EmailTemplate
     * const EmailTemplate = await prisma.emailTemplate.delete({
     *   where: {
     *     // ... filter to delete one EmailTemplate
     *   }
     * })
     * 
    **/
    delete<T extends EmailTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateDeleteArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailTemplate.
     * @param {EmailTemplateUpdateArgs} args - Arguments to update one EmailTemplate.
     * @example
     * // Update one EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpdateArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailTemplates.
     * @param {EmailTemplateDeleteManyArgs} args - Arguments to filter EmailTemplates to delete.
     * @example
     * // Delete a few EmailTemplates
     * const { count } = await prisma.emailTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTemplates
     * const emailTemplate = await prisma.emailTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTemplate.
     * @param {EmailTemplateUpsertArgs} args - Arguments to update or create a EmailTemplate.
     * @example
     * // Update or create a EmailTemplate
     * const emailTemplate = await prisma.emailTemplate.upsert({
     *   create: {
     *     // ... data to create a EmailTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends EmailTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTemplateUpsertArgs<ExtArgs>>
    ): Prisma__EmailTemplateClient<$Result.GetResult<Prisma.$EmailTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateCountArgs} args - Arguments to filter EmailTemplates to count.
     * @example
     * // Count the number of EmailTemplates
     * const count = await prisma.emailTemplate.count({
     *   where: {
     *     // ... the filter for the EmailTemplates we want to count
     *   }
     * })
    **/
    count<T extends EmailTemplateCountArgs>(
      args?: Subset<T, EmailTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTemplateAggregateArgs>(args: Subset<T, EmailTemplateAggregateArgs>): Prisma.PrismaPromise<GetEmailTemplateAggregateType<T>>

    /**
     * Group by EmailTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTemplateGroupByArgs['orderBy'] }
        : { orderBy?: EmailTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTemplate model
   */
  readonly fields: EmailTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailTemplate model
   */ 
  interface EmailTemplateFieldRefs {
    readonly id: FieldRef<"EmailTemplate", 'String'>
    readonly name: FieldRef<"EmailTemplate", 'String'>
    readonly subject: FieldRef<"EmailTemplate", 'String'>
    readonly htmlBody: FieldRef<"EmailTemplate", 'String'>
    readonly textBody: FieldRef<"EmailTemplate", 'String'>
    readonly category: FieldRef<"EmailTemplate", 'EmailTemplateCategory'>
    readonly placeholders: FieldRef<"EmailTemplate", 'String[]'>
    readonly usageCount: FieldRef<"EmailTemplate", 'Int'>
    readonly lastUsedAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly isShared: FieldRef<"EmailTemplate", 'Boolean'>
    readonly userId: FieldRef<"EmailTemplate", 'String'>
    readonly companyId: FieldRef<"EmailTemplate", 'String'>
    readonly createdAt: FieldRef<"EmailTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTemplate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailTemplate findUnique
   */
  export type EmailTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate findUniqueOrThrow
   */
  export type EmailTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate findFirst
   */
  export type EmailTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * EmailTemplate findFirstOrThrow
   */
  export type EmailTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplate to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTemplates.
     */
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * EmailTemplate findMany
   */
  export type EmailTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter, which EmailTemplates to fetch.
     */
    where?: EmailTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTemplates to fetch.
     */
    orderBy?: EmailTemplateOrderByWithRelationInput | EmailTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTemplates.
     */
    cursor?: EmailTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTemplates.
     */
    skip?: number
    distinct?: EmailTemplateScalarFieldEnum | EmailTemplateScalarFieldEnum[]
  }


  /**
   * EmailTemplate create
   */
  export type EmailTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailTemplate.
     */
    data: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
  }


  /**
   * EmailTemplate createMany
   */
  export type EmailTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTemplates.
     */
    data: EmailTemplateCreateManyInput | EmailTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailTemplate update
   */
  export type EmailTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailTemplate.
     */
    data: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
    /**
     * Choose, which EmailTemplate to update.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate updateMany
   */
  export type EmailTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTemplates.
     */
    data: XOR<EmailTemplateUpdateManyMutationInput, EmailTemplateUncheckedUpdateManyInput>
    /**
     * Filter which EmailTemplates to update
     */
    where?: EmailTemplateWhereInput
  }


  /**
   * EmailTemplate upsert
   */
  export type EmailTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailTemplate to update in case it exists.
     */
    where: EmailTemplateWhereUniqueInput
    /**
     * In case the EmailTemplate found by the `where` argument doesn't exist, create a new EmailTemplate with this data.
     */
    create: XOR<EmailTemplateCreateInput, EmailTemplateUncheckedCreateInput>
    /**
     * In case the EmailTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTemplateUpdateInput, EmailTemplateUncheckedUpdateInput>
  }


  /**
   * EmailTemplate delete
   */
  export type EmailTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
    /**
     * Filter which EmailTemplate to delete.
     */
    where: EmailTemplateWhereUniqueInput
  }


  /**
   * EmailTemplate deleteMany
   */
  export type EmailTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTemplates to delete
     */
    where?: EmailTemplateWhereInput
  }


  /**
   * EmailTemplate without action
   */
  export type EmailTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTemplate
     */
    select?: EmailTemplateSelect<ExtArgs> | null
  }



  /**
   * Model VacationResponder
   */

  export type AggregateVacationResponder = {
    _count: VacationResponderCountAggregateOutputType | null
    _min: VacationResponderMinAggregateOutputType | null
    _max: VacationResponderMaxAggregateOutputType | null
  }

  export type VacationResponderMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    subject: string | null
    message: string | null
    isActive: boolean | null
    onlyContacts: boolean | null
    onlyOnce: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VacationResponderMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    subject: string | null
    message: string | null
    isActive: boolean | null
    onlyContacts: boolean | null
    onlyOnce: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VacationResponderCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    subject: number
    message: number
    isActive: number
    onlyContacts: number
    onlyOnce: number
    excludedDomains: number
    respondedTo: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VacationResponderMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    subject?: true
    message?: true
    isActive?: true
    onlyContacts?: true
    onlyOnce?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VacationResponderMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    subject?: true
    message?: true
    isActive?: true
    onlyContacts?: true
    onlyOnce?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VacationResponderCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    subject?: true
    message?: true
    isActive?: true
    onlyContacts?: true
    onlyOnce?: true
    excludedDomains?: true
    respondedTo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VacationResponderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VacationResponder to aggregate.
     */
    where?: VacationResponderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationResponders to fetch.
     */
    orderBy?: VacationResponderOrderByWithRelationInput | VacationResponderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VacationResponderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationResponders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationResponders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VacationResponders
    **/
    _count?: true | VacationResponderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VacationResponderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VacationResponderMaxAggregateInputType
  }

  export type GetVacationResponderAggregateType<T extends VacationResponderAggregateArgs> = {
        [P in keyof T & keyof AggregateVacationResponder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVacationResponder[P]>
      : GetScalarType<T[P], AggregateVacationResponder[P]>
  }




  export type VacationResponderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VacationResponderWhereInput
    orderBy?: VacationResponderOrderByWithAggregationInput | VacationResponderOrderByWithAggregationInput[]
    by: VacationResponderScalarFieldEnum[] | VacationResponderScalarFieldEnum
    having?: VacationResponderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VacationResponderCountAggregateInputType | true
    _min?: VacationResponderMinAggregateInputType
    _max?: VacationResponderMaxAggregateInputType
  }

  export type VacationResponderGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    subject: string
    message: string
    isActive: boolean
    onlyContacts: boolean
    onlyOnce: boolean
    excludedDomains: string[]
    respondedTo: string[]
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: VacationResponderCountAggregateOutputType | null
    _min: VacationResponderMinAggregateOutputType | null
    _max: VacationResponderMaxAggregateOutputType | null
  }

  type GetVacationResponderGroupByPayload<T extends VacationResponderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VacationResponderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VacationResponderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VacationResponderGroupByOutputType[P]>
            : GetScalarType<T[P], VacationResponderGroupByOutputType[P]>
        }
      >
    >


  export type VacationResponderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    subject?: boolean
    message?: boolean
    isActive?: boolean
    onlyContacts?: boolean
    onlyOnce?: boolean
    excludedDomains?: boolean
    respondedTo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vacationResponder"]>

  export type VacationResponderSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    subject?: boolean
    message?: boolean
    isActive?: boolean
    onlyContacts?: boolean
    onlyOnce?: boolean
    excludedDomains?: boolean
    respondedTo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $VacationResponderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VacationResponder"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startDate: Date
      endDate: Date
      subject: string
      message: string
      isActive: boolean
      onlyContacts: boolean
      onlyOnce: boolean
      excludedDomains: string[]
      respondedTo: string[]
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vacationResponder"]>
    composites: {}
  }


  type VacationResponderGetPayload<S extends boolean | null | undefined | VacationResponderDefaultArgs> = $Result.GetResult<Prisma.$VacationResponderPayload, S>

  type VacationResponderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VacationResponderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VacationResponderCountAggregateInputType | true
    }

  export interface VacationResponderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VacationResponder'], meta: { name: 'VacationResponder' } }
    /**
     * Find zero or one VacationResponder that matches the filter.
     * @param {VacationResponderFindUniqueArgs} args - Arguments to find a VacationResponder
     * @example
     * // Get one VacationResponder
     * const vacationResponder = await prisma.vacationResponder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VacationResponderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VacationResponderFindUniqueArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VacationResponder that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VacationResponderFindUniqueOrThrowArgs} args - Arguments to find a VacationResponder
     * @example
     * // Get one VacationResponder
     * const vacationResponder = await prisma.vacationResponder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VacationResponderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VacationResponderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VacationResponder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderFindFirstArgs} args - Arguments to find a VacationResponder
     * @example
     * // Get one VacationResponder
     * const vacationResponder = await prisma.vacationResponder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VacationResponderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VacationResponderFindFirstArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VacationResponder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderFindFirstOrThrowArgs} args - Arguments to find a VacationResponder
     * @example
     * // Get one VacationResponder
     * const vacationResponder = await prisma.vacationResponder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VacationResponderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VacationResponderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VacationResponders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VacationResponders
     * const vacationResponders = await prisma.vacationResponder.findMany()
     * 
     * // Get first 10 VacationResponders
     * const vacationResponders = await prisma.vacationResponder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vacationResponderWithIdOnly = await prisma.vacationResponder.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VacationResponderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VacationResponderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VacationResponder.
     * @param {VacationResponderCreateArgs} args - Arguments to create a VacationResponder.
     * @example
     * // Create one VacationResponder
     * const VacationResponder = await prisma.vacationResponder.create({
     *   data: {
     *     // ... data to create a VacationResponder
     *   }
     * })
     * 
    **/
    create<T extends VacationResponderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VacationResponderCreateArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VacationResponders.
     *     @param {VacationResponderCreateManyArgs} args - Arguments to create many VacationResponders.
     *     @example
     *     // Create many VacationResponders
     *     const vacationResponder = await prisma.vacationResponder.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VacationResponderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VacationResponderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VacationResponder.
     * @param {VacationResponderDeleteArgs} args - Arguments to delete one VacationResponder.
     * @example
     * // Delete one VacationResponder
     * const VacationResponder = await prisma.vacationResponder.delete({
     *   where: {
     *     // ... filter to delete one VacationResponder
     *   }
     * })
     * 
    **/
    delete<T extends VacationResponderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VacationResponderDeleteArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VacationResponder.
     * @param {VacationResponderUpdateArgs} args - Arguments to update one VacationResponder.
     * @example
     * // Update one VacationResponder
     * const vacationResponder = await prisma.vacationResponder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VacationResponderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VacationResponderUpdateArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VacationResponders.
     * @param {VacationResponderDeleteManyArgs} args - Arguments to filter VacationResponders to delete.
     * @example
     * // Delete a few VacationResponders
     * const { count } = await prisma.vacationResponder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VacationResponderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VacationResponderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VacationResponders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VacationResponders
     * const vacationResponder = await prisma.vacationResponder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VacationResponderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VacationResponderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VacationResponder.
     * @param {VacationResponderUpsertArgs} args - Arguments to update or create a VacationResponder.
     * @example
     * // Update or create a VacationResponder
     * const vacationResponder = await prisma.vacationResponder.upsert({
     *   create: {
     *     // ... data to create a VacationResponder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VacationResponder we want to update
     *   }
     * })
    **/
    upsert<T extends VacationResponderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VacationResponderUpsertArgs<ExtArgs>>
    ): Prisma__VacationResponderClient<$Result.GetResult<Prisma.$VacationResponderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VacationResponders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderCountArgs} args - Arguments to filter VacationResponders to count.
     * @example
     * // Count the number of VacationResponders
     * const count = await prisma.vacationResponder.count({
     *   where: {
     *     // ... the filter for the VacationResponders we want to count
     *   }
     * })
    **/
    count<T extends VacationResponderCountArgs>(
      args?: Subset<T, VacationResponderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VacationResponderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VacationResponder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VacationResponderAggregateArgs>(args: Subset<T, VacationResponderAggregateArgs>): Prisma.PrismaPromise<GetVacationResponderAggregateType<T>>

    /**
     * Group by VacationResponder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VacationResponderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VacationResponderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VacationResponderGroupByArgs['orderBy'] }
        : { orderBy?: VacationResponderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VacationResponderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVacationResponderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VacationResponder model
   */
  readonly fields: VacationResponderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VacationResponder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VacationResponderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VacationResponder model
   */ 
  interface VacationResponderFieldRefs {
    readonly id: FieldRef<"VacationResponder", 'String'>
    readonly startDate: FieldRef<"VacationResponder", 'DateTime'>
    readonly endDate: FieldRef<"VacationResponder", 'DateTime'>
    readonly subject: FieldRef<"VacationResponder", 'String'>
    readonly message: FieldRef<"VacationResponder", 'String'>
    readonly isActive: FieldRef<"VacationResponder", 'Boolean'>
    readonly onlyContacts: FieldRef<"VacationResponder", 'Boolean'>
    readonly onlyOnce: FieldRef<"VacationResponder", 'Boolean'>
    readonly excludedDomains: FieldRef<"VacationResponder", 'String[]'>
    readonly respondedTo: FieldRef<"VacationResponder", 'String[]'>
    readonly userId: FieldRef<"VacationResponder", 'String'>
    readonly createdAt: FieldRef<"VacationResponder", 'DateTime'>
    readonly updatedAt: FieldRef<"VacationResponder", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * VacationResponder findUnique
   */
  export type VacationResponderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * Filter, which VacationResponder to fetch.
     */
    where: VacationResponderWhereUniqueInput
  }


  /**
   * VacationResponder findUniqueOrThrow
   */
  export type VacationResponderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * Filter, which VacationResponder to fetch.
     */
    where: VacationResponderWhereUniqueInput
  }


  /**
   * VacationResponder findFirst
   */
  export type VacationResponderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * Filter, which VacationResponder to fetch.
     */
    where?: VacationResponderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationResponders to fetch.
     */
    orderBy?: VacationResponderOrderByWithRelationInput | VacationResponderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VacationResponders.
     */
    cursor?: VacationResponderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationResponders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationResponders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VacationResponders.
     */
    distinct?: VacationResponderScalarFieldEnum | VacationResponderScalarFieldEnum[]
  }


  /**
   * VacationResponder findFirstOrThrow
   */
  export type VacationResponderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * Filter, which VacationResponder to fetch.
     */
    where?: VacationResponderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationResponders to fetch.
     */
    orderBy?: VacationResponderOrderByWithRelationInput | VacationResponderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VacationResponders.
     */
    cursor?: VacationResponderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationResponders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationResponders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VacationResponders.
     */
    distinct?: VacationResponderScalarFieldEnum | VacationResponderScalarFieldEnum[]
  }


  /**
   * VacationResponder findMany
   */
  export type VacationResponderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * Filter, which VacationResponders to fetch.
     */
    where?: VacationResponderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VacationResponders to fetch.
     */
    orderBy?: VacationResponderOrderByWithRelationInput | VacationResponderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VacationResponders.
     */
    cursor?: VacationResponderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VacationResponders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VacationResponders.
     */
    skip?: number
    distinct?: VacationResponderScalarFieldEnum | VacationResponderScalarFieldEnum[]
  }


  /**
   * VacationResponder create
   */
  export type VacationResponderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * The data needed to create a VacationResponder.
     */
    data: XOR<VacationResponderCreateInput, VacationResponderUncheckedCreateInput>
  }


  /**
   * VacationResponder createMany
   */
  export type VacationResponderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VacationResponders.
     */
    data: VacationResponderCreateManyInput | VacationResponderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * VacationResponder update
   */
  export type VacationResponderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * The data needed to update a VacationResponder.
     */
    data: XOR<VacationResponderUpdateInput, VacationResponderUncheckedUpdateInput>
    /**
     * Choose, which VacationResponder to update.
     */
    where: VacationResponderWhereUniqueInput
  }


  /**
   * VacationResponder updateMany
   */
  export type VacationResponderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VacationResponders.
     */
    data: XOR<VacationResponderUpdateManyMutationInput, VacationResponderUncheckedUpdateManyInput>
    /**
     * Filter which VacationResponders to update
     */
    where?: VacationResponderWhereInput
  }


  /**
   * VacationResponder upsert
   */
  export type VacationResponderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * The filter to search for the VacationResponder to update in case it exists.
     */
    where: VacationResponderWhereUniqueInput
    /**
     * In case the VacationResponder found by the `where` argument doesn't exist, create a new VacationResponder with this data.
     */
    create: XOR<VacationResponderCreateInput, VacationResponderUncheckedCreateInput>
    /**
     * In case the VacationResponder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VacationResponderUpdateInput, VacationResponderUncheckedUpdateInput>
  }


  /**
   * VacationResponder delete
   */
  export type VacationResponderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
    /**
     * Filter which VacationResponder to delete.
     */
    where: VacationResponderWhereUniqueInput
  }


  /**
   * VacationResponder deleteMany
   */
  export type VacationResponderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VacationResponders to delete
     */
    where?: VacationResponderWhereInput
  }


  /**
   * VacationResponder without action
   */
  export type VacationResponderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VacationResponder
     */
    select?: VacationResponderSelect<ExtArgs> | null
  }



  /**
   * Model EmailTracking
   */

  export type AggregateEmailTracking = {
    _count: EmailTrackingCountAggregateOutputType | null
    _avg: EmailTrackingAvgAggregateOutputType | null
    _sum: EmailTrackingSumAggregateOutputType | null
    _min: EmailTrackingMinAggregateOutputType | null
    _max: EmailTrackingMaxAggregateOutputType | null
  }

  export type EmailTrackingAvgAggregateOutputType = {
    openCount: number | null
    clickCount: number | null
  }

  export type EmailTrackingSumAggregateOutputType = {
    openCount: number | null
    clickCount: number | null
  }

  export type EmailTrackingMinAggregateOutputType = {
    id: string | null
    trackingId: string | null
    emailId: string | null
    outboxId: string | null
    subject: string | null
    recipientEmail: string | null
    openCount: number | null
    clickCount: number | null
    firstOpenedAt: Date | null
    lastOpenedAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTrackingMaxAggregateOutputType = {
    id: string | null
    trackingId: string | null
    emailId: string | null
    outboxId: string | null
    subject: string | null
    recipientEmail: string | null
    openCount: number | null
    clickCount: number | null
    firstOpenedAt: Date | null
    lastOpenedAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailTrackingCountAggregateOutputType = {
    id: number
    trackingId: number
    emailId: number
    outboxId: number
    subject: number
    recipientEmail: number
    openCount: number
    clickCount: number
    firstOpenedAt: number
    lastOpenedAt: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailTrackingAvgAggregateInputType = {
    openCount?: true
    clickCount?: true
  }

  export type EmailTrackingSumAggregateInputType = {
    openCount?: true
    clickCount?: true
  }

  export type EmailTrackingMinAggregateInputType = {
    id?: true
    trackingId?: true
    emailId?: true
    outboxId?: true
    subject?: true
    recipientEmail?: true
    openCount?: true
    clickCount?: true
    firstOpenedAt?: true
    lastOpenedAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTrackingMaxAggregateInputType = {
    id?: true
    trackingId?: true
    emailId?: true
    outboxId?: true
    subject?: true
    recipientEmail?: true
    openCount?: true
    clickCount?: true
    firstOpenedAt?: true
    lastOpenedAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailTrackingCountAggregateInputType = {
    id?: true
    trackingId?: true
    emailId?: true
    outboxId?: true
    subject?: true
    recipientEmail?: true
    openCount?: true
    clickCount?: true
    firstOpenedAt?: true
    lastOpenedAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTracking to aggregate.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTrackings
    **/
    _count?: true | EmailTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTrackingMaxAggregateInputType
  }

  export type GetEmailTrackingAggregateType<T extends EmailTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTracking[P]>
      : GetScalarType<T[P], AggregateEmailTracking[P]>
  }




  export type EmailTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTrackingWhereInput
    orderBy?: EmailTrackingOrderByWithAggregationInput | EmailTrackingOrderByWithAggregationInput[]
    by: EmailTrackingScalarFieldEnum[] | EmailTrackingScalarFieldEnum
    having?: EmailTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTrackingCountAggregateInputType | true
    _avg?: EmailTrackingAvgAggregateInputType
    _sum?: EmailTrackingSumAggregateInputType
    _min?: EmailTrackingMinAggregateInputType
    _max?: EmailTrackingMaxAggregateInputType
  }

  export type EmailTrackingGroupByOutputType = {
    id: string
    trackingId: string
    emailId: string | null
    outboxId: string | null
    subject: string
    recipientEmail: string
    openCount: number
    clickCount: number
    firstOpenedAt: Date | null
    lastOpenedAt: Date | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailTrackingCountAggregateOutputType | null
    _avg: EmailTrackingAvgAggregateOutputType | null
    _sum: EmailTrackingSumAggregateOutputType | null
    _min: EmailTrackingMinAggregateOutputType | null
    _max: EmailTrackingMaxAggregateOutputType | null
  }

  type GetEmailTrackingGroupByPayload<T extends EmailTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTrackingGroupByOutputType[P]>
        }
      >
    >


  export type EmailTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingId?: boolean
    emailId?: boolean
    outboxId?: boolean
    subject?: boolean
    recipientEmail?: boolean
    openCount?: boolean
    clickCount?: boolean
    firstOpenedAt?: boolean
    lastOpenedAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opens?: boolean | EmailTracking$opensArgs<ExtArgs>
    clicks?: boolean | EmailTracking$clicksArgs<ExtArgs>
    _count?: boolean | EmailTrackingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTracking"]>

  export type EmailTrackingSelectScalar = {
    id?: boolean
    trackingId?: boolean
    emailId?: boolean
    outboxId?: boolean
    subject?: boolean
    recipientEmail?: boolean
    openCount?: boolean
    clickCount?: boolean
    firstOpenedAt?: boolean
    lastOpenedAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opens?: boolean | EmailTracking$opensArgs<ExtArgs>
    clicks?: boolean | EmailTracking$clicksArgs<ExtArgs>
    _count?: boolean | EmailTrackingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTracking"
    objects: {
      opens: Prisma.$EmailTrackingEventPayload<ExtArgs>[]
      clicks: Prisma.$EmailLinkClickPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trackingId: string
      emailId: string | null
      outboxId: string | null
      subject: string
      recipientEmail: string
      openCount: number
      clickCount: number
      firstOpenedAt: Date | null
      lastOpenedAt: Date | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailTracking"]>
    composites: {}
  }


  type EmailTrackingGetPayload<S extends boolean | null | undefined | EmailTrackingDefaultArgs> = $Result.GetResult<Prisma.$EmailTrackingPayload, S>

  type EmailTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTrackingCountAggregateInputType | true
    }

  export interface EmailTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTracking'], meta: { name: 'EmailTracking' } }
    /**
     * Find zero or one EmailTracking that matches the filter.
     * @param {EmailTrackingFindUniqueArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailTrackingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailTracking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailTrackingFindUniqueOrThrowArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailTrackingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingFindFirstArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailTrackingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingFindFirstArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingFindFirstOrThrowArgs} args - Arguments to find a EmailTracking
     * @example
     * // Get one EmailTracking
     * const emailTracking = await prisma.emailTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailTrackingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTrackings
     * const emailTrackings = await prisma.emailTracking.findMany()
     * 
     * // Get first 10 EmailTrackings
     * const emailTrackings = await prisma.emailTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTrackingWithIdOnly = await prisma.emailTracking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailTrackingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailTracking.
     * @param {EmailTrackingCreateArgs} args - Arguments to create a EmailTracking.
     * @example
     * // Create one EmailTracking
     * const EmailTracking = await prisma.emailTracking.create({
     *   data: {
     *     // ... data to create a EmailTracking
     *   }
     * })
     * 
    **/
    create<T extends EmailTrackingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingCreateArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailTrackings.
     *     @param {EmailTrackingCreateManyArgs} args - Arguments to create many EmailTrackings.
     *     @example
     *     // Create many EmailTrackings
     *     const emailTracking = await prisma.emailTracking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailTrackingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailTracking.
     * @param {EmailTrackingDeleteArgs} args - Arguments to delete one EmailTracking.
     * @example
     * // Delete one EmailTracking
     * const EmailTracking = await prisma.emailTracking.delete({
     *   where: {
     *     // ... filter to delete one EmailTracking
     *   }
     * })
     * 
    **/
    delete<T extends EmailTrackingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingDeleteArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailTracking.
     * @param {EmailTrackingUpdateArgs} args - Arguments to update one EmailTracking.
     * @example
     * // Update one EmailTracking
     * const emailTracking = await prisma.emailTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailTrackingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingUpdateArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailTrackings.
     * @param {EmailTrackingDeleteManyArgs} args - Arguments to filter EmailTrackings to delete.
     * @example
     * // Delete a few EmailTrackings
     * const { count } = await prisma.emailTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailTrackingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTrackings
     * const emailTracking = await prisma.emailTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailTrackingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTracking.
     * @param {EmailTrackingUpsertArgs} args - Arguments to update or create a EmailTracking.
     * @example
     * // Update or create a EmailTracking
     * const emailTracking = await prisma.emailTracking.upsert({
     *   create: {
     *     // ... data to create a EmailTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTracking we want to update
     *   }
     * })
    **/
    upsert<T extends EmailTrackingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingUpsertArgs<ExtArgs>>
    ): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingCountArgs} args - Arguments to filter EmailTrackings to count.
     * @example
     * // Count the number of EmailTrackings
     * const count = await prisma.emailTracking.count({
     *   where: {
     *     // ... the filter for the EmailTrackings we want to count
     *   }
     * })
    **/
    count<T extends EmailTrackingCountArgs>(
      args?: Subset<T, EmailTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTrackingAggregateArgs>(args: Subset<T, EmailTrackingAggregateArgs>): Prisma.PrismaPromise<GetEmailTrackingAggregateType<T>>

    /**
     * Group by EmailTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTrackingGroupByArgs['orderBy'] }
        : { orderBy?: EmailTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTracking model
   */
  readonly fields: EmailTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    opens<T extends EmailTracking$opensArgs<ExtArgs> = {}>(args?: Subset<T, EmailTracking$opensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'findMany'> | Null>;

    clicks<T extends EmailTracking$clicksArgs<ExtArgs> = {}>(args?: Subset<T, EmailTracking$clicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailTracking model
   */ 
  interface EmailTrackingFieldRefs {
    readonly id: FieldRef<"EmailTracking", 'String'>
    readonly trackingId: FieldRef<"EmailTracking", 'String'>
    readonly emailId: FieldRef<"EmailTracking", 'String'>
    readonly outboxId: FieldRef<"EmailTracking", 'String'>
    readonly subject: FieldRef<"EmailTracking", 'String'>
    readonly recipientEmail: FieldRef<"EmailTracking", 'String'>
    readonly openCount: FieldRef<"EmailTracking", 'Int'>
    readonly clickCount: FieldRef<"EmailTracking", 'Int'>
    readonly firstOpenedAt: FieldRef<"EmailTracking", 'DateTime'>
    readonly lastOpenedAt: FieldRef<"EmailTracking", 'DateTime'>
    readonly userId: FieldRef<"EmailTracking", 'String'>
    readonly createdAt: FieldRef<"EmailTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailTracking", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailTracking findUnique
   */
  export type EmailTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where: EmailTrackingWhereUniqueInput
  }


  /**
   * EmailTracking findUniqueOrThrow
   */
  export type EmailTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where: EmailTrackingWhereUniqueInput
  }


  /**
   * EmailTracking findFirst
   */
  export type EmailTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTrackings.
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTrackings.
     */
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }


  /**
   * EmailTracking findFirstOrThrow
   */
  export type EmailTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTracking to fetch.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTrackings.
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTrackings.
     */
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }


  /**
   * EmailTracking findMany
   */
  export type EmailTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackings to fetch.
     */
    where?: EmailTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackings to fetch.
     */
    orderBy?: EmailTrackingOrderByWithRelationInput | EmailTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTrackings.
     */
    cursor?: EmailTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackings.
     */
    skip?: number
    distinct?: EmailTrackingScalarFieldEnum | EmailTrackingScalarFieldEnum[]
  }


  /**
   * EmailTracking create
   */
  export type EmailTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTracking.
     */
    data: XOR<EmailTrackingCreateInput, EmailTrackingUncheckedCreateInput>
  }


  /**
   * EmailTracking createMany
   */
  export type EmailTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTrackings.
     */
    data: EmailTrackingCreateManyInput | EmailTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailTracking update
   */
  export type EmailTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTracking.
     */
    data: XOR<EmailTrackingUpdateInput, EmailTrackingUncheckedUpdateInput>
    /**
     * Choose, which EmailTracking to update.
     */
    where: EmailTrackingWhereUniqueInput
  }


  /**
   * EmailTracking updateMany
   */
  export type EmailTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTrackings.
     */
    data: XOR<EmailTrackingUpdateManyMutationInput, EmailTrackingUncheckedUpdateManyInput>
    /**
     * Filter which EmailTrackings to update
     */
    where?: EmailTrackingWhereInput
  }


  /**
   * EmailTracking upsert
   */
  export type EmailTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTracking to update in case it exists.
     */
    where: EmailTrackingWhereUniqueInput
    /**
     * In case the EmailTracking found by the `where` argument doesn't exist, create a new EmailTracking with this data.
     */
    create: XOR<EmailTrackingCreateInput, EmailTrackingUncheckedCreateInput>
    /**
     * In case the EmailTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTrackingUpdateInput, EmailTrackingUncheckedUpdateInput>
  }


  /**
   * EmailTracking delete
   */
  export type EmailTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
    /**
     * Filter which EmailTracking to delete.
     */
    where: EmailTrackingWhereUniqueInput
  }


  /**
   * EmailTracking deleteMany
   */
  export type EmailTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTrackings to delete
     */
    where?: EmailTrackingWhereInput
  }


  /**
   * EmailTracking.opens
   */
  export type EmailTracking$opensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    where?: EmailTrackingEventWhereInput
    orderBy?: EmailTrackingEventOrderByWithRelationInput | EmailTrackingEventOrderByWithRelationInput[]
    cursor?: EmailTrackingEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTrackingEventScalarFieldEnum | EmailTrackingEventScalarFieldEnum[]
  }


  /**
   * EmailTracking.clicks
   */
  export type EmailTracking$clicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    where?: EmailLinkClickWhereInput
    orderBy?: EmailLinkClickOrderByWithRelationInput | EmailLinkClickOrderByWithRelationInput[]
    cursor?: EmailLinkClickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLinkClickScalarFieldEnum | EmailLinkClickScalarFieldEnum[]
  }


  /**
   * EmailTracking without action
   */
  export type EmailTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTracking
     */
    select?: EmailTrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingInclude<ExtArgs> | null
  }



  /**
   * Model EmailTrackingEvent
   */

  export type AggregateEmailTrackingEvent = {
    _count: EmailTrackingEventCountAggregateOutputType | null
    _min: EmailTrackingEventMinAggregateOutputType | null
    _max: EmailTrackingEventMaxAggregateOutputType | null
  }

  export type EmailTrackingEventMinAggregateOutputType = {
    id: string | null
    trackingId: string | null
    eventType: string | null
    ipAddress: string | null
    userAgent: string | null
    device: string | null
    browser: string | null
    country: string | null
    city: string | null
    createdAt: Date | null
  }

  export type EmailTrackingEventMaxAggregateOutputType = {
    id: string | null
    trackingId: string | null
    eventType: string | null
    ipAddress: string | null
    userAgent: string | null
    device: string | null
    browser: string | null
    country: string | null
    city: string | null
    createdAt: Date | null
  }

  export type EmailTrackingEventCountAggregateOutputType = {
    id: number
    trackingId: number
    eventType: number
    ipAddress: number
    userAgent: number
    device: number
    browser: number
    country: number
    city: number
    createdAt: number
    _all: number
  }


  export type EmailTrackingEventMinAggregateInputType = {
    id?: true
    trackingId?: true
    eventType?: true
    ipAddress?: true
    userAgent?: true
    device?: true
    browser?: true
    country?: true
    city?: true
    createdAt?: true
  }

  export type EmailTrackingEventMaxAggregateInputType = {
    id?: true
    trackingId?: true
    eventType?: true
    ipAddress?: true
    userAgent?: true
    device?: true
    browser?: true
    country?: true
    city?: true
    createdAt?: true
  }

  export type EmailTrackingEventCountAggregateInputType = {
    id?: true
    trackingId?: true
    eventType?: true
    ipAddress?: true
    userAgent?: true
    device?: true
    browser?: true
    country?: true
    city?: true
    createdAt?: true
    _all?: true
  }

  export type EmailTrackingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTrackingEvent to aggregate.
     */
    where?: EmailTrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackingEvents to fetch.
     */
    orderBy?: EmailTrackingEventOrderByWithRelationInput | EmailTrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTrackingEvents
    **/
    _count?: true | EmailTrackingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTrackingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTrackingEventMaxAggregateInputType
  }

  export type GetEmailTrackingEventAggregateType<T extends EmailTrackingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTrackingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTrackingEvent[P]>
      : GetScalarType<T[P], AggregateEmailTrackingEvent[P]>
  }




  export type EmailTrackingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTrackingEventWhereInput
    orderBy?: EmailTrackingEventOrderByWithAggregationInput | EmailTrackingEventOrderByWithAggregationInput[]
    by: EmailTrackingEventScalarFieldEnum[] | EmailTrackingEventScalarFieldEnum
    having?: EmailTrackingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTrackingEventCountAggregateInputType | true
    _min?: EmailTrackingEventMinAggregateInputType
    _max?: EmailTrackingEventMaxAggregateInputType
  }

  export type EmailTrackingEventGroupByOutputType = {
    id: string
    trackingId: string
    eventType: string
    ipAddress: string | null
    userAgent: string | null
    device: string | null
    browser: string | null
    country: string | null
    city: string | null
    createdAt: Date
    _count: EmailTrackingEventCountAggregateOutputType | null
    _min: EmailTrackingEventMinAggregateOutputType | null
    _max: EmailTrackingEventMaxAggregateOutputType | null
  }

  type GetEmailTrackingEventGroupByPayload<T extends EmailTrackingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTrackingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTrackingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTrackingEventGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTrackingEventGroupByOutputType[P]>
        }
      >
    >


  export type EmailTrackingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingId?: boolean
    eventType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    device?: boolean
    browser?: boolean
    country?: boolean
    city?: boolean
    createdAt?: boolean
    tracking?: boolean | EmailTrackingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTrackingEvent"]>

  export type EmailTrackingEventSelectScalar = {
    id?: boolean
    trackingId?: boolean
    eventType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    device?: boolean
    browser?: boolean
    country?: boolean
    city?: boolean
    createdAt?: boolean
  }

  export type EmailTrackingEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracking?: boolean | EmailTrackingDefaultArgs<ExtArgs>
  }


  export type $EmailTrackingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTrackingEvent"
    objects: {
      tracking: Prisma.$EmailTrackingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trackingId: string
      eventType: string
      ipAddress: string | null
      userAgent: string | null
      device: string | null
      browser: string | null
      country: string | null
      city: string | null
      createdAt: Date
    }, ExtArgs["result"]["emailTrackingEvent"]>
    composites: {}
  }


  type EmailTrackingEventGetPayload<S extends boolean | null | undefined | EmailTrackingEventDefaultArgs> = $Result.GetResult<Prisma.$EmailTrackingEventPayload, S>

  type EmailTrackingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailTrackingEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailTrackingEventCountAggregateInputType | true
    }

  export interface EmailTrackingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTrackingEvent'], meta: { name: 'EmailTrackingEvent' } }
    /**
     * Find zero or one EmailTrackingEvent that matches the filter.
     * @param {EmailTrackingEventFindUniqueArgs} args - Arguments to find a EmailTrackingEvent
     * @example
     * // Get one EmailTrackingEvent
     * const emailTrackingEvent = await prisma.emailTrackingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailTrackingEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingEventFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailTrackingEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailTrackingEventFindUniqueOrThrowArgs} args - Arguments to find a EmailTrackingEvent
     * @example
     * // Get one EmailTrackingEvent
     * const emailTrackingEvent = await prisma.emailTrackingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailTrackingEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailTrackingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventFindFirstArgs} args - Arguments to find a EmailTrackingEvent
     * @example
     * // Get one EmailTrackingEvent
     * const emailTrackingEvent = await prisma.emailTrackingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailTrackingEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingEventFindFirstArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailTrackingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventFindFirstOrThrowArgs} args - Arguments to find a EmailTrackingEvent
     * @example
     * // Get one EmailTrackingEvent
     * const emailTrackingEvent = await prisma.emailTrackingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailTrackingEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailTrackingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTrackingEvents
     * const emailTrackingEvents = await prisma.emailTrackingEvent.findMany()
     * 
     * // Get first 10 EmailTrackingEvents
     * const emailTrackingEvents = await prisma.emailTrackingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailTrackingEventWithIdOnly = await prisma.emailTrackingEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailTrackingEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailTrackingEvent.
     * @param {EmailTrackingEventCreateArgs} args - Arguments to create a EmailTrackingEvent.
     * @example
     * // Create one EmailTrackingEvent
     * const EmailTrackingEvent = await prisma.emailTrackingEvent.create({
     *   data: {
     *     // ... data to create a EmailTrackingEvent
     *   }
     * })
     * 
    **/
    create<T extends EmailTrackingEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingEventCreateArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailTrackingEvents.
     *     @param {EmailTrackingEventCreateManyArgs} args - Arguments to create many EmailTrackingEvents.
     *     @example
     *     // Create many EmailTrackingEvents
     *     const emailTrackingEvent = await prisma.emailTrackingEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailTrackingEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailTrackingEvent.
     * @param {EmailTrackingEventDeleteArgs} args - Arguments to delete one EmailTrackingEvent.
     * @example
     * // Delete one EmailTrackingEvent
     * const EmailTrackingEvent = await prisma.emailTrackingEvent.delete({
     *   where: {
     *     // ... filter to delete one EmailTrackingEvent
     *   }
     * })
     * 
    **/
    delete<T extends EmailTrackingEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingEventDeleteArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailTrackingEvent.
     * @param {EmailTrackingEventUpdateArgs} args - Arguments to update one EmailTrackingEvent.
     * @example
     * // Update one EmailTrackingEvent
     * const emailTrackingEvent = await prisma.emailTrackingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailTrackingEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingEventUpdateArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailTrackingEvents.
     * @param {EmailTrackingEventDeleteManyArgs} args - Arguments to filter EmailTrackingEvents to delete.
     * @example
     * // Delete a few EmailTrackingEvents
     * const { count } = await prisma.emailTrackingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailTrackingEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailTrackingEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTrackingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTrackingEvents
     * const emailTrackingEvent = await prisma.emailTrackingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailTrackingEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailTrackingEvent.
     * @param {EmailTrackingEventUpsertArgs} args - Arguments to update or create a EmailTrackingEvent.
     * @example
     * // Update or create a EmailTrackingEvent
     * const emailTrackingEvent = await prisma.emailTrackingEvent.upsert({
     *   create: {
     *     // ... data to create a EmailTrackingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTrackingEvent we want to update
     *   }
     * })
    **/
    upsert<T extends EmailTrackingEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailTrackingEventUpsertArgs<ExtArgs>>
    ): Prisma__EmailTrackingEventClient<$Result.GetResult<Prisma.$EmailTrackingEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailTrackingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventCountArgs} args - Arguments to filter EmailTrackingEvents to count.
     * @example
     * // Count the number of EmailTrackingEvents
     * const count = await prisma.emailTrackingEvent.count({
     *   where: {
     *     // ... the filter for the EmailTrackingEvents we want to count
     *   }
     * })
    **/
    count<T extends EmailTrackingEventCountArgs>(
      args?: Subset<T, EmailTrackingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTrackingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTrackingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTrackingEventAggregateArgs>(args: Subset<T, EmailTrackingEventAggregateArgs>): Prisma.PrismaPromise<GetEmailTrackingEventAggregateType<T>>

    /**
     * Group by EmailTrackingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTrackingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTrackingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTrackingEventGroupByArgs['orderBy'] }
        : { orderBy?: EmailTrackingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTrackingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTrackingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTrackingEvent model
   */
  readonly fields: EmailTrackingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTrackingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTrackingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tracking<T extends EmailTrackingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailTrackingDefaultArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailTrackingEvent model
   */ 
  interface EmailTrackingEventFieldRefs {
    readonly id: FieldRef<"EmailTrackingEvent", 'String'>
    readonly trackingId: FieldRef<"EmailTrackingEvent", 'String'>
    readonly eventType: FieldRef<"EmailTrackingEvent", 'String'>
    readonly ipAddress: FieldRef<"EmailTrackingEvent", 'String'>
    readonly userAgent: FieldRef<"EmailTrackingEvent", 'String'>
    readonly device: FieldRef<"EmailTrackingEvent", 'String'>
    readonly browser: FieldRef<"EmailTrackingEvent", 'String'>
    readonly country: FieldRef<"EmailTrackingEvent", 'String'>
    readonly city: FieldRef<"EmailTrackingEvent", 'String'>
    readonly createdAt: FieldRef<"EmailTrackingEvent", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailTrackingEvent findUnique
   */
  export type EmailTrackingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackingEvent to fetch.
     */
    where: EmailTrackingEventWhereUniqueInput
  }


  /**
   * EmailTrackingEvent findUniqueOrThrow
   */
  export type EmailTrackingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackingEvent to fetch.
     */
    where: EmailTrackingEventWhereUniqueInput
  }


  /**
   * EmailTrackingEvent findFirst
   */
  export type EmailTrackingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackingEvent to fetch.
     */
    where?: EmailTrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackingEvents to fetch.
     */
    orderBy?: EmailTrackingEventOrderByWithRelationInput | EmailTrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTrackingEvents.
     */
    cursor?: EmailTrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTrackingEvents.
     */
    distinct?: EmailTrackingEventScalarFieldEnum | EmailTrackingEventScalarFieldEnum[]
  }


  /**
   * EmailTrackingEvent findFirstOrThrow
   */
  export type EmailTrackingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackingEvent to fetch.
     */
    where?: EmailTrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackingEvents to fetch.
     */
    orderBy?: EmailTrackingEventOrderByWithRelationInput | EmailTrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTrackingEvents.
     */
    cursor?: EmailTrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTrackingEvents.
     */
    distinct?: EmailTrackingEventScalarFieldEnum | EmailTrackingEventScalarFieldEnum[]
  }


  /**
   * EmailTrackingEvent findMany
   */
  export type EmailTrackingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailTrackingEvents to fetch.
     */
    where?: EmailTrackingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTrackingEvents to fetch.
     */
    orderBy?: EmailTrackingEventOrderByWithRelationInput | EmailTrackingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTrackingEvents.
     */
    cursor?: EmailTrackingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTrackingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTrackingEvents.
     */
    skip?: number
    distinct?: EmailTrackingEventScalarFieldEnum | EmailTrackingEventScalarFieldEnum[]
  }


  /**
   * EmailTrackingEvent create
   */
  export type EmailTrackingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTrackingEvent.
     */
    data: XOR<EmailTrackingEventCreateInput, EmailTrackingEventUncheckedCreateInput>
  }


  /**
   * EmailTrackingEvent createMany
   */
  export type EmailTrackingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTrackingEvents.
     */
    data: EmailTrackingEventCreateManyInput | EmailTrackingEventCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailTrackingEvent update
   */
  export type EmailTrackingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTrackingEvent.
     */
    data: XOR<EmailTrackingEventUpdateInput, EmailTrackingEventUncheckedUpdateInput>
    /**
     * Choose, which EmailTrackingEvent to update.
     */
    where: EmailTrackingEventWhereUniqueInput
  }


  /**
   * EmailTrackingEvent updateMany
   */
  export type EmailTrackingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTrackingEvents.
     */
    data: XOR<EmailTrackingEventUpdateManyMutationInput, EmailTrackingEventUncheckedUpdateManyInput>
    /**
     * Filter which EmailTrackingEvents to update
     */
    where?: EmailTrackingEventWhereInput
  }


  /**
   * EmailTrackingEvent upsert
   */
  export type EmailTrackingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTrackingEvent to update in case it exists.
     */
    where: EmailTrackingEventWhereUniqueInput
    /**
     * In case the EmailTrackingEvent found by the `where` argument doesn't exist, create a new EmailTrackingEvent with this data.
     */
    create: XOR<EmailTrackingEventCreateInput, EmailTrackingEventUncheckedCreateInput>
    /**
     * In case the EmailTrackingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTrackingEventUpdateInput, EmailTrackingEventUncheckedUpdateInput>
  }


  /**
   * EmailTrackingEvent delete
   */
  export type EmailTrackingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
    /**
     * Filter which EmailTrackingEvent to delete.
     */
    where: EmailTrackingEventWhereUniqueInput
  }


  /**
   * EmailTrackingEvent deleteMany
   */
  export type EmailTrackingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTrackingEvents to delete
     */
    where?: EmailTrackingEventWhereInput
  }


  /**
   * EmailTrackingEvent without action
   */
  export type EmailTrackingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTrackingEvent
     */
    select?: EmailTrackingEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailTrackingEventInclude<ExtArgs> | null
  }



  /**
   * Model EmailLinkClick
   */

  export type AggregateEmailLinkClick = {
    _count: EmailLinkClickCountAggregateOutputType | null
    _avg: EmailLinkClickAvgAggregateOutputType | null
    _sum: EmailLinkClickSumAggregateOutputType | null
    _min: EmailLinkClickMinAggregateOutputType | null
    _max: EmailLinkClickMaxAggregateOutputType | null
  }

  export type EmailLinkClickAvgAggregateOutputType = {
    clickCount: number | null
  }

  export type EmailLinkClickSumAggregateOutputType = {
    clickCount: number | null
  }

  export type EmailLinkClickMinAggregateOutputType = {
    id: string | null
    trackingId: string | null
    originalUrl: string | null
    clickCount: number | null
    ipAddress: string | null
    userAgent: string | null
    firstClickedAt: Date | null
    lastClickedAt: Date | null
  }

  export type EmailLinkClickMaxAggregateOutputType = {
    id: string | null
    trackingId: string | null
    originalUrl: string | null
    clickCount: number | null
    ipAddress: string | null
    userAgent: string | null
    firstClickedAt: Date | null
    lastClickedAt: Date | null
  }

  export type EmailLinkClickCountAggregateOutputType = {
    id: number
    trackingId: number
    originalUrl: number
    clickCount: number
    ipAddress: number
    userAgent: number
    firstClickedAt: number
    lastClickedAt: number
    _all: number
  }


  export type EmailLinkClickAvgAggregateInputType = {
    clickCount?: true
  }

  export type EmailLinkClickSumAggregateInputType = {
    clickCount?: true
  }

  export type EmailLinkClickMinAggregateInputType = {
    id?: true
    trackingId?: true
    originalUrl?: true
    clickCount?: true
    ipAddress?: true
    userAgent?: true
    firstClickedAt?: true
    lastClickedAt?: true
  }

  export type EmailLinkClickMaxAggregateInputType = {
    id?: true
    trackingId?: true
    originalUrl?: true
    clickCount?: true
    ipAddress?: true
    userAgent?: true
    firstClickedAt?: true
    lastClickedAt?: true
  }

  export type EmailLinkClickCountAggregateInputType = {
    id?: true
    trackingId?: true
    originalUrl?: true
    clickCount?: true
    ipAddress?: true
    userAgent?: true
    firstClickedAt?: true
    lastClickedAt?: true
    _all?: true
  }

  export type EmailLinkClickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLinkClick to aggregate.
     */
    where?: EmailLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLinkClicks to fetch.
     */
    orderBy?: EmailLinkClickOrderByWithRelationInput | EmailLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLinkClicks
    **/
    _count?: true | EmailLinkClickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailLinkClickAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailLinkClickSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLinkClickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLinkClickMaxAggregateInputType
  }

  export type GetEmailLinkClickAggregateType<T extends EmailLinkClickAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLinkClick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLinkClick[P]>
      : GetScalarType<T[P], AggregateEmailLinkClick[P]>
  }




  export type EmailLinkClickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLinkClickWhereInput
    orderBy?: EmailLinkClickOrderByWithAggregationInput | EmailLinkClickOrderByWithAggregationInput[]
    by: EmailLinkClickScalarFieldEnum[] | EmailLinkClickScalarFieldEnum
    having?: EmailLinkClickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLinkClickCountAggregateInputType | true
    _avg?: EmailLinkClickAvgAggregateInputType
    _sum?: EmailLinkClickSumAggregateInputType
    _min?: EmailLinkClickMinAggregateInputType
    _max?: EmailLinkClickMaxAggregateInputType
  }

  export type EmailLinkClickGroupByOutputType = {
    id: string
    trackingId: string
    originalUrl: string
    clickCount: number
    ipAddress: string | null
    userAgent: string | null
    firstClickedAt: Date
    lastClickedAt: Date
    _count: EmailLinkClickCountAggregateOutputType | null
    _avg: EmailLinkClickAvgAggregateOutputType | null
    _sum: EmailLinkClickSumAggregateOutputType | null
    _min: EmailLinkClickMinAggregateOutputType | null
    _max: EmailLinkClickMaxAggregateOutputType | null
  }

  type GetEmailLinkClickGroupByPayload<T extends EmailLinkClickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLinkClickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLinkClickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLinkClickGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLinkClickGroupByOutputType[P]>
        }
      >
    >


  export type EmailLinkClickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trackingId?: boolean
    originalUrl?: boolean
    clickCount?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    firstClickedAt?: boolean
    lastClickedAt?: boolean
    tracking?: boolean | EmailTrackingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailLinkClick"]>

  export type EmailLinkClickSelectScalar = {
    id?: boolean
    trackingId?: boolean
    originalUrl?: boolean
    clickCount?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    firstClickedAt?: boolean
    lastClickedAt?: boolean
  }

  export type EmailLinkClickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tracking?: boolean | EmailTrackingDefaultArgs<ExtArgs>
  }


  export type $EmailLinkClickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLinkClick"
    objects: {
      tracking: Prisma.$EmailTrackingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trackingId: string
      originalUrl: string
      clickCount: number
      ipAddress: string | null
      userAgent: string | null
      firstClickedAt: Date
      lastClickedAt: Date
    }, ExtArgs["result"]["emailLinkClick"]>
    composites: {}
  }


  type EmailLinkClickGetPayload<S extends boolean | null | undefined | EmailLinkClickDefaultArgs> = $Result.GetResult<Prisma.$EmailLinkClickPayload, S>

  type EmailLinkClickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailLinkClickFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailLinkClickCountAggregateInputType | true
    }

  export interface EmailLinkClickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLinkClick'], meta: { name: 'EmailLinkClick' } }
    /**
     * Find zero or one EmailLinkClick that matches the filter.
     * @param {EmailLinkClickFindUniqueArgs} args - Arguments to find a EmailLinkClick
     * @example
     * // Get one EmailLinkClick
     * const emailLinkClick = await prisma.emailLinkClick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailLinkClickFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLinkClickFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailLinkClick that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailLinkClickFindUniqueOrThrowArgs} args - Arguments to find a EmailLinkClick
     * @example
     * // Get one EmailLinkClick
     * const emailLinkClick = await prisma.emailLinkClick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailLinkClickFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLinkClickFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailLinkClick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickFindFirstArgs} args - Arguments to find a EmailLinkClick
     * @example
     * // Get one EmailLinkClick
     * const emailLinkClick = await prisma.emailLinkClick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailLinkClickFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLinkClickFindFirstArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailLinkClick that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickFindFirstOrThrowArgs} args - Arguments to find a EmailLinkClick
     * @example
     * // Get one EmailLinkClick
     * const emailLinkClick = await prisma.emailLinkClick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailLinkClickFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLinkClickFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailLinkClicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLinkClicks
     * const emailLinkClicks = await prisma.emailLinkClick.findMany()
     * 
     * // Get first 10 EmailLinkClicks
     * const emailLinkClicks = await prisma.emailLinkClick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLinkClickWithIdOnly = await prisma.emailLinkClick.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailLinkClickFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLinkClickFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailLinkClick.
     * @param {EmailLinkClickCreateArgs} args - Arguments to create a EmailLinkClick.
     * @example
     * // Create one EmailLinkClick
     * const EmailLinkClick = await prisma.emailLinkClick.create({
     *   data: {
     *     // ... data to create a EmailLinkClick
     *   }
     * })
     * 
    **/
    create<T extends EmailLinkClickCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLinkClickCreateArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailLinkClicks.
     *     @param {EmailLinkClickCreateManyArgs} args - Arguments to create many EmailLinkClicks.
     *     @example
     *     // Create many EmailLinkClicks
     *     const emailLinkClick = await prisma.emailLinkClick.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailLinkClickCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLinkClickCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailLinkClick.
     * @param {EmailLinkClickDeleteArgs} args - Arguments to delete one EmailLinkClick.
     * @example
     * // Delete one EmailLinkClick
     * const EmailLinkClick = await prisma.emailLinkClick.delete({
     *   where: {
     *     // ... filter to delete one EmailLinkClick
     *   }
     * })
     * 
    **/
    delete<T extends EmailLinkClickDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLinkClickDeleteArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailLinkClick.
     * @param {EmailLinkClickUpdateArgs} args - Arguments to update one EmailLinkClick.
     * @example
     * // Update one EmailLinkClick
     * const emailLinkClick = await prisma.emailLinkClick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailLinkClickUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLinkClickUpdateArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailLinkClicks.
     * @param {EmailLinkClickDeleteManyArgs} args - Arguments to filter EmailLinkClicks to delete.
     * @example
     * // Delete a few EmailLinkClicks
     * const { count } = await prisma.emailLinkClick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailLinkClickDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailLinkClickDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLinkClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLinkClicks
     * const emailLinkClick = await prisma.emailLinkClick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailLinkClickUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLinkClickUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailLinkClick.
     * @param {EmailLinkClickUpsertArgs} args - Arguments to update or create a EmailLinkClick.
     * @example
     * // Update or create a EmailLinkClick
     * const emailLinkClick = await prisma.emailLinkClick.upsert({
     *   create: {
     *     // ... data to create a EmailLinkClick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLinkClick we want to update
     *   }
     * })
    **/
    upsert<T extends EmailLinkClickUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailLinkClickUpsertArgs<ExtArgs>>
    ): Prisma__EmailLinkClickClient<$Result.GetResult<Prisma.$EmailLinkClickPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailLinkClicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickCountArgs} args - Arguments to filter EmailLinkClicks to count.
     * @example
     * // Count the number of EmailLinkClicks
     * const count = await prisma.emailLinkClick.count({
     *   where: {
     *     // ... the filter for the EmailLinkClicks we want to count
     *   }
     * })
    **/
    count<T extends EmailLinkClickCountArgs>(
      args?: Subset<T, EmailLinkClickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLinkClickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLinkClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLinkClickAggregateArgs>(args: Subset<T, EmailLinkClickAggregateArgs>): Prisma.PrismaPromise<GetEmailLinkClickAggregateType<T>>

    /**
     * Group by EmailLinkClick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLinkClickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLinkClickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLinkClickGroupByArgs['orderBy'] }
        : { orderBy?: EmailLinkClickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLinkClickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLinkClickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLinkClick model
   */
  readonly fields: EmailLinkClickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLinkClick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLinkClickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tracking<T extends EmailTrackingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailTrackingDefaultArgs<ExtArgs>>): Prisma__EmailTrackingClient<$Result.GetResult<Prisma.$EmailTrackingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailLinkClick model
   */ 
  interface EmailLinkClickFieldRefs {
    readonly id: FieldRef<"EmailLinkClick", 'String'>
    readonly trackingId: FieldRef<"EmailLinkClick", 'String'>
    readonly originalUrl: FieldRef<"EmailLinkClick", 'String'>
    readonly clickCount: FieldRef<"EmailLinkClick", 'Int'>
    readonly ipAddress: FieldRef<"EmailLinkClick", 'String'>
    readonly userAgent: FieldRef<"EmailLinkClick", 'String'>
    readonly firstClickedAt: FieldRef<"EmailLinkClick", 'DateTime'>
    readonly lastClickedAt: FieldRef<"EmailLinkClick", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailLinkClick findUnique
   */
  export type EmailLinkClickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * Filter, which EmailLinkClick to fetch.
     */
    where: EmailLinkClickWhereUniqueInput
  }


  /**
   * EmailLinkClick findUniqueOrThrow
   */
  export type EmailLinkClickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * Filter, which EmailLinkClick to fetch.
     */
    where: EmailLinkClickWhereUniqueInput
  }


  /**
   * EmailLinkClick findFirst
   */
  export type EmailLinkClickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * Filter, which EmailLinkClick to fetch.
     */
    where?: EmailLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLinkClicks to fetch.
     */
    orderBy?: EmailLinkClickOrderByWithRelationInput | EmailLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLinkClicks.
     */
    cursor?: EmailLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLinkClicks.
     */
    distinct?: EmailLinkClickScalarFieldEnum | EmailLinkClickScalarFieldEnum[]
  }


  /**
   * EmailLinkClick findFirstOrThrow
   */
  export type EmailLinkClickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * Filter, which EmailLinkClick to fetch.
     */
    where?: EmailLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLinkClicks to fetch.
     */
    orderBy?: EmailLinkClickOrderByWithRelationInput | EmailLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLinkClicks.
     */
    cursor?: EmailLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLinkClicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLinkClicks.
     */
    distinct?: EmailLinkClickScalarFieldEnum | EmailLinkClickScalarFieldEnum[]
  }


  /**
   * EmailLinkClick findMany
   */
  export type EmailLinkClickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * Filter, which EmailLinkClicks to fetch.
     */
    where?: EmailLinkClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLinkClicks to fetch.
     */
    orderBy?: EmailLinkClickOrderByWithRelationInput | EmailLinkClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLinkClicks.
     */
    cursor?: EmailLinkClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLinkClicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLinkClicks.
     */
    skip?: number
    distinct?: EmailLinkClickScalarFieldEnum | EmailLinkClickScalarFieldEnum[]
  }


  /**
   * EmailLinkClick create
   */
  export type EmailLinkClickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailLinkClick.
     */
    data: XOR<EmailLinkClickCreateInput, EmailLinkClickUncheckedCreateInput>
  }


  /**
   * EmailLinkClick createMany
   */
  export type EmailLinkClickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLinkClicks.
     */
    data: EmailLinkClickCreateManyInput | EmailLinkClickCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailLinkClick update
   */
  export type EmailLinkClickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailLinkClick.
     */
    data: XOR<EmailLinkClickUpdateInput, EmailLinkClickUncheckedUpdateInput>
    /**
     * Choose, which EmailLinkClick to update.
     */
    where: EmailLinkClickWhereUniqueInput
  }


  /**
   * EmailLinkClick updateMany
   */
  export type EmailLinkClickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLinkClicks.
     */
    data: XOR<EmailLinkClickUpdateManyMutationInput, EmailLinkClickUncheckedUpdateManyInput>
    /**
     * Filter which EmailLinkClicks to update
     */
    where?: EmailLinkClickWhereInput
  }


  /**
   * EmailLinkClick upsert
   */
  export type EmailLinkClickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailLinkClick to update in case it exists.
     */
    where: EmailLinkClickWhereUniqueInput
    /**
     * In case the EmailLinkClick found by the `where` argument doesn't exist, create a new EmailLinkClick with this data.
     */
    create: XOR<EmailLinkClickCreateInput, EmailLinkClickUncheckedCreateInput>
    /**
     * In case the EmailLinkClick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLinkClickUpdateInput, EmailLinkClickUncheckedUpdateInput>
  }


  /**
   * EmailLinkClick delete
   */
  export type EmailLinkClickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
    /**
     * Filter which EmailLinkClick to delete.
     */
    where: EmailLinkClickWhereUniqueInput
  }


  /**
   * EmailLinkClick deleteMany
   */
  export type EmailLinkClickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLinkClicks to delete
     */
    where?: EmailLinkClickWhereInput
  }


  /**
   * EmailLinkClick without action
   */
  export type EmailLinkClickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLinkClick
     */
    select?: EmailLinkClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailLinkClickInclude<ExtArgs> | null
  }



  /**
   * Model MailMerge
   */

  export type AggregateMailMerge = {
    _count: MailMergeCountAggregateOutputType | null
    _avg: MailMergeAvgAggregateOutputType | null
    _sum: MailMergeSumAggregateOutputType | null
    _min: MailMergeMinAggregateOutputType | null
    _max: MailMergeMaxAggregateOutputType | null
  }

  export type MailMergeAvgAggregateOutputType = {
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type MailMergeSumAggregateOutputType = {
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type MailMergeMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    htmlBody: string | null
    textBody: string | null
    recipientCount: number | null
    status: $Enums.MailMergeStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    sentCount: number | null
    failedCount: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailMergeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    htmlBody: string | null
    textBody: string | null
    recipientCount: number | null
    status: $Enums.MailMergeStatus | null
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    sentCount: number | null
    failedCount: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MailMergeCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    htmlBody: number
    textBody: number
    recipientCount: number
    recipients: number
    status: number
    scheduledAt: number
    startedAt: number
    completedAt: number
    sentCount: number
    failedCount: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MailMergeAvgAggregateInputType = {
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type MailMergeSumAggregateInputType = {
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type MailMergeMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlBody?: true
    textBody?: true
    recipientCount?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    sentCount?: true
    failedCount?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailMergeMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlBody?: true
    textBody?: true
    recipientCount?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    sentCount?: true
    failedCount?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MailMergeCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    htmlBody?: true
    textBody?: true
    recipientCount?: true
    recipients?: true
    status?: true
    scheduledAt?: true
    startedAt?: true
    completedAt?: true
    sentCount?: true
    failedCount?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MailMergeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailMerge to aggregate.
     */
    where?: MailMergeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailMerges to fetch.
     */
    orderBy?: MailMergeOrderByWithRelationInput | MailMergeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailMergeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailMerges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailMerges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MailMerges
    **/
    _count?: true | MailMergeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MailMergeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MailMergeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailMergeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailMergeMaxAggregateInputType
  }

  export type GetMailMergeAggregateType<T extends MailMergeAggregateArgs> = {
        [P in keyof T & keyof AggregateMailMerge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailMerge[P]>
      : GetScalarType<T[P], AggregateMailMerge[P]>
  }




  export type MailMergeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailMergeWhereInput
    orderBy?: MailMergeOrderByWithAggregationInput | MailMergeOrderByWithAggregationInput[]
    by: MailMergeScalarFieldEnum[] | MailMergeScalarFieldEnum
    having?: MailMergeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailMergeCountAggregateInputType | true
    _avg?: MailMergeAvgAggregateInputType
    _sum?: MailMergeSumAggregateInputType
    _min?: MailMergeMinAggregateInputType
    _max?: MailMergeMaxAggregateInputType
  }

  export type MailMergeGroupByOutputType = {
    id: string
    name: string
    subject: string
    htmlBody: string | null
    textBody: string | null
    recipientCount: number
    recipients: JsonValue
    status: $Enums.MailMergeStatus
    scheduledAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    sentCount: number
    failedCount: number
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MailMergeCountAggregateOutputType | null
    _avg: MailMergeAvgAggregateOutputType | null
    _sum: MailMergeSumAggregateOutputType | null
    _min: MailMergeMinAggregateOutputType | null
    _max: MailMergeMaxAggregateOutputType | null
  }

  type GetMailMergeGroupByPayload<T extends MailMergeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailMergeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailMergeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailMergeGroupByOutputType[P]>
            : GetScalarType<T[P], MailMergeGroupByOutputType[P]>
        }
      >
    >


  export type MailMergeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlBody?: boolean
    textBody?: boolean
    recipientCount?: boolean
    recipients?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    sentCount?: boolean
    failedCount?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mailMerge"]>

  export type MailMergeSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    htmlBody?: boolean
    textBody?: boolean
    recipientCount?: boolean
    recipients?: boolean
    status?: boolean
    scheduledAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    sentCount?: boolean
    failedCount?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MailMergePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MailMerge"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      htmlBody: string | null
      textBody: string | null
      recipientCount: number
      recipients: Prisma.JsonValue
      status: $Enums.MailMergeStatus
      scheduledAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      sentCount: number
      failedCount: number
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mailMerge"]>
    composites: {}
  }


  type MailMergeGetPayload<S extends boolean | null | undefined | MailMergeDefaultArgs> = $Result.GetResult<Prisma.$MailMergePayload, S>

  type MailMergeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MailMergeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MailMergeCountAggregateInputType | true
    }

  export interface MailMergeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MailMerge'], meta: { name: 'MailMerge' } }
    /**
     * Find zero or one MailMerge that matches the filter.
     * @param {MailMergeFindUniqueArgs} args - Arguments to find a MailMerge
     * @example
     * // Get one MailMerge
     * const mailMerge = await prisma.mailMerge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MailMergeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MailMergeFindUniqueArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MailMerge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MailMergeFindUniqueOrThrowArgs} args - Arguments to find a MailMerge
     * @example
     * // Get one MailMerge
     * const mailMerge = await prisma.mailMerge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MailMergeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MailMergeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MailMerge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeFindFirstArgs} args - Arguments to find a MailMerge
     * @example
     * // Get one MailMerge
     * const mailMerge = await prisma.mailMerge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MailMergeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MailMergeFindFirstArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MailMerge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeFindFirstOrThrowArgs} args - Arguments to find a MailMerge
     * @example
     * // Get one MailMerge
     * const mailMerge = await prisma.mailMerge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MailMergeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MailMergeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MailMerges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MailMerges
     * const mailMerges = await prisma.mailMerge.findMany()
     * 
     * // Get first 10 MailMerges
     * const mailMerges = await prisma.mailMerge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailMergeWithIdOnly = await prisma.mailMerge.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MailMergeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailMergeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MailMerge.
     * @param {MailMergeCreateArgs} args - Arguments to create a MailMerge.
     * @example
     * // Create one MailMerge
     * const MailMerge = await prisma.mailMerge.create({
     *   data: {
     *     // ... data to create a MailMerge
     *   }
     * })
     * 
    **/
    create<T extends MailMergeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MailMergeCreateArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MailMerges.
     *     @param {MailMergeCreateManyArgs} args - Arguments to create many MailMerges.
     *     @example
     *     // Create many MailMerges
     *     const mailMerge = await prisma.mailMerge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MailMergeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailMergeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MailMerge.
     * @param {MailMergeDeleteArgs} args - Arguments to delete one MailMerge.
     * @example
     * // Delete one MailMerge
     * const MailMerge = await prisma.mailMerge.delete({
     *   where: {
     *     // ... filter to delete one MailMerge
     *   }
     * })
     * 
    **/
    delete<T extends MailMergeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MailMergeDeleteArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MailMerge.
     * @param {MailMergeUpdateArgs} args - Arguments to update one MailMerge.
     * @example
     * // Update one MailMerge
     * const mailMerge = await prisma.mailMerge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MailMergeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MailMergeUpdateArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MailMerges.
     * @param {MailMergeDeleteManyArgs} args - Arguments to filter MailMerges to delete.
     * @example
     * // Delete a few MailMerges
     * const { count } = await prisma.mailMerge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MailMergeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailMergeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailMerges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MailMerges
     * const mailMerge = await prisma.mailMerge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MailMergeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MailMergeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MailMerge.
     * @param {MailMergeUpsertArgs} args - Arguments to update or create a MailMerge.
     * @example
     * // Update or create a MailMerge
     * const mailMerge = await prisma.mailMerge.upsert({
     *   create: {
     *     // ... data to create a MailMerge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MailMerge we want to update
     *   }
     * })
    **/
    upsert<T extends MailMergeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MailMergeUpsertArgs<ExtArgs>>
    ): Prisma__MailMergeClient<$Result.GetResult<Prisma.$MailMergePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MailMerges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeCountArgs} args - Arguments to filter MailMerges to count.
     * @example
     * // Count the number of MailMerges
     * const count = await prisma.mailMerge.count({
     *   where: {
     *     // ... the filter for the MailMerges we want to count
     *   }
     * })
    **/
    count<T extends MailMergeCountArgs>(
      args?: Subset<T, MailMergeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailMergeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MailMerge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailMergeAggregateArgs>(args: Subset<T, MailMergeAggregateArgs>): Prisma.PrismaPromise<GetMailMergeAggregateType<T>>

    /**
     * Group by MailMerge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailMergeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailMergeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailMergeGroupByArgs['orderBy'] }
        : { orderBy?: MailMergeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailMergeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailMergeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MailMerge model
   */
  readonly fields: MailMergeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MailMerge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailMergeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MailMerge model
   */ 
  interface MailMergeFieldRefs {
    readonly id: FieldRef<"MailMerge", 'String'>
    readonly name: FieldRef<"MailMerge", 'String'>
    readonly subject: FieldRef<"MailMerge", 'String'>
    readonly htmlBody: FieldRef<"MailMerge", 'String'>
    readonly textBody: FieldRef<"MailMerge", 'String'>
    readonly recipientCount: FieldRef<"MailMerge", 'Int'>
    readonly recipients: FieldRef<"MailMerge", 'Json'>
    readonly status: FieldRef<"MailMerge", 'MailMergeStatus'>
    readonly scheduledAt: FieldRef<"MailMerge", 'DateTime'>
    readonly startedAt: FieldRef<"MailMerge", 'DateTime'>
    readonly completedAt: FieldRef<"MailMerge", 'DateTime'>
    readonly sentCount: FieldRef<"MailMerge", 'Int'>
    readonly failedCount: FieldRef<"MailMerge", 'Int'>
    readonly userId: FieldRef<"MailMerge", 'String'>
    readonly createdAt: FieldRef<"MailMerge", 'DateTime'>
    readonly updatedAt: FieldRef<"MailMerge", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MailMerge findUnique
   */
  export type MailMergeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * Filter, which MailMerge to fetch.
     */
    where: MailMergeWhereUniqueInput
  }


  /**
   * MailMerge findUniqueOrThrow
   */
  export type MailMergeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * Filter, which MailMerge to fetch.
     */
    where: MailMergeWhereUniqueInput
  }


  /**
   * MailMerge findFirst
   */
  export type MailMergeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * Filter, which MailMerge to fetch.
     */
    where?: MailMergeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailMerges to fetch.
     */
    orderBy?: MailMergeOrderByWithRelationInput | MailMergeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailMerges.
     */
    cursor?: MailMergeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailMerges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailMerges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailMerges.
     */
    distinct?: MailMergeScalarFieldEnum | MailMergeScalarFieldEnum[]
  }


  /**
   * MailMerge findFirstOrThrow
   */
  export type MailMergeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * Filter, which MailMerge to fetch.
     */
    where?: MailMergeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailMerges to fetch.
     */
    orderBy?: MailMergeOrderByWithRelationInput | MailMergeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailMerges.
     */
    cursor?: MailMergeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailMerges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailMerges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailMerges.
     */
    distinct?: MailMergeScalarFieldEnum | MailMergeScalarFieldEnum[]
  }


  /**
   * MailMerge findMany
   */
  export type MailMergeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * Filter, which MailMerges to fetch.
     */
    where?: MailMergeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailMerges to fetch.
     */
    orderBy?: MailMergeOrderByWithRelationInput | MailMergeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MailMerges.
     */
    cursor?: MailMergeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailMerges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailMerges.
     */
    skip?: number
    distinct?: MailMergeScalarFieldEnum | MailMergeScalarFieldEnum[]
  }


  /**
   * MailMerge create
   */
  export type MailMergeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * The data needed to create a MailMerge.
     */
    data: XOR<MailMergeCreateInput, MailMergeUncheckedCreateInput>
  }


  /**
   * MailMerge createMany
   */
  export type MailMergeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MailMerges.
     */
    data: MailMergeCreateManyInput | MailMergeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MailMerge update
   */
  export type MailMergeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * The data needed to update a MailMerge.
     */
    data: XOR<MailMergeUpdateInput, MailMergeUncheckedUpdateInput>
    /**
     * Choose, which MailMerge to update.
     */
    where: MailMergeWhereUniqueInput
  }


  /**
   * MailMerge updateMany
   */
  export type MailMergeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MailMerges.
     */
    data: XOR<MailMergeUpdateManyMutationInput, MailMergeUncheckedUpdateManyInput>
    /**
     * Filter which MailMerges to update
     */
    where?: MailMergeWhereInput
  }


  /**
   * MailMerge upsert
   */
  export type MailMergeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * The filter to search for the MailMerge to update in case it exists.
     */
    where: MailMergeWhereUniqueInput
    /**
     * In case the MailMerge found by the `where` argument doesn't exist, create a new MailMerge with this data.
     */
    create: XOR<MailMergeCreateInput, MailMergeUncheckedCreateInput>
    /**
     * In case the MailMerge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailMergeUpdateInput, MailMergeUncheckedUpdateInput>
  }


  /**
   * MailMerge delete
   */
  export type MailMergeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
    /**
     * Filter which MailMerge to delete.
     */
    where: MailMergeWhereUniqueInput
  }


  /**
   * MailMerge deleteMany
   */
  export type MailMergeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailMerges to delete
     */
    where?: MailMergeWhereInput
  }


  /**
   * MailMerge without action
   */
  export type MailMergeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailMerge
     */
    select?: MailMergeSelect<ExtArgs> | null
  }



  /**
   * Model EmailHostingSettings
   */

  export type AggregateEmailHostingSettings = {
    _count: EmailHostingSettingsCountAggregateOutputType | null
    _avg: EmailHostingSettingsAvgAggregateOutputType | null
    _sum: EmailHostingSettingsSumAggregateOutputType | null
    _min: EmailHostingSettingsMinAggregateOutputType | null
    _max: EmailHostingSettingsMaxAggregateOutputType | null
  }

  export type EmailHostingSettingsAvgAggregateOutputType = {
    defaultQuotaMb: number | null
    defaultMaxSendPerDay: number | null
    minPasswordLength: number | null
  }

  export type EmailHostingSettingsSumAggregateOutputType = {
    defaultQuotaMb: number | null
    defaultMaxSendPerDay: number | null
    minPasswordLength: number | null
  }

  export type EmailHostingSettingsMinAggregateOutputType = {
    id: string | null
    defaultDomainId: string | null
    emailFormat: string | null
    autoProvisionEnabled: boolean | null
    defaultQuotaMb: number | null
    defaultMaxSendPerDay: number | null
    notifyOnProvision: boolean | null
    welcomeEmailTemplate: string | null
    requireStrongPassword: boolean | null
    minPasswordLength: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailHostingSettingsMaxAggregateOutputType = {
    id: string | null
    defaultDomainId: string | null
    emailFormat: string | null
    autoProvisionEnabled: boolean | null
    defaultQuotaMb: number | null
    defaultMaxSendPerDay: number | null
    notifyOnProvision: boolean | null
    welcomeEmailTemplate: string | null
    requireStrongPassword: boolean | null
    minPasswordLength: number | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailHostingSettingsCountAggregateOutputType = {
    id: number
    defaultDomainId: number
    emailFormat: number
    autoProvisionEnabled: number
    defaultQuotaMb: number
    defaultMaxSendPerDay: number
    notifyOnProvision: number
    welcomeEmailTemplate: number
    requireStrongPassword: number
    minPasswordLength: number
    companyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailHostingSettingsAvgAggregateInputType = {
    defaultQuotaMb?: true
    defaultMaxSendPerDay?: true
    minPasswordLength?: true
  }

  export type EmailHostingSettingsSumAggregateInputType = {
    defaultQuotaMb?: true
    defaultMaxSendPerDay?: true
    minPasswordLength?: true
  }

  export type EmailHostingSettingsMinAggregateInputType = {
    id?: true
    defaultDomainId?: true
    emailFormat?: true
    autoProvisionEnabled?: true
    defaultQuotaMb?: true
    defaultMaxSendPerDay?: true
    notifyOnProvision?: true
    welcomeEmailTemplate?: true
    requireStrongPassword?: true
    minPasswordLength?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailHostingSettingsMaxAggregateInputType = {
    id?: true
    defaultDomainId?: true
    emailFormat?: true
    autoProvisionEnabled?: true
    defaultQuotaMb?: true
    defaultMaxSendPerDay?: true
    notifyOnProvision?: true
    welcomeEmailTemplate?: true
    requireStrongPassword?: true
    minPasswordLength?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailHostingSettingsCountAggregateInputType = {
    id?: true
    defaultDomainId?: true
    emailFormat?: true
    autoProvisionEnabled?: true
    defaultQuotaMb?: true
    defaultMaxSendPerDay?: true
    notifyOnProvision?: true
    welcomeEmailTemplate?: true
    requireStrongPassword?: true
    minPasswordLength?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailHostingSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailHostingSettings to aggregate.
     */
    where?: EmailHostingSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailHostingSettings to fetch.
     */
    orderBy?: EmailHostingSettingsOrderByWithRelationInput | EmailHostingSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailHostingSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailHostingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailHostingSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailHostingSettings
    **/
    _count?: true | EmailHostingSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailHostingSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailHostingSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailHostingSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailHostingSettingsMaxAggregateInputType
  }

  export type GetEmailHostingSettingsAggregateType<T extends EmailHostingSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailHostingSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailHostingSettings[P]>
      : GetScalarType<T[P], AggregateEmailHostingSettings[P]>
  }




  export type EmailHostingSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailHostingSettingsWhereInput
    orderBy?: EmailHostingSettingsOrderByWithAggregationInput | EmailHostingSettingsOrderByWithAggregationInput[]
    by: EmailHostingSettingsScalarFieldEnum[] | EmailHostingSettingsScalarFieldEnum
    having?: EmailHostingSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailHostingSettingsCountAggregateInputType | true
    _avg?: EmailHostingSettingsAvgAggregateInputType
    _sum?: EmailHostingSettingsSumAggregateInputType
    _min?: EmailHostingSettingsMinAggregateInputType
    _max?: EmailHostingSettingsMaxAggregateInputType
  }

  export type EmailHostingSettingsGroupByOutputType = {
    id: string
    defaultDomainId: string | null
    emailFormat: string
    autoProvisionEnabled: boolean
    defaultQuotaMb: number
    defaultMaxSendPerDay: number
    notifyOnProvision: boolean
    welcomeEmailTemplate: string | null
    requireStrongPassword: boolean
    minPasswordLength: number
    companyId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailHostingSettingsCountAggregateOutputType | null
    _avg: EmailHostingSettingsAvgAggregateOutputType | null
    _sum: EmailHostingSettingsSumAggregateOutputType | null
    _min: EmailHostingSettingsMinAggregateOutputType | null
    _max: EmailHostingSettingsMaxAggregateOutputType | null
  }

  type GetEmailHostingSettingsGroupByPayload<T extends EmailHostingSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailHostingSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailHostingSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailHostingSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], EmailHostingSettingsGroupByOutputType[P]>
        }
      >
    >


  export type EmailHostingSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    defaultDomainId?: boolean
    emailFormat?: boolean
    autoProvisionEnabled?: boolean
    defaultQuotaMb?: boolean
    defaultMaxSendPerDay?: boolean
    notifyOnProvision?: boolean
    welcomeEmailTemplate?: boolean
    requireStrongPassword?: boolean
    minPasswordLength?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailHostingSettings"]>

  export type EmailHostingSettingsSelectScalar = {
    id?: boolean
    defaultDomainId?: boolean
    emailFormat?: boolean
    autoProvisionEnabled?: boolean
    defaultQuotaMb?: boolean
    defaultMaxSendPerDay?: boolean
    notifyOnProvision?: boolean
    welcomeEmailTemplate?: boolean
    requireStrongPassword?: boolean
    minPasswordLength?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $EmailHostingSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailHostingSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      defaultDomainId: string | null
      emailFormat: string
      autoProvisionEnabled: boolean
      defaultQuotaMb: number
      defaultMaxSendPerDay: number
      notifyOnProvision: boolean
      welcomeEmailTemplate: string | null
      requireStrongPassword: boolean
      minPasswordLength: number
      companyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailHostingSettings"]>
    composites: {}
  }


  type EmailHostingSettingsGetPayload<S extends boolean | null | undefined | EmailHostingSettingsDefaultArgs> = $Result.GetResult<Prisma.$EmailHostingSettingsPayload, S>

  type EmailHostingSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailHostingSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailHostingSettingsCountAggregateInputType | true
    }

  export interface EmailHostingSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailHostingSettings'], meta: { name: 'EmailHostingSettings' } }
    /**
     * Find zero or one EmailHostingSettings that matches the filter.
     * @param {EmailHostingSettingsFindUniqueArgs} args - Arguments to find a EmailHostingSettings
     * @example
     * // Get one EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailHostingSettingsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailHostingSettingsFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailHostingSettings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailHostingSettingsFindUniqueOrThrowArgs} args - Arguments to find a EmailHostingSettings
     * @example
     * // Get one EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailHostingSettingsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailHostingSettingsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailHostingSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsFindFirstArgs} args - Arguments to find a EmailHostingSettings
     * @example
     * // Get one EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailHostingSettingsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailHostingSettingsFindFirstArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailHostingSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsFindFirstOrThrowArgs} args - Arguments to find a EmailHostingSettings
     * @example
     * // Get one EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailHostingSettingsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailHostingSettingsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailHostingSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.findMany()
     * 
     * // Get first 10 EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailHostingSettingsWithIdOnly = await prisma.emailHostingSettings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailHostingSettingsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailHostingSettingsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailHostingSettings.
     * @param {EmailHostingSettingsCreateArgs} args - Arguments to create a EmailHostingSettings.
     * @example
     * // Create one EmailHostingSettings
     * const EmailHostingSettings = await prisma.emailHostingSettings.create({
     *   data: {
     *     // ... data to create a EmailHostingSettings
     *   }
     * })
     * 
    **/
    create<T extends EmailHostingSettingsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailHostingSettingsCreateArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailHostingSettings.
     *     @param {EmailHostingSettingsCreateManyArgs} args - Arguments to create many EmailHostingSettings.
     *     @example
     *     // Create many EmailHostingSettings
     *     const emailHostingSettings = await prisma.emailHostingSettings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailHostingSettingsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailHostingSettingsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailHostingSettings.
     * @param {EmailHostingSettingsDeleteArgs} args - Arguments to delete one EmailHostingSettings.
     * @example
     * // Delete one EmailHostingSettings
     * const EmailHostingSettings = await prisma.emailHostingSettings.delete({
     *   where: {
     *     // ... filter to delete one EmailHostingSettings
     *   }
     * })
     * 
    **/
    delete<T extends EmailHostingSettingsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailHostingSettingsDeleteArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailHostingSettings.
     * @param {EmailHostingSettingsUpdateArgs} args - Arguments to update one EmailHostingSettings.
     * @example
     * // Update one EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailHostingSettingsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailHostingSettingsUpdateArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailHostingSettings.
     * @param {EmailHostingSettingsDeleteManyArgs} args - Arguments to filter EmailHostingSettings to delete.
     * @example
     * // Delete a few EmailHostingSettings
     * const { count } = await prisma.emailHostingSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailHostingSettingsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailHostingSettingsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailHostingSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailHostingSettingsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailHostingSettingsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailHostingSettings.
     * @param {EmailHostingSettingsUpsertArgs} args - Arguments to update or create a EmailHostingSettings.
     * @example
     * // Update or create a EmailHostingSettings
     * const emailHostingSettings = await prisma.emailHostingSettings.upsert({
     *   create: {
     *     // ... data to create a EmailHostingSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailHostingSettings we want to update
     *   }
     * })
    **/
    upsert<T extends EmailHostingSettingsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailHostingSettingsUpsertArgs<ExtArgs>>
    ): Prisma__EmailHostingSettingsClient<$Result.GetResult<Prisma.$EmailHostingSettingsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EmailHostingSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsCountArgs} args - Arguments to filter EmailHostingSettings to count.
     * @example
     * // Count the number of EmailHostingSettings
     * const count = await prisma.emailHostingSettings.count({
     *   where: {
     *     // ... the filter for the EmailHostingSettings we want to count
     *   }
     * })
    **/
    count<T extends EmailHostingSettingsCountArgs>(
      args?: Subset<T, EmailHostingSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailHostingSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailHostingSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailHostingSettingsAggregateArgs>(args: Subset<T, EmailHostingSettingsAggregateArgs>): Prisma.PrismaPromise<GetEmailHostingSettingsAggregateType<T>>

    /**
     * Group by EmailHostingSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailHostingSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailHostingSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailHostingSettingsGroupByArgs['orderBy'] }
        : { orderBy?: EmailHostingSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailHostingSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailHostingSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailHostingSettings model
   */
  readonly fields: EmailHostingSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailHostingSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailHostingSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailHostingSettings model
   */ 
  interface EmailHostingSettingsFieldRefs {
    readonly id: FieldRef<"EmailHostingSettings", 'String'>
    readonly defaultDomainId: FieldRef<"EmailHostingSettings", 'String'>
    readonly emailFormat: FieldRef<"EmailHostingSettings", 'String'>
    readonly autoProvisionEnabled: FieldRef<"EmailHostingSettings", 'Boolean'>
    readonly defaultQuotaMb: FieldRef<"EmailHostingSettings", 'Int'>
    readonly defaultMaxSendPerDay: FieldRef<"EmailHostingSettings", 'Int'>
    readonly notifyOnProvision: FieldRef<"EmailHostingSettings", 'Boolean'>
    readonly welcomeEmailTemplate: FieldRef<"EmailHostingSettings", 'String'>
    readonly requireStrongPassword: FieldRef<"EmailHostingSettings", 'Boolean'>
    readonly minPasswordLength: FieldRef<"EmailHostingSettings", 'Int'>
    readonly companyId: FieldRef<"EmailHostingSettings", 'String'>
    readonly createdAt: FieldRef<"EmailHostingSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailHostingSettings", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * EmailHostingSettings findUnique
   */
  export type EmailHostingSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * Filter, which EmailHostingSettings to fetch.
     */
    where: EmailHostingSettingsWhereUniqueInput
  }


  /**
   * EmailHostingSettings findUniqueOrThrow
   */
  export type EmailHostingSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * Filter, which EmailHostingSettings to fetch.
     */
    where: EmailHostingSettingsWhereUniqueInput
  }


  /**
   * EmailHostingSettings findFirst
   */
  export type EmailHostingSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * Filter, which EmailHostingSettings to fetch.
     */
    where?: EmailHostingSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailHostingSettings to fetch.
     */
    orderBy?: EmailHostingSettingsOrderByWithRelationInput | EmailHostingSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailHostingSettings.
     */
    cursor?: EmailHostingSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailHostingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailHostingSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailHostingSettings.
     */
    distinct?: EmailHostingSettingsScalarFieldEnum | EmailHostingSettingsScalarFieldEnum[]
  }


  /**
   * EmailHostingSettings findFirstOrThrow
   */
  export type EmailHostingSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * Filter, which EmailHostingSettings to fetch.
     */
    where?: EmailHostingSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailHostingSettings to fetch.
     */
    orderBy?: EmailHostingSettingsOrderByWithRelationInput | EmailHostingSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailHostingSettings.
     */
    cursor?: EmailHostingSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailHostingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailHostingSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailHostingSettings.
     */
    distinct?: EmailHostingSettingsScalarFieldEnum | EmailHostingSettingsScalarFieldEnum[]
  }


  /**
   * EmailHostingSettings findMany
   */
  export type EmailHostingSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * Filter, which EmailHostingSettings to fetch.
     */
    where?: EmailHostingSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailHostingSettings to fetch.
     */
    orderBy?: EmailHostingSettingsOrderByWithRelationInput | EmailHostingSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailHostingSettings.
     */
    cursor?: EmailHostingSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailHostingSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailHostingSettings.
     */
    skip?: number
    distinct?: EmailHostingSettingsScalarFieldEnum | EmailHostingSettingsScalarFieldEnum[]
  }


  /**
   * EmailHostingSettings create
   */
  export type EmailHostingSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a EmailHostingSettings.
     */
    data: XOR<EmailHostingSettingsCreateInput, EmailHostingSettingsUncheckedCreateInput>
  }


  /**
   * EmailHostingSettings createMany
   */
  export type EmailHostingSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailHostingSettings.
     */
    data: EmailHostingSettingsCreateManyInput | EmailHostingSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EmailHostingSettings update
   */
  export type EmailHostingSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a EmailHostingSettings.
     */
    data: XOR<EmailHostingSettingsUpdateInput, EmailHostingSettingsUncheckedUpdateInput>
    /**
     * Choose, which EmailHostingSettings to update.
     */
    where: EmailHostingSettingsWhereUniqueInput
  }


  /**
   * EmailHostingSettings updateMany
   */
  export type EmailHostingSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailHostingSettings.
     */
    data: XOR<EmailHostingSettingsUpdateManyMutationInput, EmailHostingSettingsUncheckedUpdateManyInput>
    /**
     * Filter which EmailHostingSettings to update
     */
    where?: EmailHostingSettingsWhereInput
  }


  /**
   * EmailHostingSettings upsert
   */
  export type EmailHostingSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the EmailHostingSettings to update in case it exists.
     */
    where: EmailHostingSettingsWhereUniqueInput
    /**
     * In case the EmailHostingSettings found by the `where` argument doesn't exist, create a new EmailHostingSettings with this data.
     */
    create: XOR<EmailHostingSettingsCreateInput, EmailHostingSettingsUncheckedCreateInput>
    /**
     * In case the EmailHostingSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailHostingSettingsUpdateInput, EmailHostingSettingsUncheckedUpdateInput>
  }


  /**
   * EmailHostingSettings delete
   */
  export type EmailHostingSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
    /**
     * Filter which EmailHostingSettings to delete.
     */
    where: EmailHostingSettingsWhereUniqueInput
  }


  /**
   * EmailHostingSettings deleteMany
   */
  export type EmailHostingSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailHostingSettings to delete
     */
    where?: EmailHostingSettingsWhereInput
  }


  /**
   * EmailHostingSettings without action
   */
  export type EmailHostingSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailHostingSettings
     */
    select?: EmailHostingSettingsSelect<ExtArgs> | null
  }



  /**
   * Model MailboxAuditLog
   */

  export type AggregateMailboxAuditLog = {
    _count: MailboxAuditLogCountAggregateOutputType | null
    _min: MailboxAuditLogMinAggregateOutputType | null
    _max: MailboxAuditLogMaxAggregateOutputType | null
  }

  export type MailboxAuditLogMinAggregateOutputType = {
    id: string | null
    action: $Enums.MailboxAuditAction | null
    mailboxId: string | null
    userId: string | null
    domainId: string | null
    performedById: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    companyId: string | null
    createdAt: Date | null
  }

  export type MailboxAuditLogMaxAggregateOutputType = {
    id: string | null
    action: $Enums.MailboxAuditAction | null
    mailboxId: string | null
    userId: string | null
    domainId: string | null
    performedById: string | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean | null
    errorMessage: string | null
    companyId: string | null
    createdAt: Date | null
  }

  export type MailboxAuditLogCountAggregateOutputType = {
    id: number
    action: number
    mailboxId: number
    userId: number
    domainId: number
    performedById: number
    details: number
    ipAddress: number
    userAgent: number
    success: number
    errorMessage: number
    companyId: number
    createdAt: number
    _all: number
  }


  export type MailboxAuditLogMinAggregateInputType = {
    id?: true
    action?: true
    mailboxId?: true
    userId?: true
    domainId?: true
    performedById?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    companyId?: true
    createdAt?: true
  }

  export type MailboxAuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    mailboxId?: true
    userId?: true
    domainId?: true
    performedById?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    companyId?: true
    createdAt?: true
  }

  export type MailboxAuditLogCountAggregateInputType = {
    id?: true
    action?: true
    mailboxId?: true
    userId?: true
    domainId?: true
    performedById?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    success?: true
    errorMessage?: true
    companyId?: true
    createdAt?: true
    _all?: true
  }

  export type MailboxAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailboxAuditLog to aggregate.
     */
    where?: MailboxAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailboxAuditLogs to fetch.
     */
    orderBy?: MailboxAuditLogOrderByWithRelationInput | MailboxAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MailboxAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailboxAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailboxAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MailboxAuditLogs
    **/
    _count?: true | MailboxAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MailboxAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MailboxAuditLogMaxAggregateInputType
  }

  export type GetMailboxAuditLogAggregateType<T extends MailboxAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMailboxAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMailboxAuditLog[P]>
      : GetScalarType<T[P], AggregateMailboxAuditLog[P]>
  }




  export type MailboxAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MailboxAuditLogWhereInput
    orderBy?: MailboxAuditLogOrderByWithAggregationInput | MailboxAuditLogOrderByWithAggregationInput[]
    by: MailboxAuditLogScalarFieldEnum[] | MailboxAuditLogScalarFieldEnum
    having?: MailboxAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MailboxAuditLogCountAggregateInputType | true
    _min?: MailboxAuditLogMinAggregateInputType
    _max?: MailboxAuditLogMaxAggregateInputType
  }

  export type MailboxAuditLogGroupByOutputType = {
    id: string
    action: $Enums.MailboxAuditAction
    mailboxId: string | null
    userId: string | null
    domainId: string | null
    performedById: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    success: boolean
    errorMessage: string | null
    companyId: string
    createdAt: Date
    _count: MailboxAuditLogCountAggregateOutputType | null
    _min: MailboxAuditLogMinAggregateOutputType | null
    _max: MailboxAuditLogMaxAggregateOutputType | null
  }

  type GetMailboxAuditLogGroupByPayload<T extends MailboxAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MailboxAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MailboxAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MailboxAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], MailboxAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type MailboxAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    mailboxId?: boolean
    userId?: boolean
    domainId?: boolean
    performedById?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    companyId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mailboxAuditLog"]>

  export type MailboxAuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    mailboxId?: boolean
    userId?: boolean
    domainId?: boolean
    performedById?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    success?: boolean
    errorMessage?: boolean
    companyId?: boolean
    createdAt?: boolean
  }


  export type $MailboxAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MailboxAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.MailboxAuditAction
      mailboxId: string | null
      userId: string | null
      domainId: string | null
      performedById: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      success: boolean
      errorMessage: string | null
      companyId: string
      createdAt: Date
    }, ExtArgs["result"]["mailboxAuditLog"]>
    composites: {}
  }


  type MailboxAuditLogGetPayload<S extends boolean | null | undefined | MailboxAuditLogDefaultArgs> = $Result.GetResult<Prisma.$MailboxAuditLogPayload, S>

  type MailboxAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MailboxAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MailboxAuditLogCountAggregateInputType | true
    }

  export interface MailboxAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MailboxAuditLog'], meta: { name: 'MailboxAuditLog' } }
    /**
     * Find zero or one MailboxAuditLog that matches the filter.
     * @param {MailboxAuditLogFindUniqueArgs} args - Arguments to find a MailboxAuditLog
     * @example
     * // Get one MailboxAuditLog
     * const mailboxAuditLog = await prisma.mailboxAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MailboxAuditLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxAuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MailboxAuditLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MailboxAuditLogFindUniqueOrThrowArgs} args - Arguments to find a MailboxAuditLog
     * @example
     * // Get one MailboxAuditLog
     * const mailboxAuditLog = await prisma.mailboxAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MailboxAuditLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxAuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MailboxAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogFindFirstArgs} args - Arguments to find a MailboxAuditLog
     * @example
     * // Get one MailboxAuditLog
     * const mailboxAuditLog = await prisma.mailboxAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MailboxAuditLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxAuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MailboxAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogFindFirstOrThrowArgs} args - Arguments to find a MailboxAuditLog
     * @example
     * // Get one MailboxAuditLog
     * const mailboxAuditLog = await prisma.mailboxAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MailboxAuditLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxAuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MailboxAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MailboxAuditLogs
     * const mailboxAuditLogs = await prisma.mailboxAuditLog.findMany()
     * 
     * // Get first 10 MailboxAuditLogs
     * const mailboxAuditLogs = await prisma.mailboxAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mailboxAuditLogWithIdOnly = await prisma.mailboxAuditLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MailboxAuditLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxAuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MailboxAuditLog.
     * @param {MailboxAuditLogCreateArgs} args - Arguments to create a MailboxAuditLog.
     * @example
     * // Create one MailboxAuditLog
     * const MailboxAuditLog = await prisma.mailboxAuditLog.create({
     *   data: {
     *     // ... data to create a MailboxAuditLog
     *   }
     * })
     * 
    **/
    create<T extends MailboxAuditLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxAuditLogCreateArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MailboxAuditLogs.
     *     @param {MailboxAuditLogCreateManyArgs} args - Arguments to create many MailboxAuditLogs.
     *     @example
     *     // Create many MailboxAuditLogs
     *     const mailboxAuditLog = await prisma.mailboxAuditLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MailboxAuditLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxAuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MailboxAuditLog.
     * @param {MailboxAuditLogDeleteArgs} args - Arguments to delete one MailboxAuditLog.
     * @example
     * // Delete one MailboxAuditLog
     * const MailboxAuditLog = await prisma.mailboxAuditLog.delete({
     *   where: {
     *     // ... filter to delete one MailboxAuditLog
     *   }
     * })
     * 
    **/
    delete<T extends MailboxAuditLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxAuditLogDeleteArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MailboxAuditLog.
     * @param {MailboxAuditLogUpdateArgs} args - Arguments to update one MailboxAuditLog.
     * @example
     * // Update one MailboxAuditLog
     * const mailboxAuditLog = await prisma.mailboxAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MailboxAuditLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxAuditLogUpdateArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MailboxAuditLogs.
     * @param {MailboxAuditLogDeleteManyArgs} args - Arguments to filter MailboxAuditLogs to delete.
     * @example
     * // Delete a few MailboxAuditLogs
     * const { count } = await prisma.mailboxAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MailboxAuditLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MailboxAuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MailboxAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MailboxAuditLogs
     * const mailboxAuditLog = await prisma.mailboxAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MailboxAuditLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxAuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MailboxAuditLog.
     * @param {MailboxAuditLogUpsertArgs} args - Arguments to update or create a MailboxAuditLog.
     * @example
     * // Update or create a MailboxAuditLog
     * const mailboxAuditLog = await prisma.mailboxAuditLog.upsert({
     *   create: {
     *     // ... data to create a MailboxAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MailboxAuditLog we want to update
     *   }
     * })
    **/
    upsert<T extends MailboxAuditLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MailboxAuditLogUpsertArgs<ExtArgs>>
    ): Prisma__MailboxAuditLogClient<$Result.GetResult<Prisma.$MailboxAuditLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MailboxAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogCountArgs} args - Arguments to filter MailboxAuditLogs to count.
     * @example
     * // Count the number of MailboxAuditLogs
     * const count = await prisma.mailboxAuditLog.count({
     *   where: {
     *     // ... the filter for the MailboxAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends MailboxAuditLogCountArgs>(
      args?: Subset<T, MailboxAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MailboxAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MailboxAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MailboxAuditLogAggregateArgs>(args: Subset<T, MailboxAuditLogAggregateArgs>): Prisma.PrismaPromise<GetMailboxAuditLogAggregateType<T>>

    /**
     * Group by MailboxAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MailboxAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MailboxAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MailboxAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: MailboxAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MailboxAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMailboxAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MailboxAuditLog model
   */
  readonly fields: MailboxAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MailboxAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MailboxAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MailboxAuditLog model
   */ 
  interface MailboxAuditLogFieldRefs {
    readonly id: FieldRef<"MailboxAuditLog", 'String'>
    readonly action: FieldRef<"MailboxAuditLog", 'MailboxAuditAction'>
    readonly mailboxId: FieldRef<"MailboxAuditLog", 'String'>
    readonly userId: FieldRef<"MailboxAuditLog", 'String'>
    readonly domainId: FieldRef<"MailboxAuditLog", 'String'>
    readonly performedById: FieldRef<"MailboxAuditLog", 'String'>
    readonly details: FieldRef<"MailboxAuditLog", 'Json'>
    readonly ipAddress: FieldRef<"MailboxAuditLog", 'String'>
    readonly userAgent: FieldRef<"MailboxAuditLog", 'String'>
    readonly success: FieldRef<"MailboxAuditLog", 'Boolean'>
    readonly errorMessage: FieldRef<"MailboxAuditLog", 'String'>
    readonly companyId: FieldRef<"MailboxAuditLog", 'String'>
    readonly createdAt: FieldRef<"MailboxAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MailboxAuditLog findUnique
   */
  export type MailboxAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which MailboxAuditLog to fetch.
     */
    where: MailboxAuditLogWhereUniqueInput
  }


  /**
   * MailboxAuditLog findUniqueOrThrow
   */
  export type MailboxAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which MailboxAuditLog to fetch.
     */
    where: MailboxAuditLogWhereUniqueInput
  }


  /**
   * MailboxAuditLog findFirst
   */
  export type MailboxAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which MailboxAuditLog to fetch.
     */
    where?: MailboxAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailboxAuditLogs to fetch.
     */
    orderBy?: MailboxAuditLogOrderByWithRelationInput | MailboxAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailboxAuditLogs.
     */
    cursor?: MailboxAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailboxAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailboxAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailboxAuditLogs.
     */
    distinct?: MailboxAuditLogScalarFieldEnum | MailboxAuditLogScalarFieldEnum[]
  }


  /**
   * MailboxAuditLog findFirstOrThrow
   */
  export type MailboxAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which MailboxAuditLog to fetch.
     */
    where?: MailboxAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailboxAuditLogs to fetch.
     */
    orderBy?: MailboxAuditLogOrderByWithRelationInput | MailboxAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MailboxAuditLogs.
     */
    cursor?: MailboxAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailboxAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailboxAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MailboxAuditLogs.
     */
    distinct?: MailboxAuditLogScalarFieldEnum | MailboxAuditLogScalarFieldEnum[]
  }


  /**
   * MailboxAuditLog findMany
   */
  export type MailboxAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * Filter, which MailboxAuditLogs to fetch.
     */
    where?: MailboxAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MailboxAuditLogs to fetch.
     */
    orderBy?: MailboxAuditLogOrderByWithRelationInput | MailboxAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MailboxAuditLogs.
     */
    cursor?: MailboxAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MailboxAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MailboxAuditLogs.
     */
    skip?: number
    distinct?: MailboxAuditLogScalarFieldEnum | MailboxAuditLogScalarFieldEnum[]
  }


  /**
   * MailboxAuditLog create
   */
  export type MailboxAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a MailboxAuditLog.
     */
    data: XOR<MailboxAuditLogCreateInput, MailboxAuditLogUncheckedCreateInput>
  }


  /**
   * MailboxAuditLog createMany
   */
  export type MailboxAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MailboxAuditLogs.
     */
    data: MailboxAuditLogCreateManyInput | MailboxAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MailboxAuditLog update
   */
  export type MailboxAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a MailboxAuditLog.
     */
    data: XOR<MailboxAuditLogUpdateInput, MailboxAuditLogUncheckedUpdateInput>
    /**
     * Choose, which MailboxAuditLog to update.
     */
    where: MailboxAuditLogWhereUniqueInput
  }


  /**
   * MailboxAuditLog updateMany
   */
  export type MailboxAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MailboxAuditLogs.
     */
    data: XOR<MailboxAuditLogUpdateManyMutationInput, MailboxAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which MailboxAuditLogs to update
     */
    where?: MailboxAuditLogWhereInput
  }


  /**
   * MailboxAuditLog upsert
   */
  export type MailboxAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the MailboxAuditLog to update in case it exists.
     */
    where: MailboxAuditLogWhereUniqueInput
    /**
     * In case the MailboxAuditLog found by the `where` argument doesn't exist, create a new MailboxAuditLog with this data.
     */
    create: XOR<MailboxAuditLogCreateInput, MailboxAuditLogUncheckedCreateInput>
    /**
     * In case the MailboxAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MailboxAuditLogUpdateInput, MailboxAuditLogUncheckedUpdateInput>
  }


  /**
   * MailboxAuditLog delete
   */
  export type MailboxAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
    /**
     * Filter which MailboxAuditLog to delete.
     */
    where: MailboxAuditLogWhereUniqueInput
  }


  /**
   * MailboxAuditLog deleteMany
   */
  export type MailboxAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MailboxAuditLogs to delete
     */
    where?: MailboxAuditLogWhereInput
  }


  /**
   * MailboxAuditLog without action
   */
  export type MailboxAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MailboxAuditLog
     */
    select?: MailboxAuditLogSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    jobTitle: 'jobTitle',
    phone: 'phone',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive',
    signatureEnabled: 'signatureEnabled',
    signatureStyle: 'signatureStyle',
    signatureHtml: 'signatureHtml',
    linkedinUrl: 'linkedinUrl',
    twitterUrl: 'twitterUrl',
    instagramUrl: 'instagramUrl',
    location: 'location',
    officeAddress: 'officeAddress',
    mailPassword: 'mailPassword',
    totpSecret: 'totpSecret',
    totpEnabled: 'totpEnabled',
    totpBackupCodes: 'totpBackupCodes',
    totpLastUsed: 'totpLastUsed',
    ssoProvider: 'ssoProvider',
    ssoExternalId: 'ssoExternalId',
    lastSsoLogin: 'lastSsoLogin',
    primaryMailboxId: 'primaryMailboxId',
    autoProvisionEmail: 'autoProvisionEmail',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    tagline: 'tagline',
    email: 'email',
    phone: 'phone',
    website: 'website',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    country: 'country',
    postalCode: 'postalCode',
    logoUrl: 'logoUrl',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    taxId: 'taxId',
    registrationNo: 'registrationNo',
    bankName: 'bankName',
    bankAccount: 'bankAccount',
    bankBranch: 'bankBranch',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    contactPerson: 'contactPerson',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    country: 'country',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    documentNumber: 'documentNumber',
    type: 'type',
    status: 'status',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    currency: 'currency',
    notes: 'notes',
    terms: 'terms',
    pdfUrl: 'pdfUrl',
    companyId: 'companyId',
    clientId: 'clientId',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentItemScalarFieldEnum: {
    id: 'id',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total',
    documentId: 'documentId',
    createdAt: 'createdAt'
  };

  export type DocumentItemScalarFieldEnum = (typeof DocumentItemScalarFieldEnum)[keyof typeof DocumentItemScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    isDefault: 'isDefault',
    config: 'config',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const AssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    companyId: 'companyId',
    createdAt: 'createdAt'
  };

  export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    folder: 'folder',
    fromName: 'fromName',
    fromAddress: 'fromAddress',
    toAddresses: 'toAddresses',
    ccAddresses: 'ccAddresses',
    bccAddresses: 'bccAddresses',
    subject: 'subject',
    textBody: 'textBody',
    htmlBody: 'htmlBody',
    snippet: 'snippet',
    isRead: 'isRead',
    isStarred: 'isStarred',
    hasAttachments: 'hasAttachments',
    labels: 'labels',
    priority: 'priority',
    snoozedUntil: 'snoozedUntil',
    snoozedFromFolder: 'snoozedFromFolder',
    userId: 'userId',
    sentAt: 'sentAt',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const EmailAttachmentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    emailId: 'emailId',
    createdAt: 'createdAt'
  };

  export type EmailAttachmentScalarFieldEnum = (typeof EmailAttachmentScalarFieldEnum)[keyof typeof EmailAttachmentScalarFieldEnum]


  export const EmailOutboxScalarFieldEnum: {
    id: 'id',
    fromName: 'fromName',
    fromAddress: 'fromAddress',
    toAddresses: 'toAddresses',
    ccAddresses: 'ccAddresses',
    bccAddresses: 'bccAddresses',
    subject: 'subject',
    textBody: 'textBody',
    htmlBody: 'htmlBody',
    sendAt: 'sendAt',
    status: 'status',
    sentEmailId: 'sentEmailId',
    errorMessage: 'errorMessage',
    attempts: 'attempts',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailOutboxScalarFieldEnum = (typeof EmailOutboxScalarFieldEnum)[keyof typeof EmailOutboxScalarFieldEnum]


  export const EmailDomainScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    isVerified: 'isVerified',
    isActive: 'isActive',
    verificationCode: 'verificationCode',
    verificationMethod: 'verificationMethod',
    verifiedAt: 'verifiedAt',
    dkimSelector: 'dkimSelector',
    dkimPublicKey: 'dkimPublicKey',
    dkimPrivateKey: 'dkimPrivateKey',
    dkimVerified: 'dkimVerified',
    spfRecord: 'spfRecord',
    spfVerified: 'spfVerified',
    dmarcPolicy: 'dmarcPolicy',
    dmarcRecord: 'dmarcRecord',
    dmarcVerified: 'dmarcVerified',
    mxVerified: 'mxVerified',
    catchAllEnabled: 'catchAllEnabled',
    catchAllMailboxId: 'catchAllMailboxId',
    maxMailboxes: 'maxMailboxes',
    maxAliases: 'maxAliases',
    totalStorageQuotaMb: 'totalStorageQuotaMb',
    usedStorageMb: 'usedStorageMb',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailDomainScalarFieldEnum = (typeof EmailDomainScalarFieldEnum)[keyof typeof EmailDomainScalarFieldEnum]


  export const MailboxScalarFieldEnum: {
    id: 'id',
    localPart: 'localPart',
    displayName: 'displayName',
    passwordHash: 'passwordHash',
    quotaMb: 'quotaMb',
    usedMb: 'usedMb',
    maxSendPerDay: 'maxSendPerDay',
    sentToday: 'sentToday',
    lastSentReset: 'lastSentReset',
    isActive: 'isActive',
    isAdmin: 'isAdmin',
    autoReply: 'autoReply',
    autoReplySubject: 'autoReplySubject',
    autoReplyMessage: 'autoReplyMessage',
    autoReplyStart: 'autoReplyStart',
    autoReplyEnd: 'autoReplyEnd',
    forwardingEnabled: 'forwardingEnabled',
    forwardingAddress: 'forwardingAddress',
    keepCopy: 'keepCopy',
    spamFilterLevel: 'spamFilterLevel',
    spamAction: 'spamAction',
    signatureHtml: 'signatureHtml',
    signatureText: 'signatureText',
    userId: 'userId',
    domainId: 'domainId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MailboxScalarFieldEnum = (typeof MailboxScalarFieldEnum)[keyof typeof MailboxScalarFieldEnum]


  export const EmailAliasScalarFieldEnum: {
    id: 'id',
    localPart: 'localPart',
    targetMailboxId: 'targetMailboxId',
    externalTarget: 'externalTarget',
    isActive: 'isActive',
    domainId: 'domainId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailAliasScalarFieldEnum = (typeof EmailAliasScalarFieldEnum)[keyof typeof EmailAliasScalarFieldEnum]


  export const DomainDNSScalarFieldEnum: {
    id: 'id',
    recordType: 'recordType',
    name: 'name',
    value: 'value',
    priority: 'priority',
    ttl: 'ttl',
    description: 'description',
    isRequired: 'isRequired',
    isVerified: 'isVerified',
    lastCheckedAt: 'lastCheckedAt',
    domainId: 'domainId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainDNSScalarFieldEnum = (typeof DomainDNSScalarFieldEnum)[keyof typeof DomainDNSScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    direction: 'direction',
    fromAddress: 'fromAddress',
    toAddress: 'toAddress',
    subject: 'subject',
    status: 'status',
    errorMessage: 'errorMessage',
    sizeBytes: 'sizeBytes',
    hasAttachments: 'hasAttachments',
    smtpCode: 'smtpCode',
    smtpResponse: 'smtpResponse',
    spamScore: 'spamScore',
    spamAction: 'spamAction',
    processedAt: 'processedAt',
    deliveredAt: 'deliveredAt',
    domainId: 'domainId',
    mailboxId: 'mailboxId',
    createdAt: 'createdAt'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const EmailQuarantinedScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    fromAddress: 'fromAddress',
    toAddress: 'toAddress',
    subject: 'subject',
    reason: 'reason',
    spamScore: 'spamScore',
    rawHeaders: 'rawHeaders',
    previewText: 'previewText',
    releasedAt: 'releasedAt',
    releasedBy: 'releasedBy',
    deletedAt: 'deletedAt',
    domainId: 'domainId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type EmailQuarantinedScalarFieldEnum = (typeof EmailQuarantinedScalarFieldEnum)[keyof typeof EmailQuarantinedScalarFieldEnum]


  export const EmailTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    htmlBody: 'htmlBody',
    textBody: 'textBody',
    category: 'category',
    placeholders: 'placeholders',
    usageCount: 'usageCount',
    lastUsedAt: 'lastUsedAt',
    isShared: 'isShared',
    userId: 'userId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTemplateScalarFieldEnum = (typeof EmailTemplateScalarFieldEnum)[keyof typeof EmailTemplateScalarFieldEnum]


  export const VacationResponderScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    subject: 'subject',
    message: 'message',
    isActive: 'isActive',
    onlyContacts: 'onlyContacts',
    onlyOnce: 'onlyOnce',
    excludedDomains: 'excludedDomains',
    respondedTo: 'respondedTo',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VacationResponderScalarFieldEnum = (typeof VacationResponderScalarFieldEnum)[keyof typeof VacationResponderScalarFieldEnum]


  export const EmailTrackingScalarFieldEnum: {
    id: 'id',
    trackingId: 'trackingId',
    emailId: 'emailId',
    outboxId: 'outboxId',
    subject: 'subject',
    recipientEmail: 'recipientEmail',
    openCount: 'openCount',
    clickCount: 'clickCount',
    firstOpenedAt: 'firstOpenedAt',
    lastOpenedAt: 'lastOpenedAt',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailTrackingScalarFieldEnum = (typeof EmailTrackingScalarFieldEnum)[keyof typeof EmailTrackingScalarFieldEnum]


  export const EmailTrackingEventScalarFieldEnum: {
    id: 'id',
    trackingId: 'trackingId',
    eventType: 'eventType',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    device: 'device',
    browser: 'browser',
    country: 'country',
    city: 'city',
    createdAt: 'createdAt'
  };

  export type EmailTrackingEventScalarFieldEnum = (typeof EmailTrackingEventScalarFieldEnum)[keyof typeof EmailTrackingEventScalarFieldEnum]


  export const EmailLinkClickScalarFieldEnum: {
    id: 'id',
    trackingId: 'trackingId',
    originalUrl: 'originalUrl',
    clickCount: 'clickCount',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    firstClickedAt: 'firstClickedAt',
    lastClickedAt: 'lastClickedAt'
  };

  export type EmailLinkClickScalarFieldEnum = (typeof EmailLinkClickScalarFieldEnum)[keyof typeof EmailLinkClickScalarFieldEnum]


  export const MailMergeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    htmlBody: 'htmlBody',
    textBody: 'textBody',
    recipientCount: 'recipientCount',
    recipients: 'recipients',
    status: 'status',
    scheduledAt: 'scheduledAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    sentCount: 'sentCount',
    failedCount: 'failedCount',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MailMergeScalarFieldEnum = (typeof MailMergeScalarFieldEnum)[keyof typeof MailMergeScalarFieldEnum]


  export const EmailHostingSettingsScalarFieldEnum: {
    id: 'id',
    defaultDomainId: 'defaultDomainId',
    emailFormat: 'emailFormat',
    autoProvisionEnabled: 'autoProvisionEnabled',
    defaultQuotaMb: 'defaultQuotaMb',
    defaultMaxSendPerDay: 'defaultMaxSendPerDay',
    notifyOnProvision: 'notifyOnProvision',
    welcomeEmailTemplate: 'welcomeEmailTemplate',
    requireStrongPassword: 'requireStrongPassword',
    minPasswordLength: 'minPasswordLength',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailHostingSettingsScalarFieldEnum = (typeof EmailHostingSettingsScalarFieldEnum)[keyof typeof EmailHostingSettingsScalarFieldEnum]


  export const MailboxAuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    mailboxId: 'mailboxId',
    userId: 'userId',
    domainId: 'domainId',
    performedById: 'performedById',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    success: 'success',
    errorMessage: 'errorMessage',
    companyId: 'companyId',
    createdAt: 'createdAt'
  };

  export type MailboxAuditLogScalarFieldEnum = (typeof MailboxAuditLogScalarFieldEnum)[keyof typeof MailboxAuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'AssetType'
   */
  export type EnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType'>
    


  /**
   * Reference to a field of type 'AssetType[]'
   */
  export type ListEnumAssetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetType[]'>
    


  /**
   * Reference to a field of type 'EmailFolder'
   */
  export type EnumEmailFolderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailFolder'>
    


  /**
   * Reference to a field of type 'EmailFolder[]'
   */
  export type ListEnumEmailFolderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailFolder[]'>
    


  /**
   * Reference to a field of type 'OutboxStatus'
   */
  export type EnumOutboxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboxStatus'>
    


  /**
   * Reference to a field of type 'OutboxStatus[]'
   */
  export type ListEnumOutboxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OutboxStatus[]'>
    


  /**
   * Reference to a field of type 'DNSRecordType'
   */
  export type EnumDNSRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DNSRecordType'>
    


  /**
   * Reference to a field of type 'DNSRecordType[]'
   */
  export type ListEnumDNSRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DNSRecordType[]'>
    


  /**
   * Reference to a field of type 'EmailLogStatus'
   */
  export type EnumEmailLogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailLogStatus'>
    


  /**
   * Reference to a field of type 'EmailLogStatus[]'
   */
  export type ListEnumEmailLogStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailLogStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'EmailTemplateCategory'
   */
  export type EnumEmailTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailTemplateCategory'>
    


  /**
   * Reference to a field of type 'EmailTemplateCategory[]'
   */
  export type ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailTemplateCategory[]'>
    


  /**
   * Reference to a field of type 'MailMergeStatus'
   */
  export type EnumMailMergeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailMergeStatus'>
    


  /**
   * Reference to a field of type 'MailMergeStatus[]'
   */
  export type ListEnumMailMergeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailMergeStatus[]'>
    


  /**
   * Reference to a field of type 'MailboxAuditAction'
   */
  export type EnumMailboxAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailboxAuditAction'>
    


  /**
   * Reference to a field of type 'MailboxAuditAction[]'
   */
  export type ListEnumMailboxAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MailboxAuditAction[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    jobTitle?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    signatureEnabled?: BoolFilter<"User"> | boolean
    signatureStyle?: StringFilter<"User"> | string
    signatureHtml?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    twitterUrl?: StringNullableFilter<"User"> | string | null
    instagramUrl?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    officeAddress?: StringNullableFilter<"User"> | string | null
    mailPassword?: StringNullableFilter<"User"> | string | null
    totpSecret?: StringNullableFilter<"User"> | string | null
    totpEnabled?: BoolFilter<"User"> | boolean
    totpBackupCodes?: StringNullableListFilter<"User">
    totpLastUsed?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoExternalId?: StringNullableFilter<"User"> | string | null
    lastSsoLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    primaryMailboxId?: StringNullableFilter<"User"> | string | null
    autoProvisionEmail?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    mailboxes?: MailboxListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    createdDocuments?: DocumentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    jobTitle?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    signatureEnabled?: SortOrder
    signatureStyle?: SortOrder
    signatureHtml?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    twitterUrl?: SortOrderInput | SortOrder
    instagramUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    officeAddress?: SortOrderInput | SortOrder
    mailPassword?: SortOrderInput | SortOrder
    totpSecret?: SortOrderInput | SortOrder
    totpEnabled?: SortOrder
    totpBackupCodes?: SortOrder
    totpLastUsed?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoExternalId?: SortOrderInput | SortOrder
    lastSsoLogin?: SortOrderInput | SortOrder
    primaryMailboxId?: SortOrderInput | SortOrder
    autoProvisionEmail?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mailboxes?: MailboxOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    createdDocuments?: DocumentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    jobTitle?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    signatureEnabled?: BoolFilter<"User"> | boolean
    signatureStyle?: StringFilter<"User"> | string
    signatureHtml?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    twitterUrl?: StringNullableFilter<"User"> | string | null
    instagramUrl?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    officeAddress?: StringNullableFilter<"User"> | string | null
    mailPassword?: StringNullableFilter<"User"> | string | null
    totpSecret?: StringNullableFilter<"User"> | string | null
    totpEnabled?: BoolFilter<"User"> | boolean
    totpBackupCodes?: StringNullableListFilter<"User">
    totpLastUsed?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoExternalId?: StringNullableFilter<"User"> | string | null
    lastSsoLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    primaryMailboxId?: StringNullableFilter<"User"> | string | null
    autoProvisionEmail?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    mailboxes?: MailboxListRelationFilter
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    createdDocuments?: DocumentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    jobTitle?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    signatureEnabled?: SortOrder
    signatureStyle?: SortOrder
    signatureHtml?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    twitterUrl?: SortOrderInput | SortOrder
    instagramUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    officeAddress?: SortOrderInput | SortOrder
    mailPassword?: SortOrderInput | SortOrder
    totpSecret?: SortOrderInput | SortOrder
    totpEnabled?: SortOrder
    totpBackupCodes?: SortOrder
    totpLastUsed?: SortOrderInput | SortOrder
    ssoProvider?: SortOrderInput | SortOrder
    ssoExternalId?: SortOrderInput | SortOrder
    lastSsoLogin?: SortOrderInput | SortOrder
    primaryMailboxId?: SortOrderInput | SortOrder
    autoProvisionEmail?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    jobTitle?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    signatureEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    signatureStyle?: StringWithAggregatesFilter<"User"> | string
    signatureHtml?: StringNullableWithAggregatesFilter<"User"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitterUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    instagramUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    officeAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    mailPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    totpSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    totpEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    totpBackupCodes?: StringNullableListFilter<"User">
    totpLastUsed?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoExternalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastSsoLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    primaryMailboxId?: StringNullableWithAggregatesFilter<"User"> | string | null
    autoProvisionEmail?: BoolWithAggregatesFilter<"User"> | boolean
    companyId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    tagline?: StringNullableFilter<"Company"> | string | null
    email?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    website?: StringNullableFilter<"Company"> | string | null
    addressLine1?: StringFilter<"Company"> | string
    addressLine2?: StringNullableFilter<"Company"> | string | null
    city?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    postalCode?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    primaryColor?: StringFilter<"Company"> | string
    secondaryColor?: StringFilter<"Company"> | string
    taxId?: StringNullableFilter<"Company"> | string | null
    registrationNo?: StringNullableFilter<"Company"> | string | null
    bankName?: StringNullableFilter<"Company"> | string | null
    bankAccount?: StringNullableFilter<"Company"> | string | null
    bankBranch?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    documents?: DocumentListRelationFilter
    clients?: ClientListRelationFilter
    templates?: TemplateListRelationFilter
    assets?: AssetListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    taxId?: SortOrderInput | SortOrder
    registrationNo?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    templates?: TemplateOrderByRelationAggregateInput
    assets?: AssetOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    tagline?: StringNullableFilter<"Company"> | string | null
    email?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    website?: StringNullableFilter<"Company"> | string | null
    addressLine1?: StringFilter<"Company"> | string
    addressLine2?: StringNullableFilter<"Company"> | string | null
    city?: StringFilter<"Company"> | string
    country?: StringFilter<"Company"> | string
    postalCode?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    primaryColor?: StringFilter<"Company"> | string
    secondaryColor?: StringFilter<"Company"> | string
    taxId?: StringNullableFilter<"Company"> | string | null
    registrationNo?: StringNullableFilter<"Company"> | string | null
    bankName?: StringNullableFilter<"Company"> | string | null
    bankAccount?: StringNullableFilter<"Company"> | string | null
    bankBranch?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    users?: UserListRelationFilter
    documents?: DocumentListRelationFilter
    clients?: ClientListRelationFilter
    templates?: TemplateListRelationFilter
    assets?: AssetListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrderInput | SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    taxId?: SortOrderInput | SortOrder
    registrationNo?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    bankBranch?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    tagline?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringWithAggregatesFilter<"Company"> | string
    website?: StringNullableWithAggregatesFilter<"Company"> | string | null
    addressLine1?: StringWithAggregatesFilter<"Company"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Company"> | string | null
    city?: StringWithAggregatesFilter<"Company"> | string
    country?: StringWithAggregatesFilter<"Company"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    primaryColor?: StringWithAggregatesFilter<"Company"> | string
    secondaryColor?: StringWithAggregatesFilter<"Company"> | string
    taxId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    registrationNo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Company"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Company"> | string | null
    bankBranch?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    contactPerson?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    companyId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    documents?: DocumentListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    documents?: DocumentOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    contactPerson?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    companyId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    documents?: DocumentListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"Client"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Client"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Client"> | string | null
    city?: StringNullableWithAggregatesFilter<"Client"> | string | null
    country?: StringNullableWithAggregatesFilter<"Client"> | string | null
    companyId?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    documentNumber?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    issueDate?: DateTimeFilter<"Document"> | Date | string
    dueDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    subtotal?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Document"> | string
    notes?: StringNullableFilter<"Document"> | string | null
    terms?: StringNullableFilter<"Document"> | string | null
    pdfUrl?: StringNullableFilter<"Document"> | string | null
    companyId?: StringFilter<"Document"> | string
    clientId?: StringNullableFilter<"Document"> | string | null
    createdById?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    items?: DocumentItemListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    documentNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    companyId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    items?: DocumentItemOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    documentNumber?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    issueDate?: DateTimeFilter<"Document"> | Date | string
    dueDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    subtotal?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Document"> | string
    notes?: StringNullableFilter<"Document"> | string | null
    terms?: StringNullableFilter<"Document"> | string | null
    pdfUrl?: StringNullableFilter<"Document"> | string | null
    companyId?: StringFilter<"Document"> | string
    clientId?: StringNullableFilter<"Document"> | string | null
    createdById?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
    client?: XOR<ClientNullableRelationFilter, ClientWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    items?: DocumentItemListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    documentNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    companyId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    documentNumber?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusWithAggregatesFilter<"Document"> | $Enums.DocumentStatus
    issueDate?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    subtotal?: DecimalWithAggregatesFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalWithAggregatesFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Document"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Document"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Document"> | string
    notes?: StringNullableWithAggregatesFilter<"Document"> | string | null
    terms?: StringNullableWithAggregatesFilter<"Document"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    companyId?: StringWithAggregatesFilter<"Document"> | string
    clientId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdById?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentItemWhereInput = {
    AND?: DocumentItemWhereInput | DocumentItemWhereInput[]
    OR?: DocumentItemWhereInput[]
    NOT?: DocumentItemWhereInput | DocumentItemWhereInput[]
    id?: StringFilter<"DocumentItem"> | string
    description?: StringFilter<"DocumentItem"> | string
    quantity?: IntFilter<"DocumentItem"> | number
    unitPrice?: DecimalFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    documentId?: StringFilter<"DocumentItem"> | string
    createdAt?: DateTimeFilter<"DocumentItem"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type DocumentItemOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentItemWhereInput | DocumentItemWhereInput[]
    OR?: DocumentItemWhereInput[]
    NOT?: DocumentItemWhereInput | DocumentItemWhereInput[]
    description?: StringFilter<"DocumentItem"> | string
    quantity?: IntFilter<"DocumentItem"> | number
    unitPrice?: DecimalFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    documentId?: StringFilter<"DocumentItem"> | string
    createdAt?: DateTimeFilter<"DocumentItem"> | Date | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }, "id">

  export type DocumentItemOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentItemCountOrderByAggregateInput
    _avg?: DocumentItemAvgOrderByAggregateInput
    _max?: DocumentItemMaxOrderByAggregateInput
    _min?: DocumentItemMinOrderByAggregateInput
    _sum?: DocumentItemSumOrderByAggregateInput
  }

  export type DocumentItemScalarWhereWithAggregatesInput = {
    AND?: DocumentItemScalarWhereWithAggregatesInput | DocumentItemScalarWhereWithAggregatesInput[]
    OR?: DocumentItemScalarWhereWithAggregatesInput[]
    NOT?: DocumentItemScalarWhereWithAggregatesInput | DocumentItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentItem"> | string
    description?: StringWithAggregatesFilter<"DocumentItem"> | string
    quantity?: IntWithAggregatesFilter<"DocumentItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    documentId?: StringWithAggregatesFilter<"DocumentItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentItem"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    type?: EnumDocumentTypeFilter<"Template"> | $Enums.DocumentType
    description?: StringNullableFilter<"Template"> | string | null
    isDefault?: BoolFilter<"Template"> | boolean
    config?: JsonNullableFilter<"Template">
    companyId?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    config?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    name?: StringFilter<"Template"> | string
    type?: EnumDocumentTypeFilter<"Template"> | $Enums.DocumentType
    description?: StringNullableFilter<"Template"> | string | null
    isDefault?: BoolFilter<"Template"> | boolean
    config?: JsonNullableFilter<"Template">
    companyId?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    config?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    name?: StringWithAggregatesFilter<"Template"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Template"> | $Enums.DocumentType
    description?: StringNullableWithAggregatesFilter<"Template"> | string | null
    isDefault?: BoolWithAggregatesFilter<"Template"> | boolean
    config?: JsonNullableWithAggregatesFilter<"Template">
    companyId?: StringWithAggregatesFilter<"Template"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type AssetWhereInput = {
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    id?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    mimeType?: StringFilter<"Asset"> | string
    size?: IntFilter<"Asset"> | number
    url?: StringFilter<"Asset"> | string
    companyId?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }

  export type AssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type AssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetWhereInput | AssetWhereInput[]
    OR?: AssetWhereInput[]
    NOT?: AssetWhereInput | AssetWhereInput[]
    name?: StringFilter<"Asset"> | string
    type?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    mimeType?: StringFilter<"Asset"> | string
    size?: IntFilter<"Asset"> | number
    url?: StringFilter<"Asset"> | string
    companyId?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
    company?: XOR<CompanyRelationFilter, CompanyWhereInput>
  }, "id">

  export type AssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    _count?: AssetCountOrderByAggregateInput
    _avg?: AssetAvgOrderByAggregateInput
    _max?: AssetMaxOrderByAggregateInput
    _min?: AssetMinOrderByAggregateInput
    _sum?: AssetSumOrderByAggregateInput
  }

  export type AssetScalarWhereWithAggregatesInput = {
    AND?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    OR?: AssetScalarWhereWithAggregatesInput[]
    NOT?: AssetScalarWhereWithAggregatesInput | AssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Asset"> | string
    name?: StringWithAggregatesFilter<"Asset"> | string
    type?: EnumAssetTypeWithAggregatesFilter<"Asset"> | $Enums.AssetType
    mimeType?: StringWithAggregatesFilter<"Asset"> | string
    size?: IntWithAggregatesFilter<"Asset"> | number
    url?: StringWithAggregatesFilter<"Asset"> | string
    companyId?: StringWithAggregatesFilter<"Asset"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Asset"> | Date | string
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    id?: StringFilter<"Email"> | string
    messageId?: StringFilter<"Email"> | string
    folder?: EnumEmailFolderFilter<"Email"> | $Enums.EmailFolder
    fromName?: StringNullableFilter<"Email"> | string | null
    fromAddress?: StringFilter<"Email"> | string
    toAddresses?: StringNullableListFilter<"Email">
    ccAddresses?: StringNullableListFilter<"Email">
    bccAddresses?: StringNullableListFilter<"Email">
    subject?: StringFilter<"Email"> | string
    textBody?: StringNullableFilter<"Email"> | string | null
    htmlBody?: StringNullableFilter<"Email"> | string | null
    snippet?: StringNullableFilter<"Email"> | string | null
    isRead?: BoolFilter<"Email"> | boolean
    isStarred?: BoolFilter<"Email"> | boolean
    hasAttachments?: BoolFilter<"Email"> | boolean
    labels?: StringNullableListFilter<"Email">
    priority?: StringFilter<"Email"> | string
    snoozedUntil?: DateTimeNullableFilter<"Email"> | Date | string | null
    snoozedFromFolder?: StringNullableFilter<"Email"> | string | null
    userId?: StringFilter<"Email"> | string
    sentAt?: DateTimeFilter<"Email"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    attachments?: EmailAttachmentListRelationFilter
  }

  export type EmailOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    folder?: SortOrder
    fromName?: SortOrderInput | SortOrder
    fromAddress?: SortOrder
    toAddresses?: SortOrder
    ccAddresses?: SortOrder
    bccAddresses?: SortOrder
    subject?: SortOrder
    textBody?: SortOrderInput | SortOrder
    htmlBody?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isStarred?: SortOrder
    hasAttachments?: SortOrder
    labels?: SortOrder
    priority?: SortOrder
    snoozedUntil?: SortOrderInput | SortOrder
    snoozedFromFolder?: SortOrderInput | SortOrder
    userId?: SortOrder
    sentAt?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attachments?: EmailAttachmentOrderByRelationAggregateInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId?: string
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    folder?: EnumEmailFolderFilter<"Email"> | $Enums.EmailFolder
    fromName?: StringNullableFilter<"Email"> | string | null
    fromAddress?: StringFilter<"Email"> | string
    toAddresses?: StringNullableListFilter<"Email">
    ccAddresses?: StringNullableListFilter<"Email">
    bccAddresses?: StringNullableListFilter<"Email">
    subject?: StringFilter<"Email"> | string
    textBody?: StringNullableFilter<"Email"> | string | null
    htmlBody?: StringNullableFilter<"Email"> | string | null
    snippet?: StringNullableFilter<"Email"> | string | null
    isRead?: BoolFilter<"Email"> | boolean
    isStarred?: BoolFilter<"Email"> | boolean
    hasAttachments?: BoolFilter<"Email"> | boolean
    labels?: StringNullableListFilter<"Email">
    priority?: StringFilter<"Email"> | string
    snoozedUntil?: DateTimeNullableFilter<"Email"> | Date | string | null
    snoozedFromFolder?: StringNullableFilter<"Email"> | string | null
    userId?: StringFilter<"Email"> | string
    sentAt?: DateTimeFilter<"Email"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"Email"> | Date | string | null
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    attachments?: EmailAttachmentListRelationFilter
  }, "id" | "messageId">

  export type EmailOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    folder?: SortOrder
    fromName?: SortOrderInput | SortOrder
    fromAddress?: SortOrder
    toAddresses?: SortOrder
    ccAddresses?: SortOrder
    bccAddresses?: SortOrder
    subject?: SortOrder
    textBody?: SortOrderInput | SortOrder
    htmlBody?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isStarred?: SortOrder
    hasAttachments?: SortOrder
    labels?: SortOrder
    priority?: SortOrder
    snoozedUntil?: SortOrderInput | SortOrder
    snoozedFromFolder?: SortOrderInput | SortOrder
    userId?: SortOrder
    sentAt?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailCountOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Email"> | string
    messageId?: StringWithAggregatesFilter<"Email"> | string
    folder?: EnumEmailFolderWithAggregatesFilter<"Email"> | $Enums.EmailFolder
    fromName?: StringNullableWithAggregatesFilter<"Email"> | string | null
    fromAddress?: StringWithAggregatesFilter<"Email"> | string
    toAddresses?: StringNullableListFilter<"Email">
    ccAddresses?: StringNullableListFilter<"Email">
    bccAddresses?: StringNullableListFilter<"Email">
    subject?: StringWithAggregatesFilter<"Email"> | string
    textBody?: StringNullableWithAggregatesFilter<"Email"> | string | null
    htmlBody?: StringNullableWithAggregatesFilter<"Email"> | string | null
    snippet?: StringNullableWithAggregatesFilter<"Email"> | string | null
    isRead?: BoolWithAggregatesFilter<"Email"> | boolean
    isStarred?: BoolWithAggregatesFilter<"Email"> | boolean
    hasAttachments?: BoolWithAggregatesFilter<"Email"> | boolean
    labels?: StringNullableListFilter<"Email">
    priority?: StringWithAggregatesFilter<"Email"> | string
    snoozedUntil?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    snoozedFromFolder?: StringNullableWithAggregatesFilter<"Email"> | string | null
    userId?: StringWithAggregatesFilter<"Email"> | string
    sentAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Email"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
  }

  export type EmailAttachmentWhereInput = {
    AND?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    OR?: EmailAttachmentWhereInput[]
    NOT?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    id?: StringFilter<"EmailAttachment"> | string
    filename?: StringFilter<"EmailAttachment"> | string
    mimeType?: StringFilter<"EmailAttachment"> | string
    size?: IntFilter<"EmailAttachment"> | number
    url?: StringNullableFilter<"EmailAttachment"> | string | null
    emailId?: StringFilter<"EmailAttachment"> | string
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
    email?: XOR<EmailRelationFilter, EmailWhereInput>
  }

  export type EmailAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrderInput | SortOrder
    emailId?: SortOrder
    createdAt?: SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    OR?: EmailAttachmentWhereInput[]
    NOT?: EmailAttachmentWhereInput | EmailAttachmentWhereInput[]
    filename?: StringFilter<"EmailAttachment"> | string
    mimeType?: StringFilter<"EmailAttachment"> | string
    size?: IntFilter<"EmailAttachment"> | number
    url?: StringNullableFilter<"EmailAttachment"> | string | null
    emailId?: StringFilter<"EmailAttachment"> | string
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
    email?: XOR<EmailRelationFilter, EmailWhereInput>
  }, "id">

  export type EmailAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrderInput | SortOrder
    emailId?: SortOrder
    createdAt?: SortOrder
    _count?: EmailAttachmentCountOrderByAggregateInput
    _avg?: EmailAttachmentAvgOrderByAggregateInput
    _max?: EmailAttachmentMaxOrderByAggregateInput
    _min?: EmailAttachmentMinOrderByAggregateInput
    _sum?: EmailAttachmentSumOrderByAggregateInput
  }

  export type EmailAttachmentScalarWhereWithAggregatesInput = {
    AND?: EmailAttachmentScalarWhereWithAggregatesInput | EmailAttachmentScalarWhereWithAggregatesInput[]
    OR?: EmailAttachmentScalarWhereWithAggregatesInput[]
    NOT?: EmailAttachmentScalarWhereWithAggregatesInput | EmailAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAttachment"> | string
    filename?: StringWithAggregatesFilter<"EmailAttachment"> | string
    mimeType?: StringWithAggregatesFilter<"EmailAttachment"> | string
    size?: IntWithAggregatesFilter<"EmailAttachment"> | number
    url?: StringNullableWithAggregatesFilter<"EmailAttachment"> | string | null
    emailId?: StringWithAggregatesFilter<"EmailAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailAttachment"> | Date | string
  }

  export type EmailOutboxWhereInput = {
    AND?: EmailOutboxWhereInput | EmailOutboxWhereInput[]
    OR?: EmailOutboxWhereInput[]
    NOT?: EmailOutboxWhereInput | EmailOutboxWhereInput[]
    id?: StringFilter<"EmailOutbox"> | string
    fromName?: StringNullableFilter<"EmailOutbox"> | string | null
    fromAddress?: StringFilter<"EmailOutbox"> | string
    toAddresses?: StringNullableListFilter<"EmailOutbox">
    ccAddresses?: StringNullableListFilter<"EmailOutbox">
    bccAddresses?: StringNullableListFilter<"EmailOutbox">
    subject?: StringFilter<"EmailOutbox"> | string
    textBody?: StringNullableFilter<"EmailOutbox"> | string | null
    htmlBody?: StringNullableFilter<"EmailOutbox"> | string | null
    sendAt?: DateTimeFilter<"EmailOutbox"> | Date | string
    status?: EnumOutboxStatusFilter<"EmailOutbox"> | $Enums.OutboxStatus
    sentEmailId?: StringNullableFilter<"EmailOutbox"> | string | null
    errorMessage?: StringNullableFilter<"EmailOutbox"> | string | null
    attempts?: IntFilter<"EmailOutbox"> | number
    userId?: StringFilter<"EmailOutbox"> | string
    createdAt?: DateTimeFilter<"EmailOutbox"> | Date | string
    updatedAt?: DateTimeFilter<"EmailOutbox"> | Date | string
  }

  export type EmailOutboxOrderByWithRelationInput = {
    id?: SortOrder
    fromName?: SortOrderInput | SortOrder
    fromAddress?: SortOrder
    toAddresses?: SortOrder
    ccAddresses?: SortOrder
    bccAddresses?: SortOrder
    subject?: SortOrder
    textBody?: SortOrderInput | SortOrder
    htmlBody?: SortOrderInput | SortOrder
    sendAt?: SortOrder
    status?: SortOrder
    sentEmailId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    attempts?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailOutboxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailOutboxWhereInput | EmailOutboxWhereInput[]
    OR?: EmailOutboxWhereInput[]
    NOT?: EmailOutboxWhereInput | EmailOutboxWhereInput[]
    fromName?: StringNullableFilter<"EmailOutbox"> | string | null
    fromAddress?: StringFilter<"EmailOutbox"> | string
    toAddresses?: StringNullableListFilter<"EmailOutbox">
    ccAddresses?: StringNullableListFilter<"EmailOutbox">
    bccAddresses?: StringNullableListFilter<"EmailOutbox">
    subject?: StringFilter<"EmailOutbox"> | string
    textBody?: StringNullableFilter<"EmailOutbox"> | string | null
    htmlBody?: StringNullableFilter<"EmailOutbox"> | string | null
    sendAt?: DateTimeFilter<"EmailOutbox"> | Date | string
    status?: EnumOutboxStatusFilter<"EmailOutbox"> | $Enums.OutboxStatus
    sentEmailId?: StringNullableFilter<"EmailOutbox"> | string | null
    errorMessage?: StringNullableFilter<"EmailOutbox"> | string | null
    attempts?: IntFilter<"EmailOutbox"> | number
    userId?: StringFilter<"EmailOutbox"> | string
    createdAt?: DateTimeFilter<"EmailOutbox"> | Date | string
    updatedAt?: DateTimeFilter<"EmailOutbox"> | Date | string
  }, "id">

  export type EmailOutboxOrderByWithAggregationInput = {
    id?: SortOrder
    fromName?: SortOrderInput | SortOrder
    fromAddress?: SortOrder
    toAddresses?: SortOrder
    ccAddresses?: SortOrder
    bccAddresses?: SortOrder
    subject?: SortOrder
    textBody?: SortOrderInput | SortOrder
    htmlBody?: SortOrderInput | SortOrder
    sendAt?: SortOrder
    status?: SortOrder
    sentEmailId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    attempts?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailOutboxCountOrderByAggregateInput
    _avg?: EmailOutboxAvgOrderByAggregateInput
    _max?: EmailOutboxMaxOrderByAggregateInput
    _min?: EmailOutboxMinOrderByAggregateInput
    _sum?: EmailOutboxSumOrderByAggregateInput
  }

  export type EmailOutboxScalarWhereWithAggregatesInput = {
    AND?: EmailOutboxScalarWhereWithAggregatesInput | EmailOutboxScalarWhereWithAggregatesInput[]
    OR?: EmailOutboxScalarWhereWithAggregatesInput[]
    NOT?: EmailOutboxScalarWhereWithAggregatesInput | EmailOutboxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailOutbox"> | string
    fromName?: StringNullableWithAggregatesFilter<"EmailOutbox"> | string | null
    fromAddress?: StringWithAggregatesFilter<"EmailOutbox"> | string
    toAddresses?: StringNullableListFilter<"EmailOutbox">
    ccAddresses?: StringNullableListFilter<"EmailOutbox">
    bccAddresses?: StringNullableListFilter<"EmailOutbox">
    subject?: StringWithAggregatesFilter<"EmailOutbox"> | string
    textBody?: StringNullableWithAggregatesFilter<"EmailOutbox"> | string | null
    htmlBody?: StringNullableWithAggregatesFilter<"EmailOutbox"> | string | null
    sendAt?: DateTimeWithAggregatesFilter<"EmailOutbox"> | Date | string
    status?: EnumOutboxStatusWithAggregatesFilter<"EmailOutbox"> | $Enums.OutboxStatus
    sentEmailId?: StringNullableWithAggregatesFilter<"EmailOutbox"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"EmailOutbox"> | string | null
    attempts?: IntWithAggregatesFilter<"EmailOutbox"> | number
    userId?: StringWithAggregatesFilter<"EmailOutbox"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailOutbox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailOutbox"> | Date | string
  }

  export type EmailDomainWhereInput = {
    AND?: EmailDomainWhereInput | EmailDomainWhereInput[]
    OR?: EmailDomainWhereInput[]
    NOT?: EmailDomainWhereInput | EmailDomainWhereInput[]
    id?: StringFilter<"EmailDomain"> | string
    domain?: StringFilter<"EmailDomain"> | string
    isVerified?: BoolFilter<"EmailDomain"> | boolean
    isActive?: BoolFilter<"EmailDomain"> | boolean
    verificationCode?: StringNullableFilter<"EmailDomain"> | string | null
    verificationMethod?: StringFilter<"EmailDomain"> | string
    verifiedAt?: DateTimeNullableFilter<"EmailDomain"> | Date | string | null
    dkimSelector?: StringNullableFilter<"EmailDomain"> | string | null
    dkimPublicKey?: StringNullableFilter<"EmailDomain"> | string | null
    dkimPrivateKey?: StringNullableFilter<"EmailDomain"> | string | null
    dkimVerified?: BoolFilter<"EmailDomain"> | boolean
    spfRecord?: StringNullableFilter<"EmailDomain"> | string | null
    spfVerified?: BoolFilter<"EmailDomain"> | boolean
    dmarcPolicy?: StringFilter<"EmailDomain"> | string
    dmarcRecord?: StringNullableFilter<"EmailDomain"> | string | null
    dmarcVerified?: BoolFilter<"EmailDomain"> | boolean
    mxVerified?: BoolFilter<"EmailDomain"> | boolean
    catchAllEnabled?: BoolFilter<"EmailDomain"> | boolean
    catchAllMailboxId?: StringNullableFilter<"EmailDomain"> | string | null
    maxMailboxes?: IntFilter<"EmailDomain"> | number
    maxAliases?: IntFilter<"EmailDomain"> | number
    totalStorageQuotaMb?: IntFilter<"EmailDomain"> | number
    usedStorageMb?: IntFilter<"EmailDomain"> | number
    companyId?: StringFilter<"EmailDomain"> | string
    createdAt?: DateTimeFilter<"EmailDomain"> | Date | string
    updatedAt?: DateTimeFilter<"EmailDomain"> | Date | string
    mailboxes?: MailboxListRelationFilter
    aliases?: EmailAliasListRelationFilter
    dnsRecords?: DomainDNSListRelationFilter
  }

  export type EmailDomainOrderByWithRelationInput = {
    id?: SortOrder
    domain?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    dkimSelector?: SortOrderInput | SortOrder
    dkimPublicKey?: SortOrderInput | SortOrder
    dkimPrivateKey?: SortOrderInput | SortOrder
    dkimVerified?: SortOrder
    spfRecord?: SortOrderInput | SortOrder
    spfVerified?: SortOrder
    dmarcPolicy?: SortOrder
    dmarcRecord?: SortOrderInput | SortOrder
    dmarcVerified?: SortOrder
    mxVerified?: SortOrder
    catchAllEnabled?: SortOrder
    catchAllMailboxId?: SortOrderInput | SortOrder
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mailboxes?: MailboxOrderByRelationAggregateInput
    aliases?: EmailAliasOrderByRelationAggregateInput
    dnsRecords?: DomainDNSOrderByRelationAggregateInput
  }

  export type EmailDomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: EmailDomainWhereInput | EmailDomainWhereInput[]
    OR?: EmailDomainWhereInput[]
    NOT?: EmailDomainWhereInput | EmailDomainWhereInput[]
    isVerified?: BoolFilter<"EmailDomain"> | boolean
    isActive?: BoolFilter<"EmailDomain"> | boolean
    verificationCode?: StringNullableFilter<"EmailDomain"> | string | null
    verificationMethod?: StringFilter<"EmailDomain"> | string
    verifiedAt?: DateTimeNullableFilter<"EmailDomain"> | Date | string | null
    dkimSelector?: StringNullableFilter<"EmailDomain"> | string | null
    dkimPublicKey?: StringNullableFilter<"EmailDomain"> | string | null
    dkimPrivateKey?: StringNullableFilter<"EmailDomain"> | string | null
    dkimVerified?: BoolFilter<"EmailDomain"> | boolean
    spfRecord?: StringNullableFilter<"EmailDomain"> | string | null
    spfVerified?: BoolFilter<"EmailDomain"> | boolean
    dmarcPolicy?: StringFilter<"EmailDomain"> | string
    dmarcRecord?: StringNullableFilter<"EmailDomain"> | string | null
    dmarcVerified?: BoolFilter<"EmailDomain"> | boolean
    mxVerified?: BoolFilter<"EmailDomain"> | boolean
    catchAllEnabled?: BoolFilter<"EmailDomain"> | boolean
    catchAllMailboxId?: StringNullableFilter<"EmailDomain"> | string | null
    maxMailboxes?: IntFilter<"EmailDomain"> | number
    maxAliases?: IntFilter<"EmailDomain"> | number
    totalStorageQuotaMb?: IntFilter<"EmailDomain"> | number
    usedStorageMb?: IntFilter<"EmailDomain"> | number
    companyId?: StringFilter<"EmailDomain"> | string
    createdAt?: DateTimeFilter<"EmailDomain"> | Date | string
    updatedAt?: DateTimeFilter<"EmailDomain"> | Date | string
    mailboxes?: MailboxListRelationFilter
    aliases?: EmailAliasListRelationFilter
    dnsRecords?: DomainDNSListRelationFilter
  }, "id" | "domain">

  export type EmailDomainOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    dkimSelector?: SortOrderInput | SortOrder
    dkimPublicKey?: SortOrderInput | SortOrder
    dkimPrivateKey?: SortOrderInput | SortOrder
    dkimVerified?: SortOrder
    spfRecord?: SortOrderInput | SortOrder
    spfVerified?: SortOrder
    dmarcPolicy?: SortOrder
    dmarcRecord?: SortOrderInput | SortOrder
    dmarcVerified?: SortOrder
    mxVerified?: SortOrder
    catchAllEnabled?: SortOrder
    catchAllMailboxId?: SortOrderInput | SortOrder
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailDomainCountOrderByAggregateInput
    _avg?: EmailDomainAvgOrderByAggregateInput
    _max?: EmailDomainMaxOrderByAggregateInput
    _min?: EmailDomainMinOrderByAggregateInput
    _sum?: EmailDomainSumOrderByAggregateInput
  }

  export type EmailDomainScalarWhereWithAggregatesInput = {
    AND?: EmailDomainScalarWhereWithAggregatesInput | EmailDomainScalarWhereWithAggregatesInput[]
    OR?: EmailDomainScalarWhereWithAggregatesInput[]
    NOT?: EmailDomainScalarWhereWithAggregatesInput | EmailDomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailDomain"> | string
    domain?: StringWithAggregatesFilter<"EmailDomain"> | string
    isVerified?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    isActive?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    verificationCode?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    verificationMethod?: StringWithAggregatesFilter<"EmailDomain"> | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"EmailDomain"> | Date | string | null
    dkimSelector?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    dkimPublicKey?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    dkimPrivateKey?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    dkimVerified?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    spfRecord?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    spfVerified?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    dmarcPolicy?: StringWithAggregatesFilter<"EmailDomain"> | string
    dmarcRecord?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    dmarcVerified?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    mxVerified?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    catchAllEnabled?: BoolWithAggregatesFilter<"EmailDomain"> | boolean
    catchAllMailboxId?: StringNullableWithAggregatesFilter<"EmailDomain"> | string | null
    maxMailboxes?: IntWithAggregatesFilter<"EmailDomain"> | number
    maxAliases?: IntWithAggregatesFilter<"EmailDomain"> | number
    totalStorageQuotaMb?: IntWithAggregatesFilter<"EmailDomain"> | number
    usedStorageMb?: IntWithAggregatesFilter<"EmailDomain"> | number
    companyId?: StringWithAggregatesFilter<"EmailDomain"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailDomain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailDomain"> | Date | string
  }

  export type MailboxWhereInput = {
    AND?: MailboxWhereInput | MailboxWhereInput[]
    OR?: MailboxWhereInput[]
    NOT?: MailboxWhereInput | MailboxWhereInput[]
    id?: StringFilter<"Mailbox"> | string
    localPart?: StringFilter<"Mailbox"> | string
    displayName?: StringNullableFilter<"Mailbox"> | string | null
    passwordHash?: StringFilter<"Mailbox"> | string
    quotaMb?: IntFilter<"Mailbox"> | number
    usedMb?: IntFilter<"Mailbox"> | number
    maxSendPerDay?: IntFilter<"Mailbox"> | number
    sentToday?: IntFilter<"Mailbox"> | number
    lastSentReset?: DateTimeFilter<"Mailbox"> | Date | string
    isActive?: BoolFilter<"Mailbox"> | boolean
    isAdmin?: BoolFilter<"Mailbox"> | boolean
    autoReply?: BoolFilter<"Mailbox"> | boolean
    autoReplySubject?: StringNullableFilter<"Mailbox"> | string | null
    autoReplyMessage?: StringNullableFilter<"Mailbox"> | string | null
    autoReplyStart?: DateTimeNullableFilter<"Mailbox"> | Date | string | null
    autoReplyEnd?: DateTimeNullableFilter<"Mailbox"> | Date | string | null
    forwardingEnabled?: BoolFilter<"Mailbox"> | boolean
    forwardingAddress?: StringNullableFilter<"Mailbox"> | string | null
    keepCopy?: BoolFilter<"Mailbox"> | boolean
    spamFilterLevel?: StringFilter<"Mailbox"> | string
    spamAction?: StringFilter<"Mailbox"> | string
    signatureHtml?: StringNullableFilter<"Mailbox"> | string | null
    signatureText?: StringNullableFilter<"Mailbox"> | string | null
    userId?: StringNullableFilter<"Mailbox"> | string | null
    domainId?: StringFilter<"Mailbox"> | string
    createdAt?: DateTimeFilter<"Mailbox"> | Date | string
    updatedAt?: DateTimeFilter<"Mailbox"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    domain?: XOR<EmailDomainRelationFilter, EmailDomainWhereInput>
    targetAliases?: EmailAliasListRelationFilter
  }

  export type MailboxOrderByWithRelationInput = {
    id?: SortOrder
    localPart?: SortOrder
    displayName?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
    lastSentReset?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    autoReply?: SortOrder
    autoReplySubject?: SortOrderInput | SortOrder
    autoReplyMessage?: SortOrderInput | SortOrder
    autoReplyStart?: SortOrderInput | SortOrder
    autoReplyEnd?: SortOrderInput | SortOrder
    forwardingEnabled?: SortOrder
    forwardingAddress?: SortOrderInput | SortOrder
    keepCopy?: SortOrder
    spamFilterLevel?: SortOrder
    spamAction?: SortOrder
    signatureHtml?: SortOrderInput | SortOrder
    signatureText?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    domain?: EmailDomainOrderByWithRelationInput
    targetAliases?: EmailAliasOrderByRelationAggregateInput
  }

  export type MailboxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    localPart_domainId?: MailboxLocalPartDomainIdCompoundUniqueInput
    AND?: MailboxWhereInput | MailboxWhereInput[]
    OR?: MailboxWhereInput[]
    NOT?: MailboxWhereInput | MailboxWhereInput[]
    localPart?: StringFilter<"Mailbox"> | string
    displayName?: StringNullableFilter<"Mailbox"> | string | null
    passwordHash?: StringFilter<"Mailbox"> | string
    quotaMb?: IntFilter<"Mailbox"> | number
    usedMb?: IntFilter<"Mailbox"> | number
    maxSendPerDay?: IntFilter<"Mailbox"> | number
    sentToday?: IntFilter<"Mailbox"> | number
    lastSentReset?: DateTimeFilter<"Mailbox"> | Date | string
    isActive?: BoolFilter<"Mailbox"> | boolean
    isAdmin?: BoolFilter<"Mailbox"> | boolean
    autoReply?: BoolFilter<"Mailbox"> | boolean
    autoReplySubject?: StringNullableFilter<"Mailbox"> | string | null
    autoReplyMessage?: StringNullableFilter<"Mailbox"> | string | null
    autoReplyStart?: DateTimeNullableFilter<"Mailbox"> | Date | string | null
    autoReplyEnd?: DateTimeNullableFilter<"Mailbox"> | Date | string | null
    forwardingEnabled?: BoolFilter<"Mailbox"> | boolean
    forwardingAddress?: StringNullableFilter<"Mailbox"> | string | null
    keepCopy?: BoolFilter<"Mailbox"> | boolean
    spamFilterLevel?: StringFilter<"Mailbox"> | string
    spamAction?: StringFilter<"Mailbox"> | string
    signatureHtml?: StringNullableFilter<"Mailbox"> | string | null
    signatureText?: StringNullableFilter<"Mailbox"> | string | null
    userId?: StringNullableFilter<"Mailbox"> | string | null
    domainId?: StringFilter<"Mailbox"> | string
    createdAt?: DateTimeFilter<"Mailbox"> | Date | string
    updatedAt?: DateTimeFilter<"Mailbox"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    domain?: XOR<EmailDomainRelationFilter, EmailDomainWhereInput>
    targetAliases?: EmailAliasListRelationFilter
  }, "id" | "localPart_domainId">

  export type MailboxOrderByWithAggregationInput = {
    id?: SortOrder
    localPart?: SortOrder
    displayName?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
    lastSentReset?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    autoReply?: SortOrder
    autoReplySubject?: SortOrderInput | SortOrder
    autoReplyMessage?: SortOrderInput | SortOrder
    autoReplyStart?: SortOrderInput | SortOrder
    autoReplyEnd?: SortOrderInput | SortOrder
    forwardingEnabled?: SortOrder
    forwardingAddress?: SortOrderInput | SortOrder
    keepCopy?: SortOrder
    spamFilterLevel?: SortOrder
    spamAction?: SortOrder
    signatureHtml?: SortOrderInput | SortOrder
    signatureText?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MailboxCountOrderByAggregateInput
    _avg?: MailboxAvgOrderByAggregateInput
    _max?: MailboxMaxOrderByAggregateInput
    _min?: MailboxMinOrderByAggregateInput
    _sum?: MailboxSumOrderByAggregateInput
  }

  export type MailboxScalarWhereWithAggregatesInput = {
    AND?: MailboxScalarWhereWithAggregatesInput | MailboxScalarWhereWithAggregatesInput[]
    OR?: MailboxScalarWhereWithAggregatesInput[]
    NOT?: MailboxScalarWhereWithAggregatesInput | MailboxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mailbox"> | string
    localPart?: StringWithAggregatesFilter<"Mailbox"> | string
    displayName?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    passwordHash?: StringWithAggregatesFilter<"Mailbox"> | string
    quotaMb?: IntWithAggregatesFilter<"Mailbox"> | number
    usedMb?: IntWithAggregatesFilter<"Mailbox"> | number
    maxSendPerDay?: IntWithAggregatesFilter<"Mailbox"> | number
    sentToday?: IntWithAggregatesFilter<"Mailbox"> | number
    lastSentReset?: DateTimeWithAggregatesFilter<"Mailbox"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Mailbox"> | boolean
    isAdmin?: BoolWithAggregatesFilter<"Mailbox"> | boolean
    autoReply?: BoolWithAggregatesFilter<"Mailbox"> | boolean
    autoReplySubject?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    autoReplyMessage?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    autoReplyStart?: DateTimeNullableWithAggregatesFilter<"Mailbox"> | Date | string | null
    autoReplyEnd?: DateTimeNullableWithAggregatesFilter<"Mailbox"> | Date | string | null
    forwardingEnabled?: BoolWithAggregatesFilter<"Mailbox"> | boolean
    forwardingAddress?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    keepCopy?: BoolWithAggregatesFilter<"Mailbox"> | boolean
    spamFilterLevel?: StringWithAggregatesFilter<"Mailbox"> | string
    spamAction?: StringWithAggregatesFilter<"Mailbox"> | string
    signatureHtml?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    signatureText?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Mailbox"> | string | null
    domainId?: StringWithAggregatesFilter<"Mailbox"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Mailbox"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mailbox"> | Date | string
  }

  export type EmailAliasWhereInput = {
    AND?: EmailAliasWhereInput | EmailAliasWhereInput[]
    OR?: EmailAliasWhereInput[]
    NOT?: EmailAliasWhereInput | EmailAliasWhereInput[]
    id?: StringFilter<"EmailAlias"> | string
    localPart?: StringFilter<"EmailAlias"> | string
    targetMailboxId?: StringNullableFilter<"EmailAlias"> | string | null
    externalTarget?: StringNullableFilter<"EmailAlias"> | string | null
    isActive?: BoolFilter<"EmailAlias"> | boolean
    domainId?: StringFilter<"EmailAlias"> | string
    createdAt?: DateTimeFilter<"EmailAlias"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAlias"> | Date | string
    targetMailbox?: XOR<MailboxNullableRelationFilter, MailboxWhereInput> | null
    domain?: XOR<EmailDomainRelationFilter, EmailDomainWhereInput>
  }

  export type EmailAliasOrderByWithRelationInput = {
    id?: SortOrder
    localPart?: SortOrder
    targetMailboxId?: SortOrderInput | SortOrder
    externalTarget?: SortOrderInput | SortOrder
    isActive?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targetMailbox?: MailboxOrderByWithRelationInput
    domain?: EmailDomainOrderByWithRelationInput
  }

  export type EmailAliasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    localPart_domainId?: EmailAliasLocalPartDomainIdCompoundUniqueInput
    AND?: EmailAliasWhereInput | EmailAliasWhereInput[]
    OR?: EmailAliasWhereInput[]
    NOT?: EmailAliasWhereInput | EmailAliasWhereInput[]
    localPart?: StringFilter<"EmailAlias"> | string
    targetMailboxId?: StringNullableFilter<"EmailAlias"> | string | null
    externalTarget?: StringNullableFilter<"EmailAlias"> | string | null
    isActive?: BoolFilter<"EmailAlias"> | boolean
    domainId?: StringFilter<"EmailAlias"> | string
    createdAt?: DateTimeFilter<"EmailAlias"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAlias"> | Date | string
    targetMailbox?: XOR<MailboxNullableRelationFilter, MailboxWhereInput> | null
    domain?: XOR<EmailDomainRelationFilter, EmailDomainWhereInput>
  }, "id" | "localPart_domainId">

  export type EmailAliasOrderByWithAggregationInput = {
    id?: SortOrder
    localPart?: SortOrder
    targetMailboxId?: SortOrderInput | SortOrder
    externalTarget?: SortOrderInput | SortOrder
    isActive?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailAliasCountOrderByAggregateInput
    _max?: EmailAliasMaxOrderByAggregateInput
    _min?: EmailAliasMinOrderByAggregateInput
  }

  export type EmailAliasScalarWhereWithAggregatesInput = {
    AND?: EmailAliasScalarWhereWithAggregatesInput | EmailAliasScalarWhereWithAggregatesInput[]
    OR?: EmailAliasScalarWhereWithAggregatesInput[]
    NOT?: EmailAliasScalarWhereWithAggregatesInput | EmailAliasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAlias"> | string
    localPart?: StringWithAggregatesFilter<"EmailAlias"> | string
    targetMailboxId?: StringNullableWithAggregatesFilter<"EmailAlias"> | string | null
    externalTarget?: StringNullableWithAggregatesFilter<"EmailAlias"> | string | null
    isActive?: BoolWithAggregatesFilter<"EmailAlias"> | boolean
    domainId?: StringWithAggregatesFilter<"EmailAlias"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailAlias"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAlias"> | Date | string
  }

  export type DomainDNSWhereInput = {
    AND?: DomainDNSWhereInput | DomainDNSWhereInput[]
    OR?: DomainDNSWhereInput[]
    NOT?: DomainDNSWhereInput | DomainDNSWhereInput[]
    id?: StringFilter<"DomainDNS"> | string
    recordType?: EnumDNSRecordTypeFilter<"DomainDNS"> | $Enums.DNSRecordType
    name?: StringFilter<"DomainDNS"> | string
    value?: StringFilter<"DomainDNS"> | string
    priority?: IntNullableFilter<"DomainDNS"> | number | null
    ttl?: IntFilter<"DomainDNS"> | number
    description?: StringNullableFilter<"DomainDNS"> | string | null
    isRequired?: BoolFilter<"DomainDNS"> | boolean
    isVerified?: BoolFilter<"DomainDNS"> | boolean
    lastCheckedAt?: DateTimeNullableFilter<"DomainDNS"> | Date | string | null
    domainId?: StringFilter<"DomainDNS"> | string
    createdAt?: DateTimeFilter<"DomainDNS"> | Date | string
    updatedAt?: DateTimeFilter<"DomainDNS"> | Date | string
    domain?: XOR<EmailDomainRelationFilter, EmailDomainWhereInput>
  }

  export type DomainDNSOrderByWithRelationInput = {
    id?: SortOrder
    recordType?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priority?: SortOrderInput | SortOrder
    ttl?: SortOrder
    description?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isVerified?: SortOrder
    lastCheckedAt?: SortOrderInput | SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domain?: EmailDomainOrderByWithRelationInput
  }

  export type DomainDNSWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainDNSWhereInput | DomainDNSWhereInput[]
    OR?: DomainDNSWhereInput[]
    NOT?: DomainDNSWhereInput | DomainDNSWhereInput[]
    recordType?: EnumDNSRecordTypeFilter<"DomainDNS"> | $Enums.DNSRecordType
    name?: StringFilter<"DomainDNS"> | string
    value?: StringFilter<"DomainDNS"> | string
    priority?: IntNullableFilter<"DomainDNS"> | number | null
    ttl?: IntFilter<"DomainDNS"> | number
    description?: StringNullableFilter<"DomainDNS"> | string | null
    isRequired?: BoolFilter<"DomainDNS"> | boolean
    isVerified?: BoolFilter<"DomainDNS"> | boolean
    lastCheckedAt?: DateTimeNullableFilter<"DomainDNS"> | Date | string | null
    domainId?: StringFilter<"DomainDNS"> | string
    createdAt?: DateTimeFilter<"DomainDNS"> | Date | string
    updatedAt?: DateTimeFilter<"DomainDNS"> | Date | string
    domain?: XOR<EmailDomainRelationFilter, EmailDomainWhereInput>
  }, "id">

  export type DomainDNSOrderByWithAggregationInput = {
    id?: SortOrder
    recordType?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priority?: SortOrderInput | SortOrder
    ttl?: SortOrder
    description?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isVerified?: SortOrder
    lastCheckedAt?: SortOrderInput | SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainDNSCountOrderByAggregateInput
    _avg?: DomainDNSAvgOrderByAggregateInput
    _max?: DomainDNSMaxOrderByAggregateInput
    _min?: DomainDNSMinOrderByAggregateInput
    _sum?: DomainDNSSumOrderByAggregateInput
  }

  export type DomainDNSScalarWhereWithAggregatesInput = {
    AND?: DomainDNSScalarWhereWithAggregatesInput | DomainDNSScalarWhereWithAggregatesInput[]
    OR?: DomainDNSScalarWhereWithAggregatesInput[]
    NOT?: DomainDNSScalarWhereWithAggregatesInput | DomainDNSScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainDNS"> | string
    recordType?: EnumDNSRecordTypeWithAggregatesFilter<"DomainDNS"> | $Enums.DNSRecordType
    name?: StringWithAggregatesFilter<"DomainDNS"> | string
    value?: StringWithAggregatesFilter<"DomainDNS"> | string
    priority?: IntNullableWithAggregatesFilter<"DomainDNS"> | number | null
    ttl?: IntWithAggregatesFilter<"DomainDNS"> | number
    description?: StringNullableWithAggregatesFilter<"DomainDNS"> | string | null
    isRequired?: BoolWithAggregatesFilter<"DomainDNS"> | boolean
    isVerified?: BoolWithAggregatesFilter<"DomainDNS"> | boolean
    lastCheckedAt?: DateTimeNullableWithAggregatesFilter<"DomainDNS"> | Date | string | null
    domainId?: StringWithAggregatesFilter<"DomainDNS"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DomainDNS"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DomainDNS"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    messageId?: StringNullableFilter<"EmailLog"> | string | null
    direction?: StringFilter<"EmailLog"> | string
    fromAddress?: StringFilter<"EmailLog"> | string
    toAddress?: StringFilter<"EmailLog"> | string
    subject?: StringNullableFilter<"EmailLog"> | string | null
    status?: EnumEmailLogStatusFilter<"EmailLog"> | $Enums.EmailLogStatus
    errorMessage?: StringNullableFilter<"EmailLog"> | string | null
    sizeBytes?: IntNullableFilter<"EmailLog"> | number | null
    hasAttachments?: BoolFilter<"EmailLog"> | boolean
    smtpCode?: IntNullableFilter<"EmailLog"> | number | null
    smtpResponse?: StringNullableFilter<"EmailLog"> | string | null
    spamScore?: FloatNullableFilter<"EmailLog"> | number | null
    spamAction?: StringNullableFilter<"EmailLog"> | string | null
    processedAt?: DateTimeFilter<"EmailLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    domainId?: StringNullableFilter<"EmailLog"> | string | null
    mailboxId?: StringNullableFilter<"EmailLog"> | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrderInput | SortOrder
    direction?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    hasAttachments?: SortOrder
    smtpCode?: SortOrderInput | SortOrder
    smtpResponse?: SortOrderInput | SortOrder
    spamScore?: SortOrderInput | SortOrder
    spamAction?: SortOrderInput | SortOrder
    processedAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    mailboxId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    messageId?: StringNullableFilter<"EmailLog"> | string | null
    direction?: StringFilter<"EmailLog"> | string
    fromAddress?: StringFilter<"EmailLog"> | string
    toAddress?: StringFilter<"EmailLog"> | string
    subject?: StringNullableFilter<"EmailLog"> | string | null
    status?: EnumEmailLogStatusFilter<"EmailLog"> | $Enums.EmailLogStatus
    errorMessage?: StringNullableFilter<"EmailLog"> | string | null
    sizeBytes?: IntNullableFilter<"EmailLog"> | number | null
    hasAttachments?: BoolFilter<"EmailLog"> | boolean
    smtpCode?: IntNullableFilter<"EmailLog"> | number | null
    smtpResponse?: StringNullableFilter<"EmailLog"> | string | null
    spamScore?: FloatNullableFilter<"EmailLog"> | number | null
    spamAction?: StringNullableFilter<"EmailLog"> | string | null
    processedAt?: DateTimeFilter<"EmailLog"> | Date | string
    deliveredAt?: DateTimeNullableFilter<"EmailLog"> | Date | string | null
    domainId?: StringNullableFilter<"EmailLog"> | string | null
    mailboxId?: StringNullableFilter<"EmailLog"> | string | null
    createdAt?: DateTimeFilter<"EmailLog"> | Date | string
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrderInput | SortOrder
    direction?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    hasAttachments?: SortOrder
    smtpCode?: SortOrderInput | SortOrder
    smtpResponse?: SortOrderInput | SortOrder
    spamScore?: SortOrderInput | SortOrder
    spamAction?: SortOrderInput | SortOrder
    processedAt?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    mailboxId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _avg?: EmailLogAvgOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
    _sum?: EmailLogSumOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    messageId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    direction?: StringWithAggregatesFilter<"EmailLog"> | string
    fromAddress?: StringWithAggregatesFilter<"EmailLog"> | string
    toAddress?: StringWithAggregatesFilter<"EmailLog"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    status?: EnumEmailLogStatusWithAggregatesFilter<"EmailLog"> | $Enums.EmailLogStatus
    errorMessage?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    sizeBytes?: IntNullableWithAggregatesFilter<"EmailLog"> | number | null
    hasAttachments?: BoolWithAggregatesFilter<"EmailLog"> | boolean
    smtpCode?: IntNullableWithAggregatesFilter<"EmailLog"> | number | null
    smtpResponse?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    spamScore?: FloatNullableWithAggregatesFilter<"EmailLog"> | number | null
    spamAction?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    processedAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"EmailLog"> | Date | string | null
    domainId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    mailboxId?: StringNullableWithAggregatesFilter<"EmailLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
  }

  export type EmailQuarantinedWhereInput = {
    AND?: EmailQuarantinedWhereInput | EmailQuarantinedWhereInput[]
    OR?: EmailQuarantinedWhereInput[]
    NOT?: EmailQuarantinedWhereInput | EmailQuarantinedWhereInput[]
    id?: StringFilter<"EmailQuarantined"> | string
    messageId?: StringFilter<"EmailQuarantined"> | string
    fromAddress?: StringFilter<"EmailQuarantined"> | string
    toAddress?: StringFilter<"EmailQuarantined"> | string
    subject?: StringNullableFilter<"EmailQuarantined"> | string | null
    reason?: StringFilter<"EmailQuarantined"> | string
    spamScore?: FloatNullableFilter<"EmailQuarantined"> | number | null
    rawHeaders?: StringNullableFilter<"EmailQuarantined"> | string | null
    previewText?: StringNullableFilter<"EmailQuarantined"> | string | null
    releasedAt?: DateTimeNullableFilter<"EmailQuarantined"> | Date | string | null
    releasedBy?: StringNullableFilter<"EmailQuarantined"> | string | null
    deletedAt?: DateTimeNullableFilter<"EmailQuarantined"> | Date | string | null
    domainId?: StringFilter<"EmailQuarantined"> | string
    createdAt?: DateTimeFilter<"EmailQuarantined"> | Date | string
    expiresAt?: DateTimeFilter<"EmailQuarantined"> | Date | string
  }

  export type EmailQuarantinedOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrderInput | SortOrder
    reason?: SortOrder
    spamScore?: SortOrderInput | SortOrder
    rawHeaders?: SortOrderInput | SortOrder
    previewText?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    releasedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailQuarantinedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailQuarantinedWhereInput | EmailQuarantinedWhereInput[]
    OR?: EmailQuarantinedWhereInput[]
    NOT?: EmailQuarantinedWhereInput | EmailQuarantinedWhereInput[]
    messageId?: StringFilter<"EmailQuarantined"> | string
    fromAddress?: StringFilter<"EmailQuarantined"> | string
    toAddress?: StringFilter<"EmailQuarantined"> | string
    subject?: StringNullableFilter<"EmailQuarantined"> | string | null
    reason?: StringFilter<"EmailQuarantined"> | string
    spamScore?: FloatNullableFilter<"EmailQuarantined"> | number | null
    rawHeaders?: StringNullableFilter<"EmailQuarantined"> | string | null
    previewText?: StringNullableFilter<"EmailQuarantined"> | string | null
    releasedAt?: DateTimeNullableFilter<"EmailQuarantined"> | Date | string | null
    releasedBy?: StringNullableFilter<"EmailQuarantined"> | string | null
    deletedAt?: DateTimeNullableFilter<"EmailQuarantined"> | Date | string | null
    domainId?: StringFilter<"EmailQuarantined"> | string
    createdAt?: DateTimeFilter<"EmailQuarantined"> | Date | string
    expiresAt?: DateTimeFilter<"EmailQuarantined"> | Date | string
  }, "id">

  export type EmailQuarantinedOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrderInput | SortOrder
    reason?: SortOrder
    spamScore?: SortOrderInput | SortOrder
    rawHeaders?: SortOrderInput | SortOrder
    previewText?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    releasedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: EmailQuarantinedCountOrderByAggregateInput
    _avg?: EmailQuarantinedAvgOrderByAggregateInput
    _max?: EmailQuarantinedMaxOrderByAggregateInput
    _min?: EmailQuarantinedMinOrderByAggregateInput
    _sum?: EmailQuarantinedSumOrderByAggregateInput
  }

  export type EmailQuarantinedScalarWhereWithAggregatesInput = {
    AND?: EmailQuarantinedScalarWhereWithAggregatesInput | EmailQuarantinedScalarWhereWithAggregatesInput[]
    OR?: EmailQuarantinedScalarWhereWithAggregatesInput[]
    NOT?: EmailQuarantinedScalarWhereWithAggregatesInput | EmailQuarantinedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailQuarantined"> | string
    messageId?: StringWithAggregatesFilter<"EmailQuarantined"> | string
    fromAddress?: StringWithAggregatesFilter<"EmailQuarantined"> | string
    toAddress?: StringWithAggregatesFilter<"EmailQuarantined"> | string
    subject?: StringNullableWithAggregatesFilter<"EmailQuarantined"> | string | null
    reason?: StringWithAggregatesFilter<"EmailQuarantined"> | string
    spamScore?: FloatNullableWithAggregatesFilter<"EmailQuarantined"> | number | null
    rawHeaders?: StringNullableWithAggregatesFilter<"EmailQuarantined"> | string | null
    previewText?: StringNullableWithAggregatesFilter<"EmailQuarantined"> | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"EmailQuarantined"> | Date | string | null
    releasedBy?: StringNullableWithAggregatesFilter<"EmailQuarantined"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmailQuarantined"> | Date | string | null
    domainId?: StringWithAggregatesFilter<"EmailQuarantined"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailQuarantined"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailQuarantined"> | Date | string
  }

  export type EmailTemplateWhereInput = {
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    id?: StringFilter<"EmailTemplate"> | string
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    htmlBody?: StringNullableFilter<"EmailTemplate"> | string | null
    textBody?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: EnumEmailTemplateCategoryFilter<"EmailTemplate"> | $Enums.EmailTemplateCategory
    placeholders?: StringNullableListFilter<"EmailTemplate">
    usageCount?: IntFilter<"EmailTemplate"> | number
    lastUsedAt?: DateTimeNullableFilter<"EmailTemplate"> | Date | string | null
    isShared?: BoolFilter<"EmailTemplate"> | boolean
    userId?: StringFilter<"EmailTemplate"> | string
    companyId?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }

  export type EmailTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrderInput | SortOrder
    textBody?: SortOrderInput | SortOrder
    category?: SortOrder
    placeholders?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isShared?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    OR?: EmailTemplateWhereInput[]
    NOT?: EmailTemplateWhereInput | EmailTemplateWhereInput[]
    name?: StringFilter<"EmailTemplate"> | string
    subject?: StringFilter<"EmailTemplate"> | string
    htmlBody?: StringNullableFilter<"EmailTemplate"> | string | null
    textBody?: StringNullableFilter<"EmailTemplate"> | string | null
    category?: EnumEmailTemplateCategoryFilter<"EmailTemplate"> | $Enums.EmailTemplateCategory
    placeholders?: StringNullableListFilter<"EmailTemplate">
    usageCount?: IntFilter<"EmailTemplate"> | number
    lastUsedAt?: DateTimeNullableFilter<"EmailTemplate"> | Date | string | null
    isShared?: BoolFilter<"EmailTemplate"> | boolean
    userId?: StringFilter<"EmailTemplate"> | string
    companyId?: StringNullableFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTemplate"> | Date | string
  }, "id">

  export type EmailTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrderInput | SortOrder
    textBody?: SortOrderInput | SortOrder
    category?: SortOrder
    placeholders?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isShared?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTemplateCountOrderByAggregateInput
    _avg?: EmailTemplateAvgOrderByAggregateInput
    _max?: EmailTemplateMaxOrderByAggregateInput
    _min?: EmailTemplateMinOrderByAggregateInput
    _sum?: EmailTemplateSumOrderByAggregateInput
  }

  export type EmailTemplateScalarWhereWithAggregatesInput = {
    AND?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    OR?: EmailTemplateScalarWhereWithAggregatesInput[]
    NOT?: EmailTemplateScalarWhereWithAggregatesInput | EmailTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTemplate"> | string
    name?: StringWithAggregatesFilter<"EmailTemplate"> | string
    subject?: StringWithAggregatesFilter<"EmailTemplate"> | string
    htmlBody?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    textBody?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    category?: EnumEmailTemplateCategoryWithAggregatesFilter<"EmailTemplate"> | $Enums.EmailTemplateCategory
    placeholders?: StringNullableListFilter<"EmailTemplate">
    usageCount?: IntWithAggregatesFilter<"EmailTemplate"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"EmailTemplate"> | Date | string | null
    isShared?: BoolWithAggregatesFilter<"EmailTemplate"> | boolean
    userId?: StringWithAggregatesFilter<"EmailTemplate"> | string
    companyId?: StringNullableWithAggregatesFilter<"EmailTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTemplate"> | Date | string
  }

  export type VacationResponderWhereInput = {
    AND?: VacationResponderWhereInput | VacationResponderWhereInput[]
    OR?: VacationResponderWhereInput[]
    NOT?: VacationResponderWhereInput | VacationResponderWhereInput[]
    id?: StringFilter<"VacationResponder"> | string
    startDate?: DateTimeFilter<"VacationResponder"> | Date | string
    endDate?: DateTimeFilter<"VacationResponder"> | Date | string
    subject?: StringFilter<"VacationResponder"> | string
    message?: StringFilter<"VacationResponder"> | string
    isActive?: BoolFilter<"VacationResponder"> | boolean
    onlyContacts?: BoolFilter<"VacationResponder"> | boolean
    onlyOnce?: BoolFilter<"VacationResponder"> | boolean
    excludedDomains?: StringNullableListFilter<"VacationResponder">
    respondedTo?: StringNullableListFilter<"VacationResponder">
    userId?: StringFilter<"VacationResponder"> | string
    createdAt?: DateTimeFilter<"VacationResponder"> | Date | string
    updatedAt?: DateTimeFilter<"VacationResponder"> | Date | string
  }

  export type VacationResponderOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    onlyContacts?: SortOrder
    onlyOnce?: SortOrder
    excludedDomains?: SortOrder
    respondedTo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VacationResponderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: VacationResponderWhereInput | VacationResponderWhereInput[]
    OR?: VacationResponderWhereInput[]
    NOT?: VacationResponderWhereInput | VacationResponderWhereInput[]
    startDate?: DateTimeFilter<"VacationResponder"> | Date | string
    endDate?: DateTimeFilter<"VacationResponder"> | Date | string
    subject?: StringFilter<"VacationResponder"> | string
    message?: StringFilter<"VacationResponder"> | string
    isActive?: BoolFilter<"VacationResponder"> | boolean
    onlyContacts?: BoolFilter<"VacationResponder"> | boolean
    onlyOnce?: BoolFilter<"VacationResponder"> | boolean
    excludedDomains?: StringNullableListFilter<"VacationResponder">
    respondedTo?: StringNullableListFilter<"VacationResponder">
    createdAt?: DateTimeFilter<"VacationResponder"> | Date | string
    updatedAt?: DateTimeFilter<"VacationResponder"> | Date | string
  }, "id" | "userId">

  export type VacationResponderOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    onlyContacts?: SortOrder
    onlyOnce?: SortOrder
    excludedDomains?: SortOrder
    respondedTo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VacationResponderCountOrderByAggregateInput
    _max?: VacationResponderMaxOrderByAggregateInput
    _min?: VacationResponderMinOrderByAggregateInput
  }

  export type VacationResponderScalarWhereWithAggregatesInput = {
    AND?: VacationResponderScalarWhereWithAggregatesInput | VacationResponderScalarWhereWithAggregatesInput[]
    OR?: VacationResponderScalarWhereWithAggregatesInput[]
    NOT?: VacationResponderScalarWhereWithAggregatesInput | VacationResponderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VacationResponder"> | string
    startDate?: DateTimeWithAggregatesFilter<"VacationResponder"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"VacationResponder"> | Date | string
    subject?: StringWithAggregatesFilter<"VacationResponder"> | string
    message?: StringWithAggregatesFilter<"VacationResponder"> | string
    isActive?: BoolWithAggregatesFilter<"VacationResponder"> | boolean
    onlyContacts?: BoolWithAggregatesFilter<"VacationResponder"> | boolean
    onlyOnce?: BoolWithAggregatesFilter<"VacationResponder"> | boolean
    excludedDomains?: StringNullableListFilter<"VacationResponder">
    respondedTo?: StringNullableListFilter<"VacationResponder">
    userId?: StringWithAggregatesFilter<"VacationResponder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VacationResponder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VacationResponder"> | Date | string
  }

  export type EmailTrackingWhereInput = {
    AND?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    OR?: EmailTrackingWhereInput[]
    NOT?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    id?: StringFilter<"EmailTracking"> | string
    trackingId?: StringFilter<"EmailTracking"> | string
    emailId?: StringNullableFilter<"EmailTracking"> | string | null
    outboxId?: StringNullableFilter<"EmailTracking"> | string | null
    subject?: StringFilter<"EmailTracking"> | string
    recipientEmail?: StringFilter<"EmailTracking"> | string
    openCount?: IntFilter<"EmailTracking"> | number
    clickCount?: IntFilter<"EmailTracking"> | number
    firstOpenedAt?: DateTimeNullableFilter<"EmailTracking"> | Date | string | null
    lastOpenedAt?: DateTimeNullableFilter<"EmailTracking"> | Date | string | null
    userId?: StringFilter<"EmailTracking"> | string
    createdAt?: DateTimeFilter<"EmailTracking"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTracking"> | Date | string
    opens?: EmailTrackingEventListRelationFilter
    clicks?: EmailLinkClickListRelationFilter
  }

  export type EmailTrackingOrderByWithRelationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    emailId?: SortOrderInput | SortOrder
    outboxId?: SortOrderInput | SortOrder
    subject?: SortOrder
    recipientEmail?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    firstOpenedAt?: SortOrderInput | SortOrder
    lastOpenedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opens?: EmailTrackingEventOrderByRelationAggregateInput
    clicks?: EmailLinkClickOrderByRelationAggregateInput
  }

  export type EmailTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackingId?: string
    AND?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    OR?: EmailTrackingWhereInput[]
    NOT?: EmailTrackingWhereInput | EmailTrackingWhereInput[]
    emailId?: StringNullableFilter<"EmailTracking"> | string | null
    outboxId?: StringNullableFilter<"EmailTracking"> | string | null
    subject?: StringFilter<"EmailTracking"> | string
    recipientEmail?: StringFilter<"EmailTracking"> | string
    openCount?: IntFilter<"EmailTracking"> | number
    clickCount?: IntFilter<"EmailTracking"> | number
    firstOpenedAt?: DateTimeNullableFilter<"EmailTracking"> | Date | string | null
    lastOpenedAt?: DateTimeNullableFilter<"EmailTracking"> | Date | string | null
    userId?: StringFilter<"EmailTracking"> | string
    createdAt?: DateTimeFilter<"EmailTracking"> | Date | string
    updatedAt?: DateTimeFilter<"EmailTracking"> | Date | string
    opens?: EmailTrackingEventListRelationFilter
    clicks?: EmailLinkClickListRelationFilter
  }, "id" | "trackingId">

  export type EmailTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    emailId?: SortOrderInput | SortOrder
    outboxId?: SortOrderInput | SortOrder
    subject?: SortOrder
    recipientEmail?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    firstOpenedAt?: SortOrderInput | SortOrder
    lastOpenedAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailTrackingCountOrderByAggregateInput
    _avg?: EmailTrackingAvgOrderByAggregateInput
    _max?: EmailTrackingMaxOrderByAggregateInput
    _min?: EmailTrackingMinOrderByAggregateInput
    _sum?: EmailTrackingSumOrderByAggregateInput
  }

  export type EmailTrackingScalarWhereWithAggregatesInput = {
    AND?: EmailTrackingScalarWhereWithAggregatesInput | EmailTrackingScalarWhereWithAggregatesInput[]
    OR?: EmailTrackingScalarWhereWithAggregatesInput[]
    NOT?: EmailTrackingScalarWhereWithAggregatesInput | EmailTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTracking"> | string
    trackingId?: StringWithAggregatesFilter<"EmailTracking"> | string
    emailId?: StringNullableWithAggregatesFilter<"EmailTracking"> | string | null
    outboxId?: StringNullableWithAggregatesFilter<"EmailTracking"> | string | null
    subject?: StringWithAggregatesFilter<"EmailTracking"> | string
    recipientEmail?: StringWithAggregatesFilter<"EmailTracking"> | string
    openCount?: IntWithAggregatesFilter<"EmailTracking"> | number
    clickCount?: IntWithAggregatesFilter<"EmailTracking"> | number
    firstOpenedAt?: DateTimeNullableWithAggregatesFilter<"EmailTracking"> | Date | string | null
    lastOpenedAt?: DateTimeNullableWithAggregatesFilter<"EmailTracking"> | Date | string | null
    userId?: StringWithAggregatesFilter<"EmailTracking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailTracking"> | Date | string
  }

  export type EmailTrackingEventWhereInput = {
    AND?: EmailTrackingEventWhereInput | EmailTrackingEventWhereInput[]
    OR?: EmailTrackingEventWhereInput[]
    NOT?: EmailTrackingEventWhereInput | EmailTrackingEventWhereInput[]
    id?: StringFilter<"EmailTrackingEvent"> | string
    trackingId?: StringFilter<"EmailTrackingEvent"> | string
    eventType?: StringFilter<"EmailTrackingEvent"> | string
    ipAddress?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    userAgent?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    device?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    browser?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    country?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    city?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    createdAt?: DateTimeFilter<"EmailTrackingEvent"> | Date | string
    tracking?: XOR<EmailTrackingRelationFilter, EmailTrackingWhereInput>
  }

  export type EmailTrackingEventOrderByWithRelationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tracking?: EmailTrackingOrderByWithRelationInput
  }

  export type EmailTrackingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailTrackingEventWhereInput | EmailTrackingEventWhereInput[]
    OR?: EmailTrackingEventWhereInput[]
    NOT?: EmailTrackingEventWhereInput | EmailTrackingEventWhereInput[]
    trackingId?: StringFilter<"EmailTrackingEvent"> | string
    eventType?: StringFilter<"EmailTrackingEvent"> | string
    ipAddress?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    userAgent?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    device?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    browser?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    country?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    city?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    createdAt?: DateTimeFilter<"EmailTrackingEvent"> | Date | string
    tracking?: XOR<EmailTrackingRelationFilter, EmailTrackingWhereInput>
  }, "id">

  export type EmailTrackingEventOrderByWithAggregationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EmailTrackingEventCountOrderByAggregateInput
    _max?: EmailTrackingEventMaxOrderByAggregateInput
    _min?: EmailTrackingEventMinOrderByAggregateInput
  }

  export type EmailTrackingEventScalarWhereWithAggregatesInput = {
    AND?: EmailTrackingEventScalarWhereWithAggregatesInput | EmailTrackingEventScalarWhereWithAggregatesInput[]
    OR?: EmailTrackingEventScalarWhereWithAggregatesInput[]
    NOT?: EmailTrackingEventScalarWhereWithAggregatesInput | EmailTrackingEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailTrackingEvent"> | string
    trackingId?: StringWithAggregatesFilter<"EmailTrackingEvent"> | string
    eventType?: StringWithAggregatesFilter<"EmailTrackingEvent"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"EmailTrackingEvent"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"EmailTrackingEvent"> | string | null
    device?: StringNullableWithAggregatesFilter<"EmailTrackingEvent"> | string | null
    browser?: StringNullableWithAggregatesFilter<"EmailTrackingEvent"> | string | null
    country?: StringNullableWithAggregatesFilter<"EmailTrackingEvent"> | string | null
    city?: StringNullableWithAggregatesFilter<"EmailTrackingEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailTrackingEvent"> | Date | string
  }

  export type EmailLinkClickWhereInput = {
    AND?: EmailLinkClickWhereInput | EmailLinkClickWhereInput[]
    OR?: EmailLinkClickWhereInput[]
    NOT?: EmailLinkClickWhereInput | EmailLinkClickWhereInput[]
    id?: StringFilter<"EmailLinkClick"> | string
    trackingId?: StringFilter<"EmailLinkClick"> | string
    originalUrl?: StringFilter<"EmailLinkClick"> | string
    clickCount?: IntFilter<"EmailLinkClick"> | number
    ipAddress?: StringNullableFilter<"EmailLinkClick"> | string | null
    userAgent?: StringNullableFilter<"EmailLinkClick"> | string | null
    firstClickedAt?: DateTimeFilter<"EmailLinkClick"> | Date | string
    lastClickedAt?: DateTimeFilter<"EmailLinkClick"> | Date | string
    tracking?: XOR<EmailTrackingRelationFilter, EmailTrackingWhereInput>
  }

  export type EmailLinkClickOrderByWithRelationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    firstClickedAt?: SortOrder
    lastClickedAt?: SortOrder
    tracking?: EmailTrackingOrderByWithRelationInput
  }

  export type EmailLinkClickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackingId_originalUrl?: EmailLinkClickTrackingIdOriginalUrlCompoundUniqueInput
    AND?: EmailLinkClickWhereInput | EmailLinkClickWhereInput[]
    OR?: EmailLinkClickWhereInput[]
    NOT?: EmailLinkClickWhereInput | EmailLinkClickWhereInput[]
    trackingId?: StringFilter<"EmailLinkClick"> | string
    originalUrl?: StringFilter<"EmailLinkClick"> | string
    clickCount?: IntFilter<"EmailLinkClick"> | number
    ipAddress?: StringNullableFilter<"EmailLinkClick"> | string | null
    userAgent?: StringNullableFilter<"EmailLinkClick"> | string | null
    firstClickedAt?: DateTimeFilter<"EmailLinkClick"> | Date | string
    lastClickedAt?: DateTimeFilter<"EmailLinkClick"> | Date | string
    tracking?: XOR<EmailTrackingRelationFilter, EmailTrackingWhereInput>
  }, "id" | "trackingId_originalUrl">

  export type EmailLinkClickOrderByWithAggregationInput = {
    id?: SortOrder
    trackingId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    firstClickedAt?: SortOrder
    lastClickedAt?: SortOrder
    _count?: EmailLinkClickCountOrderByAggregateInput
    _avg?: EmailLinkClickAvgOrderByAggregateInput
    _max?: EmailLinkClickMaxOrderByAggregateInput
    _min?: EmailLinkClickMinOrderByAggregateInput
    _sum?: EmailLinkClickSumOrderByAggregateInput
  }

  export type EmailLinkClickScalarWhereWithAggregatesInput = {
    AND?: EmailLinkClickScalarWhereWithAggregatesInput | EmailLinkClickScalarWhereWithAggregatesInput[]
    OR?: EmailLinkClickScalarWhereWithAggregatesInput[]
    NOT?: EmailLinkClickScalarWhereWithAggregatesInput | EmailLinkClickScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLinkClick"> | string
    trackingId?: StringWithAggregatesFilter<"EmailLinkClick"> | string
    originalUrl?: StringWithAggregatesFilter<"EmailLinkClick"> | string
    clickCount?: IntWithAggregatesFilter<"EmailLinkClick"> | number
    ipAddress?: StringNullableWithAggregatesFilter<"EmailLinkClick"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"EmailLinkClick"> | string | null
    firstClickedAt?: DateTimeWithAggregatesFilter<"EmailLinkClick"> | Date | string
    lastClickedAt?: DateTimeWithAggregatesFilter<"EmailLinkClick"> | Date | string
  }

  export type MailMergeWhereInput = {
    AND?: MailMergeWhereInput | MailMergeWhereInput[]
    OR?: MailMergeWhereInput[]
    NOT?: MailMergeWhereInput | MailMergeWhereInput[]
    id?: StringFilter<"MailMerge"> | string
    name?: StringFilter<"MailMerge"> | string
    subject?: StringFilter<"MailMerge"> | string
    htmlBody?: StringNullableFilter<"MailMerge"> | string | null
    textBody?: StringNullableFilter<"MailMerge"> | string | null
    recipientCount?: IntFilter<"MailMerge"> | number
    recipients?: JsonFilter<"MailMerge">
    status?: EnumMailMergeStatusFilter<"MailMerge"> | $Enums.MailMergeStatus
    scheduledAt?: DateTimeNullableFilter<"MailMerge"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"MailMerge"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"MailMerge"> | Date | string | null
    sentCount?: IntFilter<"MailMerge"> | number
    failedCount?: IntFilter<"MailMerge"> | number
    userId?: StringFilter<"MailMerge"> | string
    createdAt?: DateTimeFilter<"MailMerge"> | Date | string
    updatedAt?: DateTimeFilter<"MailMerge"> | Date | string
  }

  export type MailMergeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrderInput | SortOrder
    textBody?: SortOrderInput | SortOrder
    recipientCount?: SortOrder
    recipients?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailMergeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MailMergeWhereInput | MailMergeWhereInput[]
    OR?: MailMergeWhereInput[]
    NOT?: MailMergeWhereInput | MailMergeWhereInput[]
    name?: StringFilter<"MailMerge"> | string
    subject?: StringFilter<"MailMerge"> | string
    htmlBody?: StringNullableFilter<"MailMerge"> | string | null
    textBody?: StringNullableFilter<"MailMerge"> | string | null
    recipientCount?: IntFilter<"MailMerge"> | number
    recipients?: JsonFilter<"MailMerge">
    status?: EnumMailMergeStatusFilter<"MailMerge"> | $Enums.MailMergeStatus
    scheduledAt?: DateTimeNullableFilter<"MailMerge"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"MailMerge"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"MailMerge"> | Date | string | null
    sentCount?: IntFilter<"MailMerge"> | number
    failedCount?: IntFilter<"MailMerge"> | number
    userId?: StringFilter<"MailMerge"> | string
    createdAt?: DateTimeFilter<"MailMerge"> | Date | string
    updatedAt?: DateTimeFilter<"MailMerge"> | Date | string
  }, "id">

  export type MailMergeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrderInput | SortOrder
    textBody?: SortOrderInput | SortOrder
    recipientCount?: SortOrder
    recipients?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MailMergeCountOrderByAggregateInput
    _avg?: MailMergeAvgOrderByAggregateInput
    _max?: MailMergeMaxOrderByAggregateInput
    _min?: MailMergeMinOrderByAggregateInput
    _sum?: MailMergeSumOrderByAggregateInput
  }

  export type MailMergeScalarWhereWithAggregatesInput = {
    AND?: MailMergeScalarWhereWithAggregatesInput | MailMergeScalarWhereWithAggregatesInput[]
    OR?: MailMergeScalarWhereWithAggregatesInput[]
    NOT?: MailMergeScalarWhereWithAggregatesInput | MailMergeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MailMerge"> | string
    name?: StringWithAggregatesFilter<"MailMerge"> | string
    subject?: StringWithAggregatesFilter<"MailMerge"> | string
    htmlBody?: StringNullableWithAggregatesFilter<"MailMerge"> | string | null
    textBody?: StringNullableWithAggregatesFilter<"MailMerge"> | string | null
    recipientCount?: IntWithAggregatesFilter<"MailMerge"> | number
    recipients?: JsonWithAggregatesFilter<"MailMerge">
    status?: EnumMailMergeStatusWithAggregatesFilter<"MailMerge"> | $Enums.MailMergeStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"MailMerge"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"MailMerge"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"MailMerge"> | Date | string | null
    sentCount?: IntWithAggregatesFilter<"MailMerge"> | number
    failedCount?: IntWithAggregatesFilter<"MailMerge"> | number
    userId?: StringWithAggregatesFilter<"MailMerge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MailMerge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MailMerge"> | Date | string
  }

  export type EmailHostingSettingsWhereInput = {
    AND?: EmailHostingSettingsWhereInput | EmailHostingSettingsWhereInput[]
    OR?: EmailHostingSettingsWhereInput[]
    NOT?: EmailHostingSettingsWhereInput | EmailHostingSettingsWhereInput[]
    id?: StringFilter<"EmailHostingSettings"> | string
    defaultDomainId?: StringNullableFilter<"EmailHostingSettings"> | string | null
    emailFormat?: StringFilter<"EmailHostingSettings"> | string
    autoProvisionEnabled?: BoolFilter<"EmailHostingSettings"> | boolean
    defaultQuotaMb?: IntFilter<"EmailHostingSettings"> | number
    defaultMaxSendPerDay?: IntFilter<"EmailHostingSettings"> | number
    notifyOnProvision?: BoolFilter<"EmailHostingSettings"> | boolean
    welcomeEmailTemplate?: StringNullableFilter<"EmailHostingSettings"> | string | null
    requireStrongPassword?: BoolFilter<"EmailHostingSettings"> | boolean
    minPasswordLength?: IntFilter<"EmailHostingSettings"> | number
    companyId?: StringFilter<"EmailHostingSettings"> | string
    createdAt?: DateTimeFilter<"EmailHostingSettings"> | Date | string
    updatedAt?: DateTimeFilter<"EmailHostingSettings"> | Date | string
  }

  export type EmailHostingSettingsOrderByWithRelationInput = {
    id?: SortOrder
    defaultDomainId?: SortOrderInput | SortOrder
    emailFormat?: SortOrder
    autoProvisionEnabled?: SortOrder
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    notifyOnProvision?: SortOrder
    welcomeEmailTemplate?: SortOrderInput | SortOrder
    requireStrongPassword?: SortOrder
    minPasswordLength?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailHostingSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    companyId?: string
    AND?: EmailHostingSettingsWhereInput | EmailHostingSettingsWhereInput[]
    OR?: EmailHostingSettingsWhereInput[]
    NOT?: EmailHostingSettingsWhereInput | EmailHostingSettingsWhereInput[]
    defaultDomainId?: StringNullableFilter<"EmailHostingSettings"> | string | null
    emailFormat?: StringFilter<"EmailHostingSettings"> | string
    autoProvisionEnabled?: BoolFilter<"EmailHostingSettings"> | boolean
    defaultQuotaMb?: IntFilter<"EmailHostingSettings"> | number
    defaultMaxSendPerDay?: IntFilter<"EmailHostingSettings"> | number
    notifyOnProvision?: BoolFilter<"EmailHostingSettings"> | boolean
    welcomeEmailTemplate?: StringNullableFilter<"EmailHostingSettings"> | string | null
    requireStrongPassword?: BoolFilter<"EmailHostingSettings"> | boolean
    minPasswordLength?: IntFilter<"EmailHostingSettings"> | number
    createdAt?: DateTimeFilter<"EmailHostingSettings"> | Date | string
    updatedAt?: DateTimeFilter<"EmailHostingSettings"> | Date | string
  }, "id" | "companyId">

  export type EmailHostingSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    defaultDomainId?: SortOrderInput | SortOrder
    emailFormat?: SortOrder
    autoProvisionEnabled?: SortOrder
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    notifyOnProvision?: SortOrder
    welcomeEmailTemplate?: SortOrderInput | SortOrder
    requireStrongPassword?: SortOrder
    minPasswordLength?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailHostingSettingsCountOrderByAggregateInput
    _avg?: EmailHostingSettingsAvgOrderByAggregateInput
    _max?: EmailHostingSettingsMaxOrderByAggregateInput
    _min?: EmailHostingSettingsMinOrderByAggregateInput
    _sum?: EmailHostingSettingsSumOrderByAggregateInput
  }

  export type EmailHostingSettingsScalarWhereWithAggregatesInput = {
    AND?: EmailHostingSettingsScalarWhereWithAggregatesInput | EmailHostingSettingsScalarWhereWithAggregatesInput[]
    OR?: EmailHostingSettingsScalarWhereWithAggregatesInput[]
    NOT?: EmailHostingSettingsScalarWhereWithAggregatesInput | EmailHostingSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailHostingSettings"> | string
    defaultDomainId?: StringNullableWithAggregatesFilter<"EmailHostingSettings"> | string | null
    emailFormat?: StringWithAggregatesFilter<"EmailHostingSettings"> | string
    autoProvisionEnabled?: BoolWithAggregatesFilter<"EmailHostingSettings"> | boolean
    defaultQuotaMb?: IntWithAggregatesFilter<"EmailHostingSettings"> | number
    defaultMaxSendPerDay?: IntWithAggregatesFilter<"EmailHostingSettings"> | number
    notifyOnProvision?: BoolWithAggregatesFilter<"EmailHostingSettings"> | boolean
    welcomeEmailTemplate?: StringNullableWithAggregatesFilter<"EmailHostingSettings"> | string | null
    requireStrongPassword?: BoolWithAggregatesFilter<"EmailHostingSettings"> | boolean
    minPasswordLength?: IntWithAggregatesFilter<"EmailHostingSettings"> | number
    companyId?: StringWithAggregatesFilter<"EmailHostingSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailHostingSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailHostingSettings"> | Date | string
  }

  export type MailboxAuditLogWhereInput = {
    AND?: MailboxAuditLogWhereInput | MailboxAuditLogWhereInput[]
    OR?: MailboxAuditLogWhereInput[]
    NOT?: MailboxAuditLogWhereInput | MailboxAuditLogWhereInput[]
    id?: StringFilter<"MailboxAuditLog"> | string
    action?: EnumMailboxAuditActionFilter<"MailboxAuditLog"> | $Enums.MailboxAuditAction
    mailboxId?: StringNullableFilter<"MailboxAuditLog"> | string | null
    userId?: StringNullableFilter<"MailboxAuditLog"> | string | null
    domainId?: StringNullableFilter<"MailboxAuditLog"> | string | null
    performedById?: StringNullableFilter<"MailboxAuditLog"> | string | null
    details?: JsonNullableFilter<"MailboxAuditLog">
    ipAddress?: StringNullableFilter<"MailboxAuditLog"> | string | null
    userAgent?: StringNullableFilter<"MailboxAuditLog"> | string | null
    success?: BoolFilter<"MailboxAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"MailboxAuditLog"> | string | null
    companyId?: StringFilter<"MailboxAuditLog"> | string
    createdAt?: DateTimeFilter<"MailboxAuditLog"> | Date | string
  }

  export type MailboxAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    mailboxId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    performedById?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type MailboxAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MailboxAuditLogWhereInput | MailboxAuditLogWhereInput[]
    OR?: MailboxAuditLogWhereInput[]
    NOT?: MailboxAuditLogWhereInput | MailboxAuditLogWhereInput[]
    action?: EnumMailboxAuditActionFilter<"MailboxAuditLog"> | $Enums.MailboxAuditAction
    mailboxId?: StringNullableFilter<"MailboxAuditLog"> | string | null
    userId?: StringNullableFilter<"MailboxAuditLog"> | string | null
    domainId?: StringNullableFilter<"MailboxAuditLog"> | string | null
    performedById?: StringNullableFilter<"MailboxAuditLog"> | string | null
    details?: JsonNullableFilter<"MailboxAuditLog">
    ipAddress?: StringNullableFilter<"MailboxAuditLog"> | string | null
    userAgent?: StringNullableFilter<"MailboxAuditLog"> | string | null
    success?: BoolFilter<"MailboxAuditLog"> | boolean
    errorMessage?: StringNullableFilter<"MailboxAuditLog"> | string | null
    companyId?: StringFilter<"MailboxAuditLog"> | string
    createdAt?: DateTimeFilter<"MailboxAuditLog"> | Date | string
  }, "id">

  export type MailboxAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    mailboxId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    domainId?: SortOrderInput | SortOrder
    performedById?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    _count?: MailboxAuditLogCountOrderByAggregateInput
    _max?: MailboxAuditLogMaxOrderByAggregateInput
    _min?: MailboxAuditLogMinOrderByAggregateInput
  }

  export type MailboxAuditLogScalarWhereWithAggregatesInput = {
    AND?: MailboxAuditLogScalarWhereWithAggregatesInput | MailboxAuditLogScalarWhereWithAggregatesInput[]
    OR?: MailboxAuditLogScalarWhereWithAggregatesInput[]
    NOT?: MailboxAuditLogScalarWhereWithAggregatesInput | MailboxAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MailboxAuditLog"> | string
    action?: EnumMailboxAuditActionWithAggregatesFilter<"MailboxAuditLog"> | $Enums.MailboxAuditAction
    mailboxId?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    domainId?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    performedById?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"MailboxAuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    success?: BoolWithAggregatesFilter<"MailboxAuditLog"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"MailboxAuditLog"> | string | null
    companyId?: StringWithAggregatesFilter<"MailboxAuditLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MailboxAuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutUsersInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    templates?: TemplateCreateNestedManyWithoutCompanyInput
    assets?: AssetCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCompanyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUpdateManyWithoutCompanyNestedInput
    assets?: AssetUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCompanyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutClientsInput
    documents?: DocumentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
    documents?: DocumentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
    client?: ClientCreateNestedOneWithoutDocumentsInput
    createdBy: UserCreateNestedOneWithoutCreatedDocumentsInput
    items?: DocumentItemCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    clientId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DocumentItemUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    items?: DocumentItemUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DocumentItemUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    clientId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentItemCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutItemsInput
  }

  export type DocumentItemUncheckedCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    documentId: string
    createdAt?: Date | string
  }

  export type DocumentItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutItemsNestedInput
  }

  export type DocumentItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentItemCreateManyInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    documentId: string
    createdAt?: Date | string
  }

  export type DocumentItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    description?: string | null
    isDefault?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    description?: string | null
    isDefault?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateManyInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    description?: string | null
    isDefault?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateInput = {
    id?: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutAssetsInput
  }

  export type AssetUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    companyId: string
    createdAt?: Date | string
  }

  export type AssetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutAssetsNestedInput
  }

  export type AssetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetCreateManyInput = {
    id?: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    companyId: string
    createdAt?: Date | string
  }

  export type AssetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCreateInput = {
    id?: string
    messageId: string
    folder?: $Enums.EmailFolder
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailCreatetoAddressesInput | string[]
    ccAddresses?: EmailCreateccAddressesInput | string[]
    bccAddresses?: EmailCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    snippet?: string | null
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: EmailCreatelabelsInput | string[]
    priority?: string
    snoozedUntil?: Date | string | null
    snoozedFromFolder?: string | null
    userId: string
    sentAt?: Date | string
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: EmailAttachmentCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateInput = {
    id?: string
    messageId: string
    folder?: $Enums.EmailFolder
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailCreatetoAddressesInput | string[]
    ccAddresses?: EmailCreateccAddressesInput | string[]
    bccAddresses?: EmailCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    snippet?: string | null
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: EmailCreatelabelsInput | string[]
    priority?: string
    snoozedUntil?: Date | string | null
    snoozedFromFolder?: string | null
    userId: string
    sentAt?: Date | string
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    folder?: EnumEmailFolderFieldUpdateOperationsInput | $Enums.EmailFolder
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailUpdatetoAddressesInput | string[]
    ccAddresses?: EmailUpdateccAddressesInput | string[]
    bccAddresses?: EmailUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    labels?: EmailUpdatelabelsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snoozedFromFolder?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: EmailAttachmentUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    folder?: EnumEmailFolderFieldUpdateOperationsInput | $Enums.EmailFolder
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailUpdatetoAddressesInput | string[]
    ccAddresses?: EmailUpdateccAddressesInput | string[]
    bccAddresses?: EmailUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    labels?: EmailUpdatelabelsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snoozedFromFolder?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailCreateManyInput = {
    id?: string
    messageId: string
    folder?: $Enums.EmailFolder
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailCreatetoAddressesInput | string[]
    ccAddresses?: EmailCreateccAddressesInput | string[]
    bccAddresses?: EmailCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    snippet?: string | null
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: EmailCreatelabelsInput | string[]
    priority?: string
    snoozedUntil?: Date | string | null
    snoozedFromFolder?: string | null
    userId: string
    sentAt?: Date | string
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    folder?: EnumEmailFolderFieldUpdateOperationsInput | $Enums.EmailFolder
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailUpdatetoAddressesInput | string[]
    ccAddresses?: EmailUpdateccAddressesInput | string[]
    bccAddresses?: EmailUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    labels?: EmailUpdatelabelsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snoozedFromFolder?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    folder?: EnumEmailFolderFieldUpdateOperationsInput | $Enums.EmailFolder
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailUpdatetoAddressesInput | string[]
    ccAddresses?: EmailUpdateccAddressesInput | string[]
    bccAddresses?: EmailUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    labels?: EmailUpdatelabelsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snoozedFromFolder?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateInput = {
    id?: string
    filename: string
    mimeType: string
    size: number
    url?: string | null
    createdAt?: Date | string
    email: EmailCreateNestedOneWithoutAttachmentsInput
  }

  export type EmailAttachmentUncheckedCreateInput = {
    id?: string
    filename: string
    mimeType: string
    size: number
    url?: string | null
    emailId: string
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type EmailAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    emailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateManyInput = {
    id?: string
    filename: string
    mimeType: string
    size: number
    url?: string | null
    emailId: string
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    emailId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOutboxCreateInput = {
    id?: string
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailOutboxCreatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxCreateccAddressesInput | string[]
    bccAddresses?: EmailOutboxCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    sendAt: Date | string
    status?: $Enums.OutboxStatus
    sentEmailId?: string | null
    errorMessage?: string | null
    attempts?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailOutboxUncheckedCreateInput = {
    id?: string
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailOutboxCreatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxCreateccAddressesInput | string[]
    bccAddresses?: EmailOutboxCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    sendAt: Date | string
    status?: $Enums.OutboxStatus
    sentEmailId?: string | null
    errorMessage?: string | null
    attempts?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailOutboxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailOutboxUpdatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxUpdateccAddressesInput | string[]
    bccAddresses?: EmailOutboxUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    sentEmailId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOutboxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailOutboxUpdatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxUpdateccAddressesInput | string[]
    bccAddresses?: EmailOutboxUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    sentEmailId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOutboxCreateManyInput = {
    id?: string
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailOutboxCreatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxCreateccAddressesInput | string[]
    bccAddresses?: EmailOutboxCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    sendAt: Date | string
    status?: $Enums.OutboxStatus
    sentEmailId?: string | null
    errorMessage?: string | null
    attempts?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailOutboxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailOutboxUpdatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxUpdateccAddressesInput | string[]
    bccAddresses?: EmailOutboxUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    sentEmailId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailOutboxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailOutboxUpdatetoAddressesInput | string[]
    ccAddresses?: EmailOutboxUpdateccAddressesInput | string[]
    bccAddresses?: EmailOutboxUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    sendAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOutboxStatusFieldUpdateOperationsInput | $Enums.OutboxStatus
    sentEmailId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailDomainCreateInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxCreateNestedManyWithoutDomainInput
    aliases?: EmailAliasCreateNestedManyWithoutDomainInput
    dnsRecords?: DomainDNSCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainUncheckedCreateInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxUncheckedCreateNestedManyWithoutDomainInput
    aliases?: EmailAliasUncheckedCreateNestedManyWithoutDomainInput
    dnsRecords?: DomainDNSUncheckedCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUpdateManyWithoutDomainNestedInput
    aliases?: EmailAliasUpdateManyWithoutDomainNestedInput
    dnsRecords?: DomainDNSUpdateManyWithoutDomainNestedInput
  }

  export type EmailDomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUncheckedUpdateManyWithoutDomainNestedInput
    aliases?: EmailAliasUncheckedUpdateManyWithoutDomainNestedInput
    dnsRecords?: DomainDNSUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type EmailDomainCreateManyInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailDomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailDomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxCreateInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutMailboxesInput
    domain: EmailDomainCreateNestedOneWithoutMailboxesInput
    targetAliases?: EmailAliasCreateNestedManyWithoutTargetMailboxInput
  }

  export type MailboxUncheckedCreateInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    userId?: string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    targetAliases?: EmailAliasUncheckedCreateNestedManyWithoutTargetMailboxInput
  }

  export type MailboxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMailboxesNestedInput
    domain?: EmailDomainUpdateOneRequiredWithoutMailboxesNestedInput
    targetAliases?: EmailAliasUpdateManyWithoutTargetMailboxNestedInput
  }

  export type MailboxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetAliases?: EmailAliasUncheckedUpdateManyWithoutTargetMailboxNestedInput
  }

  export type MailboxCreateManyInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    userId?: string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailboxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasCreateInput = {
    id?: string
    localPart: string
    externalTarget?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    targetMailbox?: MailboxCreateNestedOneWithoutTargetAliasesInput
    domain: EmailDomainCreateNestedOneWithoutAliasesInput
  }

  export type EmailAliasUncheckedCreateInput = {
    id?: string
    localPart: string
    targetMailboxId?: string | null
    externalTarget?: string | null
    isActive?: boolean
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAliasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetMailbox?: MailboxUpdateOneWithoutTargetAliasesNestedInput
    domain?: EmailDomainUpdateOneRequiredWithoutAliasesNestedInput
  }

  export type EmailAliasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    targetMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasCreateManyInput = {
    id?: string
    localPart: string
    targetMailboxId?: string | null
    externalTarget?: string | null
    isActive?: boolean
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAliasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    targetMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainDNSCreateInput = {
    id?: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority?: number | null
    ttl?: number
    description?: string | null
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain: EmailDomainCreateNestedOneWithoutDnsRecordsInput
  }

  export type DomainDNSUncheckedCreateInput = {
    id?: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority?: number | null
    ttl?: number
    description?: string | null
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: Date | string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainDNSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: EmailDomainUpdateOneRequiredWithoutDnsRecordsNestedInput
  }

  export type DomainDNSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainDNSCreateManyInput = {
    id?: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority?: number | null
    ttl?: number
    description?: string | null
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: Date | string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainDNSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainDNSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    messageId?: string | null
    direction: string
    fromAddress: string
    toAddress: string
    subject?: string | null
    status: $Enums.EmailLogStatus
    errorMessage?: string | null
    sizeBytes?: number | null
    hasAttachments?: boolean
    smtpCode?: number | null
    smtpResponse?: string | null
    spamScore?: number | null
    spamAction?: string | null
    processedAt?: Date | string
    deliveredAt?: Date | string | null
    domainId?: string | null
    mailboxId?: string | null
    createdAt?: Date | string
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    messageId?: string | null
    direction: string
    fromAddress: string
    toAddress: string
    subject?: string | null
    status: $Enums.EmailLogStatus
    errorMessage?: string | null
    sizeBytes?: number | null
    hasAttachments?: boolean
    smtpCode?: number | null
    smtpResponse?: string | null
    spamScore?: number | null
    spamAction?: string | null
    processedAt?: Date | string
    deliveredAt?: Date | string | null
    domainId?: string | null
    mailboxId?: string | null
    createdAt?: Date | string
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailLogStatusFieldUpdateOperationsInput | $Enums.EmailLogStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    smtpCode?: NullableIntFieldUpdateOperationsInput | number | null
    smtpResponse?: NullableStringFieldUpdateOperationsInput | string | null
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    spamAction?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailLogStatusFieldUpdateOperationsInput | $Enums.EmailLogStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    smtpCode?: NullableIntFieldUpdateOperationsInput | number | null
    smtpResponse?: NullableStringFieldUpdateOperationsInput | string | null
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    spamAction?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateManyInput = {
    id?: string
    messageId?: string | null
    direction: string
    fromAddress: string
    toAddress: string
    subject?: string | null
    status: $Enums.EmailLogStatus
    errorMessage?: string | null
    sizeBytes?: number | null
    hasAttachments?: boolean
    smtpCode?: number | null
    smtpResponse?: string | null
    spamScore?: number | null
    spamAction?: string | null
    processedAt?: Date | string
    deliveredAt?: Date | string | null
    domainId?: string | null
    mailboxId?: string | null
    createdAt?: Date | string
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailLogStatusFieldUpdateOperationsInput | $Enums.EmailLogStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    smtpCode?: NullableIntFieldUpdateOperationsInput | number | null
    smtpResponse?: NullableStringFieldUpdateOperationsInput | string | null
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    spamAction?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmailLogStatusFieldUpdateOperationsInput | $Enums.EmailLogStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableIntFieldUpdateOperationsInput | number | null
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    smtpCode?: NullableIntFieldUpdateOperationsInput | number | null
    smtpResponse?: NullableStringFieldUpdateOperationsInput | string | null
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    spamAction?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailQuarantinedCreateInput = {
    id?: string
    messageId: string
    fromAddress: string
    toAddress: string
    subject?: string | null
    reason: string
    spamScore?: number | null
    rawHeaders?: string | null
    previewText?: string | null
    releasedAt?: Date | string | null
    releasedBy?: string | null
    deletedAt?: Date | string | null
    domainId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailQuarantinedUncheckedCreateInput = {
    id?: string
    messageId: string
    fromAddress: string
    toAddress: string
    subject?: string | null
    reason: string
    spamScore?: number | null
    rawHeaders?: string | null
    previewText?: string | null
    releasedAt?: Date | string | null
    releasedBy?: string | null
    deletedAt?: Date | string | null
    domainId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailQuarantinedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    rawHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailQuarantinedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    rawHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailQuarantinedCreateManyInput = {
    id?: string
    messageId: string
    fromAddress: string
    toAddress: string
    subject?: string | null
    reason: string
    spamScore?: number | null
    rawHeaders?: string | null
    previewText?: string | null
    releasedAt?: Date | string | null
    releasedBy?: string | null
    deletedAt?: Date | string | null
    domainId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailQuarantinedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    rawHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailQuarantinedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: StringFieldUpdateOperationsInput | string
    spamScore?: NullableFloatFieldUpdateOperationsInput | number | null
    rawHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    previewText?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateInput = {
    id?: string
    name: string
    subject: string
    htmlBody?: string | null
    textBody?: string | null
    category?: $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateCreateplaceholdersInput | string[]
    usageCount?: number
    lastUsedAt?: Date | string | null
    isShared?: boolean
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    htmlBody?: string | null
    textBody?: string | null
    category?: $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateCreateplaceholdersInput | string[]
    usageCount?: number
    lastUsedAt?: Date | string | null
    isShared?: boolean
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEmailTemplateCategoryFieldUpdateOperationsInput | $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEmailTemplateCategoryFieldUpdateOperationsInput | $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateCreateManyInput = {
    id?: string
    name: string
    subject: string
    htmlBody?: string | null
    textBody?: string | null
    category?: $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateCreateplaceholdersInput | string[]
    usageCount?: number
    lastUsedAt?: Date | string | null
    isShared?: boolean
    userId: string
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEmailTemplateCategoryFieldUpdateOperationsInput | $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumEmailTemplateCategoryFieldUpdateOperationsInput | $Enums.EmailTemplateCategory
    placeholders?: EmailTemplateUpdateplaceholdersInput | string[]
    usageCount?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isShared?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VacationResponderCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    subject?: string
    message: string
    isActive?: boolean
    onlyContacts?: boolean
    onlyOnce?: boolean
    excludedDomains?: VacationResponderCreateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderCreaterespondedToInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VacationResponderUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    subject?: string
    message: string
    isActive?: boolean
    onlyContacts?: boolean
    onlyOnce?: boolean
    excludedDomains?: VacationResponderCreateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderCreaterespondedToInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VacationResponderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    onlyContacts?: BoolFieldUpdateOperationsInput | boolean
    onlyOnce?: BoolFieldUpdateOperationsInput | boolean
    excludedDomains?: VacationResponderUpdateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderUpdaterespondedToInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VacationResponderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    onlyContacts?: BoolFieldUpdateOperationsInput | boolean
    onlyOnce?: BoolFieldUpdateOperationsInput | boolean
    excludedDomains?: VacationResponderUpdateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderUpdaterespondedToInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VacationResponderCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    subject?: string
    message: string
    isActive?: boolean
    onlyContacts?: boolean
    onlyOnce?: boolean
    excludedDomains?: VacationResponderCreateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderCreaterespondedToInput | string[]
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VacationResponderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    onlyContacts?: BoolFieldUpdateOperationsInput | boolean
    onlyOnce?: BoolFieldUpdateOperationsInput | boolean
    excludedDomains?: VacationResponderUpdateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderUpdaterespondedToInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VacationResponderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    onlyContacts?: BoolFieldUpdateOperationsInput | boolean
    onlyOnce?: BoolFieldUpdateOperationsInput | boolean
    excludedDomains?: VacationResponderUpdateexcludedDomainsInput | string[]
    respondedTo?: VacationResponderUpdaterespondedToInput | string[]
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingCreateInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opens?: EmailTrackingEventCreateNestedManyWithoutTrackingInput
    clicks?: EmailLinkClickCreateNestedManyWithoutTrackingInput
  }

  export type EmailTrackingUncheckedCreateInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opens?: EmailTrackingEventUncheckedCreateNestedManyWithoutTrackingInput
    clicks?: EmailLinkClickUncheckedCreateNestedManyWithoutTrackingInput
  }

  export type EmailTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: EmailTrackingEventUpdateManyWithoutTrackingNestedInput
    clicks?: EmailLinkClickUpdateManyWithoutTrackingNestedInput
  }

  export type EmailTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: EmailTrackingEventUncheckedUpdateManyWithoutTrackingNestedInput
    clicks?: EmailLinkClickUncheckedUpdateManyWithoutTrackingNestedInput
  }

  export type EmailTrackingCreateManyInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingEventCreateInput = {
    id?: string
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    country?: string | null
    city?: string | null
    createdAt?: Date | string
    tracking: EmailTrackingCreateNestedOneWithoutOpensInput
  }

  export type EmailTrackingEventUncheckedCreateInput = {
    id?: string
    trackingId: string
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    country?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type EmailTrackingEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tracking?: EmailTrackingUpdateOneRequiredWithoutOpensNestedInput
  }

  export type EmailTrackingEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingEventCreateManyInput = {
    id?: string
    trackingId: string
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    country?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type EmailTrackingEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLinkClickCreateInput = {
    id?: string
    originalUrl: string
    clickCount?: number
    ipAddress?: string | null
    userAgent?: string | null
    firstClickedAt?: Date | string
    lastClickedAt?: Date | string
    tracking: EmailTrackingCreateNestedOneWithoutClicksInput
  }

  export type EmailLinkClickUncheckedCreateInput = {
    id?: string
    trackingId: string
    originalUrl: string
    clickCount?: number
    ipAddress?: string | null
    userAgent?: string | null
    firstClickedAt?: Date | string
    lastClickedAt?: Date | string
  }

  export type EmailLinkClickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tracking?: EmailTrackingUpdateOneRequiredWithoutClicksNestedInput
  }

  export type EmailLinkClickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLinkClickCreateManyInput = {
    id?: string
    trackingId: string
    originalUrl: string
    clickCount?: number
    ipAddress?: string | null
    userAgent?: string | null
    firstClickedAt?: Date | string
    lastClickedAt?: Date | string
  }

  export type EmailLinkClickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLinkClickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailMergeCreateInput = {
    id?: string
    name: string
    subject: string
    htmlBody?: string | null
    textBody?: string | null
    recipientCount?: number
    recipients: JsonNullValueInput | InputJsonValue
    status?: $Enums.MailMergeStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sentCount?: number
    failedCount?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailMergeUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    htmlBody?: string | null
    textBody?: string | null
    recipientCount?: number
    recipients: JsonNullValueInput | InputJsonValue
    status?: $Enums.MailMergeStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sentCount?: number
    failedCount?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailMergeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    recipients?: JsonNullValueInput | InputJsonValue
    status?: EnumMailMergeStatusFieldUpdateOperationsInput | $Enums.MailMergeStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailMergeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    recipients?: JsonNullValueInput | InputJsonValue
    status?: EnumMailMergeStatusFieldUpdateOperationsInput | $Enums.MailMergeStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailMergeCreateManyInput = {
    id?: string
    name: string
    subject: string
    htmlBody?: string | null
    textBody?: string | null
    recipientCount?: number
    recipients: JsonNullValueInput | InputJsonValue
    status?: $Enums.MailMergeStatus
    scheduledAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    sentCount?: number
    failedCount?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailMergeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    recipients?: JsonNullValueInput | InputJsonValue
    status?: EnumMailMergeStatusFieldUpdateOperationsInput | $Enums.MailMergeStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailMergeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    recipientCount?: IntFieldUpdateOperationsInput | number
    recipients?: JsonNullValueInput | InputJsonValue
    status?: EnumMailMergeStatusFieldUpdateOperationsInput | $Enums.MailMergeStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailHostingSettingsCreateInput = {
    id?: string
    defaultDomainId?: string | null
    emailFormat?: string
    autoProvisionEnabled?: boolean
    defaultQuotaMb?: number
    defaultMaxSendPerDay?: number
    notifyOnProvision?: boolean
    welcomeEmailTemplate?: string | null
    requireStrongPassword?: boolean
    minPasswordLength?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailHostingSettingsUncheckedCreateInput = {
    id?: string
    defaultDomainId?: string | null
    emailFormat?: string
    autoProvisionEnabled?: boolean
    defaultQuotaMb?: number
    defaultMaxSendPerDay?: number
    notifyOnProvision?: boolean
    welcomeEmailTemplate?: string | null
    requireStrongPassword?: boolean
    minPasswordLength?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailHostingSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultDomainId?: NullableStringFieldUpdateOperationsInput | string | null
    emailFormat?: StringFieldUpdateOperationsInput | string
    autoProvisionEnabled?: BoolFieldUpdateOperationsInput | boolean
    defaultQuotaMb?: IntFieldUpdateOperationsInput | number
    defaultMaxSendPerDay?: IntFieldUpdateOperationsInput | number
    notifyOnProvision?: BoolFieldUpdateOperationsInput | boolean
    welcomeEmailTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    minPasswordLength?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailHostingSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultDomainId?: NullableStringFieldUpdateOperationsInput | string | null
    emailFormat?: StringFieldUpdateOperationsInput | string
    autoProvisionEnabled?: BoolFieldUpdateOperationsInput | boolean
    defaultQuotaMb?: IntFieldUpdateOperationsInput | number
    defaultMaxSendPerDay?: IntFieldUpdateOperationsInput | number
    notifyOnProvision?: BoolFieldUpdateOperationsInput | boolean
    welcomeEmailTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    minPasswordLength?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailHostingSettingsCreateManyInput = {
    id?: string
    defaultDomainId?: string | null
    emailFormat?: string
    autoProvisionEnabled?: boolean
    defaultQuotaMb?: number
    defaultMaxSendPerDay?: number
    notifyOnProvision?: boolean
    welcomeEmailTemplate?: string | null
    requireStrongPassword?: boolean
    minPasswordLength?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailHostingSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultDomainId?: NullableStringFieldUpdateOperationsInput | string | null
    emailFormat?: StringFieldUpdateOperationsInput | string
    autoProvisionEnabled?: BoolFieldUpdateOperationsInput | boolean
    defaultQuotaMb?: IntFieldUpdateOperationsInput | number
    defaultMaxSendPerDay?: IntFieldUpdateOperationsInput | number
    notifyOnProvision?: BoolFieldUpdateOperationsInput | boolean
    welcomeEmailTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    minPasswordLength?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailHostingSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    defaultDomainId?: NullableStringFieldUpdateOperationsInput | string | null
    emailFormat?: StringFieldUpdateOperationsInput | string
    autoProvisionEnabled?: BoolFieldUpdateOperationsInput | boolean
    defaultQuotaMb?: IntFieldUpdateOperationsInput | number
    defaultMaxSendPerDay?: IntFieldUpdateOperationsInput | number
    notifyOnProvision?: BoolFieldUpdateOperationsInput | boolean
    welcomeEmailTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    requireStrongPassword?: BoolFieldUpdateOperationsInput | boolean
    minPasswordLength?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxAuditLogCreateInput = {
    id?: string
    action: $Enums.MailboxAuditAction
    mailboxId?: string | null
    userId?: string | null
    domainId?: string | null
    performedById?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    companyId: string
    createdAt?: Date | string
  }

  export type MailboxAuditLogUncheckedCreateInput = {
    id?: string
    action: $Enums.MailboxAuditAction
    mailboxId?: string | null
    userId?: string | null
    domainId?: string | null
    performedById?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    companyId: string
    createdAt?: Date | string
  }

  export type MailboxAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumMailboxAuditActionFieldUpdateOperationsInput | $Enums.MailboxAuditAction
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumMailboxAuditActionFieldUpdateOperationsInput | $Enums.MailboxAuditAction
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxAuditLogCreateManyInput = {
    id?: string
    action: $Enums.MailboxAuditAction
    mailboxId?: string | null
    userId?: string | null
    domainId?: string | null
    performedById?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    success?: boolean
    errorMessage?: string | null
    companyId: string
    createdAt?: Date | string
  }

  export type MailboxAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumMailboxAuditActionFieldUpdateOperationsInput | $Enums.MailboxAuditAction
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumMailboxAuditActionFieldUpdateOperationsInput | $Enums.MailboxAuditAction
    mailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: NullableStringFieldUpdateOperationsInput | string | null
    performedById?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MailboxListRelationFilter = {
    every?: MailboxWhereInput
    some?: MailboxWhereInput
    none?: MailboxWhereInput
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MailboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    jobTitle?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    signatureEnabled?: SortOrder
    signatureStyle?: SortOrder
    signatureHtml?: SortOrder
    linkedinUrl?: SortOrder
    twitterUrl?: SortOrder
    instagramUrl?: SortOrder
    location?: SortOrder
    officeAddress?: SortOrder
    mailPassword?: SortOrder
    totpSecret?: SortOrder
    totpEnabled?: SortOrder
    totpBackupCodes?: SortOrder
    totpLastUsed?: SortOrder
    ssoProvider?: SortOrder
    ssoExternalId?: SortOrder
    lastSsoLogin?: SortOrder
    primaryMailboxId?: SortOrder
    autoProvisionEmail?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    jobTitle?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    signatureEnabled?: SortOrder
    signatureStyle?: SortOrder
    signatureHtml?: SortOrder
    linkedinUrl?: SortOrder
    twitterUrl?: SortOrder
    instagramUrl?: SortOrder
    location?: SortOrder
    officeAddress?: SortOrder
    mailPassword?: SortOrder
    totpSecret?: SortOrder
    totpEnabled?: SortOrder
    totpLastUsed?: SortOrder
    ssoProvider?: SortOrder
    ssoExternalId?: SortOrder
    lastSsoLogin?: SortOrder
    primaryMailboxId?: SortOrder
    autoProvisionEmail?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    jobTitle?: SortOrder
    phone?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    signatureEnabled?: SortOrder
    signatureStyle?: SortOrder
    signatureHtml?: SortOrder
    linkedinUrl?: SortOrder
    twitterUrl?: SortOrder
    instagramUrl?: SortOrder
    location?: SortOrder
    officeAddress?: SortOrder
    mailPassword?: SortOrder
    totpSecret?: SortOrder
    totpEnabled?: SortOrder
    totpLastUsed?: SortOrder
    ssoProvider?: SortOrder
    ssoExternalId?: SortOrder
    lastSsoLogin?: SortOrder
    primaryMailboxId?: SortOrder
    autoProvisionEmail?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type TemplateListRelationFilter = {
    every?: TemplateWhereInput
    some?: TemplateWhereInput
    none?: TemplateWhereInput
  }

  export type AssetListRelationFilter = {
    every?: AssetWhereInput
    some?: AssetWhereInput
    none?: AssetWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    taxId?: SortOrder
    registrationNo?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    bankBranch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    taxId?: SortOrder
    registrationNo?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    bankBranch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    tagline?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    website?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    taxId?: SortOrder
    registrationNo?: SortOrder
    bankName?: SortOrder
    bankAccount?: SortOrder
    bankBranch?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    contactPerson?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    contactPerson?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    contactPerson?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    country?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ClientNullableRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DocumentItemListRelationFilter = {
    every?: DocumentItemWhereInput
    some?: DocumentItemWhereInput
    none?: DocumentItemWhereInput
  }

  export type DocumentItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    documentNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    pdfUrl?: SortOrder
    companyId?: SortOrder
    clientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    pdfUrl?: SortOrder
    companyId?: SortOrder
    clientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    documentNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    terms?: SortOrder
    pdfUrl?: SortOrder
    companyId?: SortOrder
    clientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentItemCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type DocumentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentItemMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    config?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type AssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type EnumEmailFolderFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailFolder | EnumEmailFolderFieldRefInput<$PrismaModel>
    in?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailFolderFilter<$PrismaModel> | $Enums.EmailFolder
  }

  export type EmailAttachmentListRelationFilter = {
    every?: EmailAttachmentWhereInput
    some?: EmailAttachmentWhereInput
    none?: EmailAttachmentWhereInput
  }

  export type EmailAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    folder?: SortOrder
    fromName?: SortOrder
    fromAddress?: SortOrder
    toAddresses?: SortOrder
    ccAddresses?: SortOrder
    bccAddresses?: SortOrder
    subject?: SortOrder
    textBody?: SortOrder
    htmlBody?: SortOrder
    snippet?: SortOrder
    isRead?: SortOrder
    isStarred?: SortOrder
    hasAttachments?: SortOrder
    labels?: SortOrder
    priority?: SortOrder
    snoozedUntil?: SortOrder
    snoozedFromFolder?: SortOrder
    userId?: SortOrder
    sentAt?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    folder?: SortOrder
    fromName?: SortOrder
    fromAddress?: SortOrder
    subject?: SortOrder
    textBody?: SortOrder
    htmlBody?: SortOrder
    snippet?: SortOrder
    isRead?: SortOrder
    isStarred?: SortOrder
    hasAttachments?: SortOrder
    priority?: SortOrder
    snoozedUntil?: SortOrder
    snoozedFromFolder?: SortOrder
    userId?: SortOrder
    sentAt?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    folder?: SortOrder
    fromName?: SortOrder
    fromAddress?: SortOrder
    subject?: SortOrder
    textBody?: SortOrder
    htmlBody?: SortOrder
    snippet?: SortOrder
    isRead?: SortOrder
    isStarred?: SortOrder
    hasAttachments?: SortOrder
    priority?: SortOrder
    snoozedUntil?: SortOrder
    snoozedFromFolder?: SortOrder
    userId?: SortOrder
    sentAt?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmailFolderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailFolder | EnumEmailFolderFieldRefInput<$PrismaModel>
    in?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailFolderWithAggregatesFilter<$PrismaModel> | $Enums.EmailFolder
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailFolderFilter<$PrismaModel>
    _max?: NestedEnumEmailFolderFilter<$PrismaModel>
  }

  export type EmailRelationFilter = {
    is?: EmailWhereInput
    isNot?: EmailWhereInput
  }

  export type EmailAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    emailId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EmailAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    emailId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    emailId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumOutboxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusFilter<$PrismaModel> | $Enums.OutboxStatus
  }

  export type EmailOutboxCountOrderByAggregateInput = {
    id?: SortOrder
    fromName?: SortOrder
    fromAddress?: SortOrder
    toAddresses?: SortOrder
    ccAddresses?: SortOrder
    bccAddresses?: SortOrder
    subject?: SortOrder
    textBody?: SortOrder
    htmlBody?: SortOrder
    sendAt?: SortOrder
    status?: SortOrder
    sentEmailId?: SortOrder
    errorMessage?: SortOrder
    attempts?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailOutboxAvgOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EmailOutboxMaxOrderByAggregateInput = {
    id?: SortOrder
    fromName?: SortOrder
    fromAddress?: SortOrder
    subject?: SortOrder
    textBody?: SortOrder
    htmlBody?: SortOrder
    sendAt?: SortOrder
    status?: SortOrder
    sentEmailId?: SortOrder
    errorMessage?: SortOrder
    attempts?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailOutboxMinOrderByAggregateInput = {
    id?: SortOrder
    fromName?: SortOrder
    fromAddress?: SortOrder
    subject?: SortOrder
    textBody?: SortOrder
    htmlBody?: SortOrder
    sendAt?: SortOrder
    status?: SortOrder
    sentEmailId?: SortOrder
    errorMessage?: SortOrder
    attempts?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailOutboxSumOrderByAggregateInput = {
    attempts?: SortOrder
  }

  export type EnumOutboxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboxStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboxStatusFilter<$PrismaModel>
  }

  export type EmailAliasListRelationFilter = {
    every?: EmailAliasWhereInput
    some?: EmailAliasWhereInput
    none?: EmailAliasWhereInput
  }

  export type DomainDNSListRelationFilter = {
    every?: DomainDNSWhereInput
    some?: DomainDNSWhereInput
    none?: DomainDNSWhereInput
  }

  export type EmailAliasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainDNSOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailDomainCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationCode?: SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrder
    dkimSelector?: SortOrder
    dkimPublicKey?: SortOrder
    dkimPrivateKey?: SortOrder
    dkimVerified?: SortOrder
    spfRecord?: SortOrder
    spfVerified?: SortOrder
    dmarcPolicy?: SortOrder
    dmarcRecord?: SortOrder
    dmarcVerified?: SortOrder
    mxVerified?: SortOrder
    catchAllEnabled?: SortOrder
    catchAllMailboxId?: SortOrder
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailDomainAvgOrderByAggregateInput = {
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
  }

  export type EmailDomainMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationCode?: SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrder
    dkimSelector?: SortOrder
    dkimPublicKey?: SortOrder
    dkimPrivateKey?: SortOrder
    dkimVerified?: SortOrder
    spfRecord?: SortOrder
    spfVerified?: SortOrder
    dmarcPolicy?: SortOrder
    dmarcRecord?: SortOrder
    dmarcVerified?: SortOrder
    mxVerified?: SortOrder
    catchAllEnabled?: SortOrder
    catchAllMailboxId?: SortOrder
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailDomainMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    verificationCode?: SortOrder
    verificationMethod?: SortOrder
    verifiedAt?: SortOrder
    dkimSelector?: SortOrder
    dkimPublicKey?: SortOrder
    dkimPrivateKey?: SortOrder
    dkimVerified?: SortOrder
    spfRecord?: SortOrder
    spfVerified?: SortOrder
    dmarcPolicy?: SortOrder
    dmarcRecord?: SortOrder
    dmarcVerified?: SortOrder
    mxVerified?: SortOrder
    catchAllEnabled?: SortOrder
    catchAllMailboxId?: SortOrder
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailDomainSumOrderByAggregateInput = {
    maxMailboxes?: SortOrder
    maxAliases?: SortOrder
    totalStorageQuotaMb?: SortOrder
    usedStorageMb?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EmailDomainRelationFilter = {
    is?: EmailDomainWhereInput
    isNot?: EmailDomainWhereInput
  }

  export type MailboxLocalPartDomainIdCompoundUniqueInput = {
    localPart: string
    domainId: string
  }

  export type MailboxCountOrderByAggregateInput = {
    id?: SortOrder
    localPart?: SortOrder
    displayName?: SortOrder
    passwordHash?: SortOrder
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
    lastSentReset?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    autoReply?: SortOrder
    autoReplySubject?: SortOrder
    autoReplyMessage?: SortOrder
    autoReplyStart?: SortOrder
    autoReplyEnd?: SortOrder
    forwardingEnabled?: SortOrder
    forwardingAddress?: SortOrder
    keepCopy?: SortOrder
    spamFilterLevel?: SortOrder
    spamAction?: SortOrder
    signatureHtml?: SortOrder
    signatureText?: SortOrder
    userId?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailboxAvgOrderByAggregateInput = {
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
  }

  export type MailboxMaxOrderByAggregateInput = {
    id?: SortOrder
    localPart?: SortOrder
    displayName?: SortOrder
    passwordHash?: SortOrder
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
    lastSentReset?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    autoReply?: SortOrder
    autoReplySubject?: SortOrder
    autoReplyMessage?: SortOrder
    autoReplyStart?: SortOrder
    autoReplyEnd?: SortOrder
    forwardingEnabled?: SortOrder
    forwardingAddress?: SortOrder
    keepCopy?: SortOrder
    spamFilterLevel?: SortOrder
    spamAction?: SortOrder
    signatureHtml?: SortOrder
    signatureText?: SortOrder
    userId?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailboxMinOrderByAggregateInput = {
    id?: SortOrder
    localPart?: SortOrder
    displayName?: SortOrder
    passwordHash?: SortOrder
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
    lastSentReset?: SortOrder
    isActive?: SortOrder
    isAdmin?: SortOrder
    autoReply?: SortOrder
    autoReplySubject?: SortOrder
    autoReplyMessage?: SortOrder
    autoReplyStart?: SortOrder
    autoReplyEnd?: SortOrder
    forwardingEnabled?: SortOrder
    forwardingAddress?: SortOrder
    keepCopy?: SortOrder
    spamFilterLevel?: SortOrder
    spamAction?: SortOrder
    signatureHtml?: SortOrder
    signatureText?: SortOrder
    userId?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailboxSumOrderByAggregateInput = {
    quotaMb?: SortOrder
    usedMb?: SortOrder
    maxSendPerDay?: SortOrder
    sentToday?: SortOrder
  }

  export type MailboxNullableRelationFilter = {
    is?: MailboxWhereInput | null
    isNot?: MailboxWhereInput | null
  }

  export type EmailAliasLocalPartDomainIdCompoundUniqueInput = {
    localPart: string
    domainId: string
  }

  export type EmailAliasCountOrderByAggregateInput = {
    id?: SortOrder
    localPart?: SortOrder
    targetMailboxId?: SortOrder
    externalTarget?: SortOrder
    isActive?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAliasMaxOrderByAggregateInput = {
    id?: SortOrder
    localPart?: SortOrder
    targetMailboxId?: SortOrder
    externalTarget?: SortOrder
    isActive?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailAliasMinOrderByAggregateInput = {
    id?: SortOrder
    localPart?: SortOrder
    targetMailboxId?: SortOrder
    externalTarget?: SortOrder
    isActive?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDNSRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DNSRecordType | EnumDNSRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDNSRecordTypeFilter<$PrismaModel> | $Enums.DNSRecordType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DomainDNSCountOrderByAggregateInput = {
    id?: SortOrder
    recordType?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priority?: SortOrder
    ttl?: SortOrder
    description?: SortOrder
    isRequired?: SortOrder
    isVerified?: SortOrder
    lastCheckedAt?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainDNSAvgOrderByAggregateInput = {
    priority?: SortOrder
    ttl?: SortOrder
  }

  export type DomainDNSMaxOrderByAggregateInput = {
    id?: SortOrder
    recordType?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priority?: SortOrder
    ttl?: SortOrder
    description?: SortOrder
    isRequired?: SortOrder
    isVerified?: SortOrder
    lastCheckedAt?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainDNSMinOrderByAggregateInput = {
    id?: SortOrder
    recordType?: SortOrder
    name?: SortOrder
    value?: SortOrder
    priority?: SortOrder
    ttl?: SortOrder
    description?: SortOrder
    isRequired?: SortOrder
    isVerified?: SortOrder
    lastCheckedAt?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainDNSSumOrderByAggregateInput = {
    priority?: SortOrder
    ttl?: SortOrder
  }

  export type EnumDNSRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DNSRecordType | EnumDNSRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDNSRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.DNSRecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDNSRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumDNSRecordTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEmailLogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailLogStatus | EnumEmailLogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailLogStatusFilter<$PrismaModel> | $Enums.EmailLogStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    direction?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    sizeBytes?: SortOrder
    hasAttachments?: SortOrder
    smtpCode?: SortOrder
    smtpResponse?: SortOrder
    spamScore?: SortOrder
    spamAction?: SortOrder
    processedAt?: SortOrder
    deliveredAt?: SortOrder
    domainId?: SortOrder
    mailboxId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
    smtpCode?: SortOrder
    spamScore?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    direction?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    sizeBytes?: SortOrder
    hasAttachments?: SortOrder
    smtpCode?: SortOrder
    smtpResponse?: SortOrder
    spamScore?: SortOrder
    spamAction?: SortOrder
    processedAt?: SortOrder
    deliveredAt?: SortOrder
    domainId?: SortOrder
    mailboxId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    direction?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    sizeBytes?: SortOrder
    hasAttachments?: SortOrder
    smtpCode?: SortOrder
    smtpResponse?: SortOrder
    spamScore?: SortOrder
    spamAction?: SortOrder
    processedAt?: SortOrder
    deliveredAt?: SortOrder
    domainId?: SortOrder
    mailboxId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLogSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
    smtpCode?: SortOrder
    spamScore?: SortOrder
  }

  export type EnumEmailLogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailLogStatus | EnumEmailLogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailLogStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailLogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailLogStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailLogStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EmailQuarantinedCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    reason?: SortOrder
    spamScore?: SortOrder
    rawHeaders?: SortOrder
    previewText?: SortOrder
    releasedAt?: SortOrder
    releasedBy?: SortOrder
    deletedAt?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailQuarantinedAvgOrderByAggregateInput = {
    spamScore?: SortOrder
  }

  export type EmailQuarantinedMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    reason?: SortOrder
    spamScore?: SortOrder
    rawHeaders?: SortOrder
    previewText?: SortOrder
    releasedAt?: SortOrder
    releasedBy?: SortOrder
    deletedAt?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailQuarantinedMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    subject?: SortOrder
    reason?: SortOrder
    spamScore?: SortOrder
    rawHeaders?: SortOrder
    previewText?: SortOrder
    releasedAt?: SortOrder
    releasedBy?: SortOrder
    deletedAt?: SortOrder
    domainId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailQuarantinedSumOrderByAggregateInput = {
    spamScore?: SortOrder
  }

  export type EnumEmailTemplateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTemplateCategory | EnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTemplateCategoryFilter<$PrismaModel> | $Enums.EmailTemplateCategory
  }

  export type EmailTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrder
    textBody?: SortOrder
    category?: SortOrder
    placeholders?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    isShared?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EmailTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrder
    textBody?: SortOrder
    category?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    isShared?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrder
    textBody?: SortOrder
    category?: SortOrder
    usageCount?: SortOrder
    lastUsedAt?: SortOrder
    isShared?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EnumEmailTemplateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTemplateCategory | EnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTemplateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EmailTemplateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTemplateCategoryFilter<$PrismaModel>
    _max?: NestedEnumEmailTemplateCategoryFilter<$PrismaModel>
  }

  export type VacationResponderCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    onlyContacts?: SortOrder
    onlyOnce?: SortOrder
    excludedDomains?: SortOrder
    respondedTo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VacationResponderMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    onlyContacts?: SortOrder
    onlyOnce?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VacationResponderMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isActive?: SortOrder
    onlyContacts?: SortOrder
    onlyOnce?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTrackingEventListRelationFilter = {
    every?: EmailTrackingEventWhereInput
    some?: EmailTrackingEventWhereInput
    none?: EmailTrackingEventWhereInput
  }

  export type EmailLinkClickListRelationFilter = {
    every?: EmailLinkClickWhereInput
    some?: EmailLinkClickWhereInput
    none?: EmailLinkClickWhereInput
  }

  export type EmailTrackingEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailLinkClickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    emailId?: SortOrder
    outboxId?: SortOrder
    subject?: SortOrder
    recipientEmail?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    firstOpenedAt?: SortOrder
    lastOpenedAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTrackingAvgOrderByAggregateInput = {
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type EmailTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    emailId?: SortOrder
    outboxId?: SortOrder
    subject?: SortOrder
    recipientEmail?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    firstOpenedAt?: SortOrder
    lastOpenedAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    emailId?: SortOrder
    outboxId?: SortOrder
    subject?: SortOrder
    recipientEmail?: SortOrder
    openCount?: SortOrder
    clickCount?: SortOrder
    firstOpenedAt?: SortOrder
    lastOpenedAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailTrackingSumOrderByAggregateInput = {
    openCount?: SortOrder
    clickCount?: SortOrder
  }

  export type EmailTrackingRelationFilter = {
    is?: EmailTrackingWhereInput
    isNot?: EmailTrackingWhereInput
  }

  export type EmailTrackingEventCountOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    country?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailTrackingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    country?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailTrackingEventMinOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    country?: SortOrder
    city?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailLinkClickTrackingIdOriginalUrlCompoundUniqueInput = {
    trackingId: string
    originalUrl: string
  }

  export type EmailLinkClickCountOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    firstClickedAt?: SortOrder
    lastClickedAt?: SortOrder
  }

  export type EmailLinkClickAvgOrderByAggregateInput = {
    clickCount?: SortOrder
  }

  export type EmailLinkClickMaxOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    firstClickedAt?: SortOrder
    lastClickedAt?: SortOrder
  }

  export type EmailLinkClickMinOrderByAggregateInput = {
    id?: SortOrder
    trackingId?: SortOrder
    originalUrl?: SortOrder
    clickCount?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    firstClickedAt?: SortOrder
    lastClickedAt?: SortOrder
  }

  export type EmailLinkClickSumOrderByAggregateInput = {
    clickCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumMailMergeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MailMergeStatus | EnumMailMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailMergeStatusFilter<$PrismaModel> | $Enums.MailMergeStatus
  }

  export type MailMergeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrder
    textBody?: SortOrder
    recipientCount?: SortOrder
    recipients?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailMergeAvgOrderByAggregateInput = {
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type MailMergeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrder
    textBody?: SortOrder
    recipientCount?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailMergeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    htmlBody?: SortOrder
    textBody?: SortOrder
    recipientCount?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MailMergeSumOrderByAggregateInput = {
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumMailMergeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailMergeStatus | EnumMailMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailMergeStatusWithAggregatesFilter<$PrismaModel> | $Enums.MailMergeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailMergeStatusFilter<$PrismaModel>
    _max?: NestedEnumMailMergeStatusFilter<$PrismaModel>
  }

  export type EmailHostingSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    defaultDomainId?: SortOrder
    emailFormat?: SortOrder
    autoProvisionEnabled?: SortOrder
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    notifyOnProvision?: SortOrder
    welcomeEmailTemplate?: SortOrder
    requireStrongPassword?: SortOrder
    minPasswordLength?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailHostingSettingsAvgOrderByAggregateInput = {
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    minPasswordLength?: SortOrder
  }

  export type EmailHostingSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    defaultDomainId?: SortOrder
    emailFormat?: SortOrder
    autoProvisionEnabled?: SortOrder
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    notifyOnProvision?: SortOrder
    welcomeEmailTemplate?: SortOrder
    requireStrongPassword?: SortOrder
    minPasswordLength?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailHostingSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    defaultDomainId?: SortOrder
    emailFormat?: SortOrder
    autoProvisionEnabled?: SortOrder
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    notifyOnProvision?: SortOrder
    welcomeEmailTemplate?: SortOrder
    requireStrongPassword?: SortOrder
    minPasswordLength?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailHostingSettingsSumOrderByAggregateInput = {
    defaultQuotaMb?: SortOrder
    defaultMaxSendPerDay?: SortOrder
    minPasswordLength?: SortOrder
  }

  export type EnumMailboxAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.MailboxAuditAction | EnumMailboxAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumMailboxAuditActionFilter<$PrismaModel> | $Enums.MailboxAuditAction
  }

  export type MailboxAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    mailboxId?: SortOrder
    userId?: SortOrder
    domainId?: SortOrder
    performedById?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type MailboxAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    mailboxId?: SortOrder
    userId?: SortOrder
    domainId?: SortOrder
    performedById?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type MailboxAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    mailboxId?: SortOrder
    userId?: SortOrder
    domainId?: SortOrder
    performedById?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMailboxAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailboxAuditAction | EnumMailboxAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumMailboxAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.MailboxAuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailboxAuditActionFilter<$PrismaModel>
    _max?: NestedEnumMailboxAuditActionFilter<$PrismaModel>
  }

  export type UserCreatetotpBackupCodesInput = {
    set: string[]
  }

  export type MailboxCreateNestedManyWithoutUserInput = {
    create?: XOR<MailboxCreateWithoutUserInput, MailboxUncheckedCreateWithoutUserInput> | MailboxCreateWithoutUserInput[] | MailboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutUserInput | MailboxCreateOrConnectWithoutUserInput[]
    createMany?: MailboxCreateManyUserInputEnvelope
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DocumentCreateWithoutCreatedByInput, DocumentUncheckedCreateWithoutCreatedByInput> | DocumentCreateWithoutCreatedByInput[] | DocumentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatedByInput | DocumentCreateOrConnectWithoutCreatedByInput[]
    createMany?: DocumentCreateManyCreatedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type MailboxUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MailboxCreateWithoutUserInput, MailboxUncheckedCreateWithoutUserInput> | MailboxCreateWithoutUserInput[] | MailboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutUserInput | MailboxCreateOrConnectWithoutUserInput[]
    createMany?: MailboxCreateManyUserInputEnvelope
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DocumentCreateWithoutCreatedByInput, DocumentUncheckedCreateWithoutCreatedByInput> | DocumentCreateWithoutCreatedByInput[] | DocumentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatedByInput | DocumentCreateOrConnectWithoutCreatedByInput[]
    createMany?: DocumentCreateManyCreatedByInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdatetotpBackupCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MailboxUpdateManyWithoutUserNestedInput = {
    create?: XOR<MailboxCreateWithoutUserInput, MailboxUncheckedCreateWithoutUserInput> | MailboxCreateWithoutUserInput[] | MailboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutUserInput | MailboxCreateOrConnectWithoutUserInput[]
    upsert?: MailboxUpsertWithWhereUniqueWithoutUserInput | MailboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MailboxCreateManyUserInputEnvelope
    set?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    disconnect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    delete?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    update?: MailboxUpdateWithWhereUniqueWithoutUserInput | MailboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MailboxUpdateManyWithWhereWithoutUserInput | MailboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MailboxScalarWhereInput | MailboxScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type DocumentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DocumentCreateWithoutCreatedByInput, DocumentUncheckedCreateWithoutCreatedByInput> | DocumentCreateWithoutCreatedByInput[] | DocumentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatedByInput | DocumentCreateOrConnectWithoutCreatedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCreatedByInput | DocumentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DocumentCreateManyCreatedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCreatedByInput | DocumentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCreatedByInput | DocumentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type MailboxUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MailboxCreateWithoutUserInput, MailboxUncheckedCreateWithoutUserInput> | MailboxCreateWithoutUserInput[] | MailboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutUserInput | MailboxCreateOrConnectWithoutUserInput[]
    upsert?: MailboxUpsertWithWhereUniqueWithoutUserInput | MailboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MailboxCreateManyUserInputEnvelope
    set?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    disconnect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    delete?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    update?: MailboxUpdateWithWhereUniqueWithoutUserInput | MailboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MailboxUpdateManyWithWhereWithoutUserInput | MailboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MailboxScalarWhereInput | MailboxScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DocumentCreateWithoutCreatedByInput, DocumentUncheckedCreateWithoutCreatedByInput> | DocumentCreateWithoutCreatedByInput[] | DocumentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCreatedByInput | DocumentCreateOrConnectWithoutCreatedByInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCreatedByInput | DocumentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DocumentCreateManyCreatedByInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCreatedByInput | DocumentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCreatedByInput | DocumentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type TemplateCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TemplateCreateWithoutCompanyInput, TemplateUncheckedCreateWithoutCompanyInput> | TemplateCreateWithoutCompanyInput[] | TemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCompanyInput | TemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: TemplateCreateManyCompanyInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type AssetCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AssetCreateWithoutCompanyInput, AssetUncheckedCreateWithoutCompanyInput> | AssetCreateWithoutCompanyInput[] | AssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCompanyInput | AssetCreateOrConnectWithoutCompanyInput[]
    createMany?: AssetCreateManyCompanyInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type TemplateUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TemplateCreateWithoutCompanyInput, TemplateUncheckedCreateWithoutCompanyInput> | TemplateCreateWithoutCompanyInput[] | TemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCompanyInput | TemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: TemplateCreateManyCompanyInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type AssetUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<AssetCreateWithoutCompanyInput, AssetUncheckedCreateWithoutCompanyInput> | AssetCreateWithoutCompanyInput[] | AssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCompanyInput | AssetCreateOrConnectWithoutCompanyInput[]
    createMany?: AssetCreateManyCompanyInputEnvelope
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCompanyInput | ClientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCompanyInput | ClientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCompanyInput | ClientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type TemplateUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TemplateCreateWithoutCompanyInput, TemplateUncheckedCreateWithoutCompanyInput> | TemplateCreateWithoutCompanyInput[] | TemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCompanyInput | TemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutCompanyInput | TemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TemplateCreateManyCompanyInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutCompanyInput | TemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutCompanyInput | TemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type AssetUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AssetCreateWithoutCompanyInput, AssetUncheckedCreateWithoutCompanyInput> | AssetCreateWithoutCompanyInput[] | AssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCompanyInput | AssetCreateOrConnectWithoutCompanyInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCompanyInput | AssetUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AssetCreateManyCompanyInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCompanyInput | AssetUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCompanyInput | AssetUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput> | ClientCreateWithoutCompanyInput[] | ClientUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutCompanyInput | ClientCreateOrConnectWithoutCompanyInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutCompanyInput | ClientUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ClientCreateManyCompanyInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutCompanyInput | ClientUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutCompanyInput | ClientUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type TemplateUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TemplateCreateWithoutCompanyInput, TemplateUncheckedCreateWithoutCompanyInput> | TemplateCreateWithoutCompanyInput[] | TemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutCompanyInput | TemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutCompanyInput | TemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TemplateCreateManyCompanyInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutCompanyInput | TemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutCompanyInput | TemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type AssetUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<AssetCreateWithoutCompanyInput, AssetUncheckedCreateWithoutCompanyInput> | AssetCreateWithoutCompanyInput[] | AssetUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: AssetCreateOrConnectWithoutCompanyInput | AssetCreateOrConnectWithoutCompanyInput[]
    upsert?: AssetUpsertWithWhereUniqueWithoutCompanyInput | AssetUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: AssetCreateManyCompanyInputEnvelope
    set?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    disconnect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    delete?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    connect?: AssetWhereUniqueInput | AssetWhereUniqueInput[]
    update?: AssetUpdateWithWhereUniqueWithoutCompanyInput | AssetUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: AssetUpdateManyWithWhereWithoutCompanyInput | AssetUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: AssetScalarWhereInput | AssetScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutClientsInput = {
    create?: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutClientsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutClientsInput
    upsert?: CompanyUpsertWithoutClientsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutClientsInput, CompanyUpdateWithoutClientsInput>, CompanyUncheckedUpdateWithoutClientsInput>
  }

  export type DocumentUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput> | DocumentCreateWithoutClientInput[] | DocumentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientInput | DocumentCreateOrConnectWithoutClientInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientInput | DocumentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: DocumentCreateManyClientInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientInput | DocumentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientInput | DocumentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedDocumentsInput = {
    create?: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentItemCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentItemCreateWithoutDocumentInput, DocumentItemUncheckedCreateWithoutDocumentInput> | DocumentItemCreateWithoutDocumentInput[] | DocumentItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentItemCreateOrConnectWithoutDocumentInput | DocumentItemCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentItemCreateManyDocumentInputEnvelope
    connect?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
  }

  export type DocumentItemUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentItemCreateWithoutDocumentInput, DocumentItemUncheckedCreateWithoutDocumentInput> | DocumentItemCreateWithoutDocumentInput[] | DocumentItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentItemCreateOrConnectWithoutDocumentInput | DocumentItemCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentItemCreateManyDocumentInputEnvelope
    connect?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CompanyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    upsert?: CompanyUpsertWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentsInput, CompanyUpdateWithoutDocumentsInput>, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutDocumentsInput
    upsert?: ClientUpsertWithoutDocumentsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutDocumentsInput, ClientUpdateWithoutDocumentsInput>, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedDocumentsInput
    upsert?: UserUpsertWithoutCreatedDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedDocumentsInput, UserUpdateWithoutCreatedDocumentsInput>, UserUncheckedUpdateWithoutCreatedDocumentsInput>
  }

  export type DocumentItemUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentItemCreateWithoutDocumentInput, DocumentItemUncheckedCreateWithoutDocumentInput> | DocumentItemCreateWithoutDocumentInput[] | DocumentItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentItemCreateOrConnectWithoutDocumentInput | DocumentItemCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentItemUpsertWithWhereUniqueWithoutDocumentInput | DocumentItemUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentItemCreateManyDocumentInputEnvelope
    set?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    disconnect?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    delete?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    connect?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    update?: DocumentItemUpdateWithWhereUniqueWithoutDocumentInput | DocumentItemUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentItemUpdateManyWithWhereWithoutDocumentInput | DocumentItemUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentItemScalarWhereInput | DocumentItemScalarWhereInput[]
  }

  export type DocumentItemUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentItemCreateWithoutDocumentInput, DocumentItemUncheckedCreateWithoutDocumentInput> | DocumentItemCreateWithoutDocumentInput[] | DocumentItemUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentItemCreateOrConnectWithoutDocumentInput | DocumentItemCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentItemUpsertWithWhereUniqueWithoutDocumentInput | DocumentItemUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentItemCreateManyDocumentInputEnvelope
    set?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    disconnect?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    delete?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    connect?: DocumentItemWhereUniqueInput | DocumentItemWhereUniqueInput[]
    update?: DocumentItemUpdateWithWhereUniqueWithoutDocumentInput | DocumentItemUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentItemUpdateManyWithWhereWithoutDocumentInput | DocumentItemUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentItemScalarWhereInput | DocumentItemScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutItemsInput = {
    create?: XOR<DocumentCreateWithoutItemsInput, DocumentUncheckedCreateWithoutItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutItemsInput
    connect?: DocumentWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<DocumentCreateWithoutItemsInput, DocumentUncheckedCreateWithoutItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutItemsInput
    upsert?: DocumentUpsertWithoutItemsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutItemsInput, DocumentUpdateWithoutItemsInput>, DocumentUncheckedUpdateWithoutItemsInput>
  }

  export type CompanyCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTemplatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTemplatesInput
    upsert?: CompanyUpsertWithoutTemplatesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTemplatesInput, CompanyUpdateWithoutTemplatesInput>, CompanyUncheckedUpdateWithoutTemplatesInput>
  }

  export type CompanyCreateNestedOneWithoutAssetsInput = {
    create?: XOR<CompanyCreateWithoutAssetsInput, CompanyUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAssetsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EnumAssetTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssetType
  }

  export type CompanyUpdateOneRequiredWithoutAssetsNestedInput = {
    create?: XOR<CompanyCreateWithoutAssetsInput, CompanyUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutAssetsInput
    upsert?: CompanyUpsertWithoutAssetsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutAssetsInput, CompanyUpdateWithoutAssetsInput>, CompanyUncheckedUpdateWithoutAssetsInput>
  }

  export type EmailCreatetoAddressesInput = {
    set: string[]
  }

  export type EmailCreateccAddressesInput = {
    set: string[]
  }

  export type EmailCreatebccAddressesInput = {
    set: string[]
  }

  export type EmailCreatelabelsInput = {
    set: string[]
  }

  export type EmailAttachmentCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
  }

  export type EmailAttachmentUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
  }

  export type EnumEmailFolderFieldUpdateOperationsInput = {
    set?: $Enums.EmailFolder
  }

  export type EmailUpdatetoAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdateccAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdatebccAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdatelabelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailAttachmentUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    upsert?: EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput | EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    set?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    disconnect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    delete?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    update?: EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput | EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailAttachmentUpdateManyWithWhereWithoutEmailInput | EmailAttachmentUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
  }

  export type EmailAttachmentUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput> | EmailAttachmentCreateWithoutEmailInput[] | EmailAttachmentUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailAttachmentCreateOrConnectWithoutEmailInput | EmailAttachmentCreateOrConnectWithoutEmailInput[]
    upsert?: EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput | EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailAttachmentCreateManyEmailInputEnvelope
    set?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    disconnect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    delete?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    connect?: EmailAttachmentWhereUniqueInput | EmailAttachmentWhereUniqueInput[]
    update?: EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput | EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailAttachmentUpdateManyWithWhereWithoutEmailInput | EmailAttachmentUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
  }

  export type EmailCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutAttachmentsInput
    connect?: EmailWhereUniqueInput
  }

  export type EmailUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutAttachmentsInput
    upsert?: EmailUpsertWithoutAttachmentsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutAttachmentsInput, EmailUpdateWithoutAttachmentsInput>, EmailUncheckedUpdateWithoutAttachmentsInput>
  }

  export type EmailOutboxCreatetoAddressesInput = {
    set: string[]
  }

  export type EmailOutboxCreateccAddressesInput = {
    set: string[]
  }

  export type EmailOutboxCreatebccAddressesInput = {
    set: string[]
  }

  export type EmailOutboxUpdatetoAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailOutboxUpdateccAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailOutboxUpdatebccAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumOutboxStatusFieldUpdateOperationsInput = {
    set?: $Enums.OutboxStatus
  }

  export type MailboxCreateNestedManyWithoutDomainInput = {
    create?: XOR<MailboxCreateWithoutDomainInput, MailboxUncheckedCreateWithoutDomainInput> | MailboxCreateWithoutDomainInput[] | MailboxUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutDomainInput | MailboxCreateOrConnectWithoutDomainInput[]
    createMany?: MailboxCreateManyDomainInputEnvelope
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
  }

  export type EmailAliasCreateNestedManyWithoutDomainInput = {
    create?: XOR<EmailAliasCreateWithoutDomainInput, EmailAliasUncheckedCreateWithoutDomainInput> | EmailAliasCreateWithoutDomainInput[] | EmailAliasUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutDomainInput | EmailAliasCreateOrConnectWithoutDomainInput[]
    createMany?: EmailAliasCreateManyDomainInputEnvelope
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
  }

  export type DomainDNSCreateNestedManyWithoutDomainInput = {
    create?: XOR<DomainDNSCreateWithoutDomainInput, DomainDNSUncheckedCreateWithoutDomainInput> | DomainDNSCreateWithoutDomainInput[] | DomainDNSUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DomainDNSCreateOrConnectWithoutDomainInput | DomainDNSCreateOrConnectWithoutDomainInput[]
    createMany?: DomainDNSCreateManyDomainInputEnvelope
    connect?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
  }

  export type MailboxUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<MailboxCreateWithoutDomainInput, MailboxUncheckedCreateWithoutDomainInput> | MailboxCreateWithoutDomainInput[] | MailboxUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutDomainInput | MailboxCreateOrConnectWithoutDomainInput[]
    createMany?: MailboxCreateManyDomainInputEnvelope
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
  }

  export type EmailAliasUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<EmailAliasCreateWithoutDomainInput, EmailAliasUncheckedCreateWithoutDomainInput> | EmailAliasCreateWithoutDomainInput[] | EmailAliasUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutDomainInput | EmailAliasCreateOrConnectWithoutDomainInput[]
    createMany?: EmailAliasCreateManyDomainInputEnvelope
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
  }

  export type DomainDNSUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<DomainDNSCreateWithoutDomainInput, DomainDNSUncheckedCreateWithoutDomainInput> | DomainDNSCreateWithoutDomainInput[] | DomainDNSUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DomainDNSCreateOrConnectWithoutDomainInput | DomainDNSCreateOrConnectWithoutDomainInput[]
    createMany?: DomainDNSCreateManyDomainInputEnvelope
    connect?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
  }

  export type MailboxUpdateManyWithoutDomainNestedInput = {
    create?: XOR<MailboxCreateWithoutDomainInput, MailboxUncheckedCreateWithoutDomainInput> | MailboxCreateWithoutDomainInput[] | MailboxUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutDomainInput | MailboxCreateOrConnectWithoutDomainInput[]
    upsert?: MailboxUpsertWithWhereUniqueWithoutDomainInput | MailboxUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: MailboxCreateManyDomainInputEnvelope
    set?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    disconnect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    delete?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    update?: MailboxUpdateWithWhereUniqueWithoutDomainInput | MailboxUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: MailboxUpdateManyWithWhereWithoutDomainInput | MailboxUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: MailboxScalarWhereInput | MailboxScalarWhereInput[]
  }

  export type EmailAliasUpdateManyWithoutDomainNestedInput = {
    create?: XOR<EmailAliasCreateWithoutDomainInput, EmailAliasUncheckedCreateWithoutDomainInput> | EmailAliasCreateWithoutDomainInput[] | EmailAliasUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutDomainInput | EmailAliasCreateOrConnectWithoutDomainInput[]
    upsert?: EmailAliasUpsertWithWhereUniqueWithoutDomainInput | EmailAliasUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: EmailAliasCreateManyDomainInputEnvelope
    set?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    disconnect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    delete?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    update?: EmailAliasUpdateWithWhereUniqueWithoutDomainInput | EmailAliasUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: EmailAliasUpdateManyWithWhereWithoutDomainInput | EmailAliasUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: EmailAliasScalarWhereInput | EmailAliasScalarWhereInput[]
  }

  export type DomainDNSUpdateManyWithoutDomainNestedInput = {
    create?: XOR<DomainDNSCreateWithoutDomainInput, DomainDNSUncheckedCreateWithoutDomainInput> | DomainDNSCreateWithoutDomainInput[] | DomainDNSUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DomainDNSCreateOrConnectWithoutDomainInput | DomainDNSCreateOrConnectWithoutDomainInput[]
    upsert?: DomainDNSUpsertWithWhereUniqueWithoutDomainInput | DomainDNSUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: DomainDNSCreateManyDomainInputEnvelope
    set?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    disconnect?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    delete?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    connect?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    update?: DomainDNSUpdateWithWhereUniqueWithoutDomainInput | DomainDNSUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: DomainDNSUpdateManyWithWhereWithoutDomainInput | DomainDNSUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: DomainDNSScalarWhereInput | DomainDNSScalarWhereInput[]
  }

  export type MailboxUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<MailboxCreateWithoutDomainInput, MailboxUncheckedCreateWithoutDomainInput> | MailboxCreateWithoutDomainInput[] | MailboxUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: MailboxCreateOrConnectWithoutDomainInput | MailboxCreateOrConnectWithoutDomainInput[]
    upsert?: MailboxUpsertWithWhereUniqueWithoutDomainInput | MailboxUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: MailboxCreateManyDomainInputEnvelope
    set?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    disconnect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    delete?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    connect?: MailboxWhereUniqueInput | MailboxWhereUniqueInput[]
    update?: MailboxUpdateWithWhereUniqueWithoutDomainInput | MailboxUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: MailboxUpdateManyWithWhereWithoutDomainInput | MailboxUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: MailboxScalarWhereInput | MailboxScalarWhereInput[]
  }

  export type EmailAliasUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<EmailAliasCreateWithoutDomainInput, EmailAliasUncheckedCreateWithoutDomainInput> | EmailAliasCreateWithoutDomainInput[] | EmailAliasUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutDomainInput | EmailAliasCreateOrConnectWithoutDomainInput[]
    upsert?: EmailAliasUpsertWithWhereUniqueWithoutDomainInput | EmailAliasUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: EmailAliasCreateManyDomainInputEnvelope
    set?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    disconnect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    delete?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    update?: EmailAliasUpdateWithWhereUniqueWithoutDomainInput | EmailAliasUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: EmailAliasUpdateManyWithWhereWithoutDomainInput | EmailAliasUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: EmailAliasScalarWhereInput | EmailAliasScalarWhereInput[]
  }

  export type DomainDNSUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<DomainDNSCreateWithoutDomainInput, DomainDNSUncheckedCreateWithoutDomainInput> | DomainDNSCreateWithoutDomainInput[] | DomainDNSUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: DomainDNSCreateOrConnectWithoutDomainInput | DomainDNSCreateOrConnectWithoutDomainInput[]
    upsert?: DomainDNSUpsertWithWhereUniqueWithoutDomainInput | DomainDNSUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: DomainDNSCreateManyDomainInputEnvelope
    set?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    disconnect?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    delete?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    connect?: DomainDNSWhereUniqueInput | DomainDNSWhereUniqueInput[]
    update?: DomainDNSUpdateWithWhereUniqueWithoutDomainInput | DomainDNSUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: DomainDNSUpdateManyWithWhereWithoutDomainInput | DomainDNSUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: DomainDNSScalarWhereInput | DomainDNSScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMailboxesInput = {
    create?: XOR<UserCreateWithoutMailboxesInput, UserUncheckedCreateWithoutMailboxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMailboxesInput
    connect?: UserWhereUniqueInput
  }

  export type EmailDomainCreateNestedOneWithoutMailboxesInput = {
    create?: XOR<EmailDomainCreateWithoutMailboxesInput, EmailDomainUncheckedCreateWithoutMailboxesInput>
    connectOrCreate?: EmailDomainCreateOrConnectWithoutMailboxesInput
    connect?: EmailDomainWhereUniqueInput
  }

  export type EmailAliasCreateNestedManyWithoutTargetMailboxInput = {
    create?: XOR<EmailAliasCreateWithoutTargetMailboxInput, EmailAliasUncheckedCreateWithoutTargetMailboxInput> | EmailAliasCreateWithoutTargetMailboxInput[] | EmailAliasUncheckedCreateWithoutTargetMailboxInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutTargetMailboxInput | EmailAliasCreateOrConnectWithoutTargetMailboxInput[]
    createMany?: EmailAliasCreateManyTargetMailboxInputEnvelope
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
  }

  export type EmailAliasUncheckedCreateNestedManyWithoutTargetMailboxInput = {
    create?: XOR<EmailAliasCreateWithoutTargetMailboxInput, EmailAliasUncheckedCreateWithoutTargetMailboxInput> | EmailAliasCreateWithoutTargetMailboxInput[] | EmailAliasUncheckedCreateWithoutTargetMailboxInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutTargetMailboxInput | EmailAliasCreateOrConnectWithoutTargetMailboxInput[]
    createMany?: EmailAliasCreateManyTargetMailboxInputEnvelope
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutMailboxesNestedInput = {
    create?: XOR<UserCreateWithoutMailboxesInput, UserUncheckedCreateWithoutMailboxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMailboxesInput
    upsert?: UserUpsertWithoutMailboxesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMailboxesInput, UserUpdateWithoutMailboxesInput>, UserUncheckedUpdateWithoutMailboxesInput>
  }

  export type EmailDomainUpdateOneRequiredWithoutMailboxesNestedInput = {
    create?: XOR<EmailDomainCreateWithoutMailboxesInput, EmailDomainUncheckedCreateWithoutMailboxesInput>
    connectOrCreate?: EmailDomainCreateOrConnectWithoutMailboxesInput
    upsert?: EmailDomainUpsertWithoutMailboxesInput
    connect?: EmailDomainWhereUniqueInput
    update?: XOR<XOR<EmailDomainUpdateToOneWithWhereWithoutMailboxesInput, EmailDomainUpdateWithoutMailboxesInput>, EmailDomainUncheckedUpdateWithoutMailboxesInput>
  }

  export type EmailAliasUpdateManyWithoutTargetMailboxNestedInput = {
    create?: XOR<EmailAliasCreateWithoutTargetMailboxInput, EmailAliasUncheckedCreateWithoutTargetMailboxInput> | EmailAliasCreateWithoutTargetMailboxInput[] | EmailAliasUncheckedCreateWithoutTargetMailboxInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutTargetMailboxInput | EmailAliasCreateOrConnectWithoutTargetMailboxInput[]
    upsert?: EmailAliasUpsertWithWhereUniqueWithoutTargetMailboxInput | EmailAliasUpsertWithWhereUniqueWithoutTargetMailboxInput[]
    createMany?: EmailAliasCreateManyTargetMailboxInputEnvelope
    set?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    disconnect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    delete?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    update?: EmailAliasUpdateWithWhereUniqueWithoutTargetMailboxInput | EmailAliasUpdateWithWhereUniqueWithoutTargetMailboxInput[]
    updateMany?: EmailAliasUpdateManyWithWhereWithoutTargetMailboxInput | EmailAliasUpdateManyWithWhereWithoutTargetMailboxInput[]
    deleteMany?: EmailAliasScalarWhereInput | EmailAliasScalarWhereInput[]
  }

  export type EmailAliasUncheckedUpdateManyWithoutTargetMailboxNestedInput = {
    create?: XOR<EmailAliasCreateWithoutTargetMailboxInput, EmailAliasUncheckedCreateWithoutTargetMailboxInput> | EmailAliasCreateWithoutTargetMailboxInput[] | EmailAliasUncheckedCreateWithoutTargetMailboxInput[]
    connectOrCreate?: EmailAliasCreateOrConnectWithoutTargetMailboxInput | EmailAliasCreateOrConnectWithoutTargetMailboxInput[]
    upsert?: EmailAliasUpsertWithWhereUniqueWithoutTargetMailboxInput | EmailAliasUpsertWithWhereUniqueWithoutTargetMailboxInput[]
    createMany?: EmailAliasCreateManyTargetMailboxInputEnvelope
    set?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    disconnect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    delete?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    connect?: EmailAliasWhereUniqueInput | EmailAliasWhereUniqueInput[]
    update?: EmailAliasUpdateWithWhereUniqueWithoutTargetMailboxInput | EmailAliasUpdateWithWhereUniqueWithoutTargetMailboxInput[]
    updateMany?: EmailAliasUpdateManyWithWhereWithoutTargetMailboxInput | EmailAliasUpdateManyWithWhereWithoutTargetMailboxInput[]
    deleteMany?: EmailAliasScalarWhereInput | EmailAliasScalarWhereInput[]
  }

  export type MailboxCreateNestedOneWithoutTargetAliasesInput = {
    create?: XOR<MailboxCreateWithoutTargetAliasesInput, MailboxUncheckedCreateWithoutTargetAliasesInput>
    connectOrCreate?: MailboxCreateOrConnectWithoutTargetAliasesInput
    connect?: MailboxWhereUniqueInput
  }

  export type EmailDomainCreateNestedOneWithoutAliasesInput = {
    create?: XOR<EmailDomainCreateWithoutAliasesInput, EmailDomainUncheckedCreateWithoutAliasesInput>
    connectOrCreate?: EmailDomainCreateOrConnectWithoutAliasesInput
    connect?: EmailDomainWhereUniqueInput
  }

  export type MailboxUpdateOneWithoutTargetAliasesNestedInput = {
    create?: XOR<MailboxCreateWithoutTargetAliasesInput, MailboxUncheckedCreateWithoutTargetAliasesInput>
    connectOrCreate?: MailboxCreateOrConnectWithoutTargetAliasesInput
    upsert?: MailboxUpsertWithoutTargetAliasesInput
    disconnect?: MailboxWhereInput | boolean
    delete?: MailboxWhereInput | boolean
    connect?: MailboxWhereUniqueInput
    update?: XOR<XOR<MailboxUpdateToOneWithWhereWithoutTargetAliasesInput, MailboxUpdateWithoutTargetAliasesInput>, MailboxUncheckedUpdateWithoutTargetAliasesInput>
  }

  export type EmailDomainUpdateOneRequiredWithoutAliasesNestedInput = {
    create?: XOR<EmailDomainCreateWithoutAliasesInput, EmailDomainUncheckedCreateWithoutAliasesInput>
    connectOrCreate?: EmailDomainCreateOrConnectWithoutAliasesInput
    upsert?: EmailDomainUpsertWithoutAliasesInput
    connect?: EmailDomainWhereUniqueInput
    update?: XOR<XOR<EmailDomainUpdateToOneWithWhereWithoutAliasesInput, EmailDomainUpdateWithoutAliasesInput>, EmailDomainUncheckedUpdateWithoutAliasesInput>
  }

  export type EmailDomainCreateNestedOneWithoutDnsRecordsInput = {
    create?: XOR<EmailDomainCreateWithoutDnsRecordsInput, EmailDomainUncheckedCreateWithoutDnsRecordsInput>
    connectOrCreate?: EmailDomainCreateOrConnectWithoutDnsRecordsInput
    connect?: EmailDomainWhereUniqueInput
  }

  export type EnumDNSRecordTypeFieldUpdateOperationsInput = {
    set?: $Enums.DNSRecordType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmailDomainUpdateOneRequiredWithoutDnsRecordsNestedInput = {
    create?: XOR<EmailDomainCreateWithoutDnsRecordsInput, EmailDomainUncheckedCreateWithoutDnsRecordsInput>
    connectOrCreate?: EmailDomainCreateOrConnectWithoutDnsRecordsInput
    upsert?: EmailDomainUpsertWithoutDnsRecordsInput
    connect?: EmailDomainWhereUniqueInput
    update?: XOR<XOR<EmailDomainUpdateToOneWithWhereWithoutDnsRecordsInput, EmailDomainUpdateWithoutDnsRecordsInput>, EmailDomainUncheckedUpdateWithoutDnsRecordsInput>
  }

  export type EnumEmailLogStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmailLogStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmailTemplateCreateplaceholdersInput = {
    set: string[]
  }

  export type EnumEmailTemplateCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EmailTemplateCategory
  }

  export type EmailTemplateUpdateplaceholdersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VacationResponderCreateexcludedDomainsInput = {
    set: string[]
  }

  export type VacationResponderCreaterespondedToInput = {
    set: string[]
  }

  export type VacationResponderUpdateexcludedDomainsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VacationResponderUpdaterespondedToInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailTrackingEventCreateNestedManyWithoutTrackingInput = {
    create?: XOR<EmailTrackingEventCreateWithoutTrackingInput, EmailTrackingEventUncheckedCreateWithoutTrackingInput> | EmailTrackingEventCreateWithoutTrackingInput[] | EmailTrackingEventUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailTrackingEventCreateOrConnectWithoutTrackingInput | EmailTrackingEventCreateOrConnectWithoutTrackingInput[]
    createMany?: EmailTrackingEventCreateManyTrackingInputEnvelope
    connect?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
  }

  export type EmailLinkClickCreateNestedManyWithoutTrackingInput = {
    create?: XOR<EmailLinkClickCreateWithoutTrackingInput, EmailLinkClickUncheckedCreateWithoutTrackingInput> | EmailLinkClickCreateWithoutTrackingInput[] | EmailLinkClickUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailLinkClickCreateOrConnectWithoutTrackingInput | EmailLinkClickCreateOrConnectWithoutTrackingInput[]
    createMany?: EmailLinkClickCreateManyTrackingInputEnvelope
    connect?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
  }

  export type EmailTrackingEventUncheckedCreateNestedManyWithoutTrackingInput = {
    create?: XOR<EmailTrackingEventCreateWithoutTrackingInput, EmailTrackingEventUncheckedCreateWithoutTrackingInput> | EmailTrackingEventCreateWithoutTrackingInput[] | EmailTrackingEventUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailTrackingEventCreateOrConnectWithoutTrackingInput | EmailTrackingEventCreateOrConnectWithoutTrackingInput[]
    createMany?: EmailTrackingEventCreateManyTrackingInputEnvelope
    connect?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
  }

  export type EmailLinkClickUncheckedCreateNestedManyWithoutTrackingInput = {
    create?: XOR<EmailLinkClickCreateWithoutTrackingInput, EmailLinkClickUncheckedCreateWithoutTrackingInput> | EmailLinkClickCreateWithoutTrackingInput[] | EmailLinkClickUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailLinkClickCreateOrConnectWithoutTrackingInput | EmailLinkClickCreateOrConnectWithoutTrackingInput[]
    createMany?: EmailLinkClickCreateManyTrackingInputEnvelope
    connect?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
  }

  export type EmailTrackingEventUpdateManyWithoutTrackingNestedInput = {
    create?: XOR<EmailTrackingEventCreateWithoutTrackingInput, EmailTrackingEventUncheckedCreateWithoutTrackingInput> | EmailTrackingEventCreateWithoutTrackingInput[] | EmailTrackingEventUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailTrackingEventCreateOrConnectWithoutTrackingInput | EmailTrackingEventCreateOrConnectWithoutTrackingInput[]
    upsert?: EmailTrackingEventUpsertWithWhereUniqueWithoutTrackingInput | EmailTrackingEventUpsertWithWhereUniqueWithoutTrackingInput[]
    createMany?: EmailTrackingEventCreateManyTrackingInputEnvelope
    set?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    disconnect?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    delete?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    connect?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    update?: EmailTrackingEventUpdateWithWhereUniqueWithoutTrackingInput | EmailTrackingEventUpdateWithWhereUniqueWithoutTrackingInput[]
    updateMany?: EmailTrackingEventUpdateManyWithWhereWithoutTrackingInput | EmailTrackingEventUpdateManyWithWhereWithoutTrackingInput[]
    deleteMany?: EmailTrackingEventScalarWhereInput | EmailTrackingEventScalarWhereInput[]
  }

  export type EmailLinkClickUpdateManyWithoutTrackingNestedInput = {
    create?: XOR<EmailLinkClickCreateWithoutTrackingInput, EmailLinkClickUncheckedCreateWithoutTrackingInput> | EmailLinkClickCreateWithoutTrackingInput[] | EmailLinkClickUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailLinkClickCreateOrConnectWithoutTrackingInput | EmailLinkClickCreateOrConnectWithoutTrackingInput[]
    upsert?: EmailLinkClickUpsertWithWhereUniqueWithoutTrackingInput | EmailLinkClickUpsertWithWhereUniqueWithoutTrackingInput[]
    createMany?: EmailLinkClickCreateManyTrackingInputEnvelope
    set?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    disconnect?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    delete?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    connect?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    update?: EmailLinkClickUpdateWithWhereUniqueWithoutTrackingInput | EmailLinkClickUpdateWithWhereUniqueWithoutTrackingInput[]
    updateMany?: EmailLinkClickUpdateManyWithWhereWithoutTrackingInput | EmailLinkClickUpdateManyWithWhereWithoutTrackingInput[]
    deleteMany?: EmailLinkClickScalarWhereInput | EmailLinkClickScalarWhereInput[]
  }

  export type EmailTrackingEventUncheckedUpdateManyWithoutTrackingNestedInput = {
    create?: XOR<EmailTrackingEventCreateWithoutTrackingInput, EmailTrackingEventUncheckedCreateWithoutTrackingInput> | EmailTrackingEventCreateWithoutTrackingInput[] | EmailTrackingEventUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailTrackingEventCreateOrConnectWithoutTrackingInput | EmailTrackingEventCreateOrConnectWithoutTrackingInput[]
    upsert?: EmailTrackingEventUpsertWithWhereUniqueWithoutTrackingInput | EmailTrackingEventUpsertWithWhereUniqueWithoutTrackingInput[]
    createMany?: EmailTrackingEventCreateManyTrackingInputEnvelope
    set?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    disconnect?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    delete?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    connect?: EmailTrackingEventWhereUniqueInput | EmailTrackingEventWhereUniqueInput[]
    update?: EmailTrackingEventUpdateWithWhereUniqueWithoutTrackingInput | EmailTrackingEventUpdateWithWhereUniqueWithoutTrackingInput[]
    updateMany?: EmailTrackingEventUpdateManyWithWhereWithoutTrackingInput | EmailTrackingEventUpdateManyWithWhereWithoutTrackingInput[]
    deleteMany?: EmailTrackingEventScalarWhereInput | EmailTrackingEventScalarWhereInput[]
  }

  export type EmailLinkClickUncheckedUpdateManyWithoutTrackingNestedInput = {
    create?: XOR<EmailLinkClickCreateWithoutTrackingInput, EmailLinkClickUncheckedCreateWithoutTrackingInput> | EmailLinkClickCreateWithoutTrackingInput[] | EmailLinkClickUncheckedCreateWithoutTrackingInput[]
    connectOrCreate?: EmailLinkClickCreateOrConnectWithoutTrackingInput | EmailLinkClickCreateOrConnectWithoutTrackingInput[]
    upsert?: EmailLinkClickUpsertWithWhereUniqueWithoutTrackingInput | EmailLinkClickUpsertWithWhereUniqueWithoutTrackingInput[]
    createMany?: EmailLinkClickCreateManyTrackingInputEnvelope
    set?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    disconnect?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    delete?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    connect?: EmailLinkClickWhereUniqueInput | EmailLinkClickWhereUniqueInput[]
    update?: EmailLinkClickUpdateWithWhereUniqueWithoutTrackingInput | EmailLinkClickUpdateWithWhereUniqueWithoutTrackingInput[]
    updateMany?: EmailLinkClickUpdateManyWithWhereWithoutTrackingInput | EmailLinkClickUpdateManyWithWhereWithoutTrackingInput[]
    deleteMany?: EmailLinkClickScalarWhereInput | EmailLinkClickScalarWhereInput[]
  }

  export type EmailTrackingCreateNestedOneWithoutOpensInput = {
    create?: XOR<EmailTrackingCreateWithoutOpensInput, EmailTrackingUncheckedCreateWithoutOpensInput>
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutOpensInput
    connect?: EmailTrackingWhereUniqueInput
  }

  export type EmailTrackingUpdateOneRequiredWithoutOpensNestedInput = {
    create?: XOR<EmailTrackingCreateWithoutOpensInput, EmailTrackingUncheckedCreateWithoutOpensInput>
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutOpensInput
    upsert?: EmailTrackingUpsertWithoutOpensInput
    connect?: EmailTrackingWhereUniqueInput
    update?: XOR<XOR<EmailTrackingUpdateToOneWithWhereWithoutOpensInput, EmailTrackingUpdateWithoutOpensInput>, EmailTrackingUncheckedUpdateWithoutOpensInput>
  }

  export type EmailTrackingCreateNestedOneWithoutClicksInput = {
    create?: XOR<EmailTrackingCreateWithoutClicksInput, EmailTrackingUncheckedCreateWithoutClicksInput>
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutClicksInput
    connect?: EmailTrackingWhereUniqueInput
  }

  export type EmailTrackingUpdateOneRequiredWithoutClicksNestedInput = {
    create?: XOR<EmailTrackingCreateWithoutClicksInput, EmailTrackingUncheckedCreateWithoutClicksInput>
    connectOrCreate?: EmailTrackingCreateOrConnectWithoutClicksInput
    upsert?: EmailTrackingUpsertWithoutClicksInput
    connect?: EmailTrackingWhereUniqueInput
    update?: XOR<XOR<EmailTrackingUpdateToOneWithWhereWithoutClicksInput, EmailTrackingUpdateWithoutClicksInput>, EmailTrackingUncheckedUpdateWithoutClicksInput>
  }

  export type EnumMailMergeStatusFieldUpdateOperationsInput = {
    set?: $Enums.MailMergeStatus
  }

  export type EnumMailboxAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.MailboxAuditAction
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAssetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeFilter<$PrismaModel> | $Enums.AssetType
  }

  export type NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssetType | EnumAssetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssetType[] | ListEnumAssetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssetTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssetTypeFilter<$PrismaModel>
    _max?: NestedEnumAssetTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmailFolderFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailFolder | EnumEmailFolderFieldRefInput<$PrismaModel>
    in?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailFolderFilter<$PrismaModel> | $Enums.EmailFolder
  }

  export type NestedEnumEmailFolderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailFolder | EnumEmailFolderFieldRefInput<$PrismaModel>
    in?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailFolder[] | ListEnumEmailFolderFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailFolderWithAggregatesFilter<$PrismaModel> | $Enums.EmailFolder
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailFolderFilter<$PrismaModel>
    _max?: NestedEnumEmailFolderFilter<$PrismaModel>
  }

  export type NestedEnumOutboxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusFilter<$PrismaModel> | $Enums.OutboxStatus
  }

  export type NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OutboxStatus | EnumOutboxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OutboxStatus[] | ListEnumOutboxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOutboxStatusWithAggregatesFilter<$PrismaModel> | $Enums.OutboxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOutboxStatusFilter<$PrismaModel>
    _max?: NestedEnumOutboxStatusFilter<$PrismaModel>
  }

  export type NestedEnumDNSRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DNSRecordType | EnumDNSRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDNSRecordTypeFilter<$PrismaModel> | $Enums.DNSRecordType
  }

  export type NestedEnumDNSRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DNSRecordType | EnumDNSRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DNSRecordType[] | ListEnumDNSRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDNSRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.DNSRecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDNSRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumDNSRecordTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEmailLogStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailLogStatus | EnumEmailLogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailLogStatusFilter<$PrismaModel> | $Enums.EmailLogStatus
  }

  export type NestedEnumEmailLogStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailLogStatus | EnumEmailLogStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailLogStatus[] | ListEnumEmailLogStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailLogStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmailLogStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailLogStatusFilter<$PrismaModel>
    _max?: NestedEnumEmailLogStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmailTemplateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTemplateCategory | EnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTemplateCategoryFilter<$PrismaModel> | $Enums.EmailTemplateCategory
  }

  export type NestedEnumEmailTemplateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailTemplateCategory | EnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailTemplateCategory[] | ListEnumEmailTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailTemplateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EmailTemplateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailTemplateCategoryFilter<$PrismaModel>
    _max?: NestedEnumEmailTemplateCategoryFilter<$PrismaModel>
  }

  export type NestedEnumMailMergeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MailMergeStatus | EnumMailMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailMergeStatusFilter<$PrismaModel> | $Enums.MailMergeStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMailMergeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailMergeStatus | EnumMailMergeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailMergeStatus[] | ListEnumMailMergeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMailMergeStatusWithAggregatesFilter<$PrismaModel> | $Enums.MailMergeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailMergeStatusFilter<$PrismaModel>
    _max?: NestedEnumMailMergeStatusFilter<$PrismaModel>
  }

  export type NestedEnumMailboxAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.MailboxAuditAction | EnumMailboxAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumMailboxAuditActionFilter<$PrismaModel> | $Enums.MailboxAuditAction
  }

  export type NestedEnumMailboxAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MailboxAuditAction | EnumMailboxAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MailboxAuditAction[] | ListEnumMailboxAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumMailboxAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.MailboxAuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMailboxAuditActionFilter<$PrismaModel>
    _max?: NestedEnumMailboxAuditActionFilter<$PrismaModel>
  }

  export type MailboxCreateWithoutUserInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    domain: EmailDomainCreateNestedOneWithoutMailboxesInput
    targetAliases?: EmailAliasCreateNestedManyWithoutTargetMailboxInput
  }

  export type MailboxUncheckedCreateWithoutUserInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    targetAliases?: EmailAliasUncheckedCreateNestedManyWithoutTargetMailboxInput
  }

  export type MailboxCreateOrConnectWithoutUserInput = {
    where: MailboxWhereUniqueInput
    create: XOR<MailboxCreateWithoutUserInput, MailboxUncheckedCreateWithoutUserInput>
  }

  export type MailboxCreateManyUserInputEnvelope = {
    data: MailboxCreateManyUserInput | MailboxCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    templates?: TemplateCreateNestedManyWithoutCompanyInput
    assets?: AssetCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCompanyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type DocumentCreateWithoutCreatedByInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
    client?: ClientCreateNestedOneWithoutDocumentsInput
    items?: DocumentItemCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DocumentItemUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutCreatedByInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCreatedByInput, DocumentUncheckedCreateWithoutCreatedByInput>
  }

  export type DocumentCreateManyCreatedByInputEnvelope = {
    data: DocumentCreateManyCreatedByInput | DocumentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type MailboxUpsertWithWhereUniqueWithoutUserInput = {
    where: MailboxWhereUniqueInput
    update: XOR<MailboxUpdateWithoutUserInput, MailboxUncheckedUpdateWithoutUserInput>
    create: XOR<MailboxCreateWithoutUserInput, MailboxUncheckedCreateWithoutUserInput>
  }

  export type MailboxUpdateWithWhereUniqueWithoutUserInput = {
    where: MailboxWhereUniqueInput
    data: XOR<MailboxUpdateWithoutUserInput, MailboxUncheckedUpdateWithoutUserInput>
  }

  export type MailboxUpdateManyWithWhereWithoutUserInput = {
    where: MailboxScalarWhereInput
    data: XOR<MailboxUpdateManyMutationInput, MailboxUncheckedUpdateManyWithoutUserInput>
  }

  export type MailboxScalarWhereInput = {
    AND?: MailboxScalarWhereInput | MailboxScalarWhereInput[]
    OR?: MailboxScalarWhereInput[]
    NOT?: MailboxScalarWhereInput | MailboxScalarWhereInput[]
    id?: StringFilter<"Mailbox"> | string
    localPart?: StringFilter<"Mailbox"> | string
    displayName?: StringNullableFilter<"Mailbox"> | string | null
    passwordHash?: StringFilter<"Mailbox"> | string
    quotaMb?: IntFilter<"Mailbox"> | number
    usedMb?: IntFilter<"Mailbox"> | number
    maxSendPerDay?: IntFilter<"Mailbox"> | number
    sentToday?: IntFilter<"Mailbox"> | number
    lastSentReset?: DateTimeFilter<"Mailbox"> | Date | string
    isActive?: BoolFilter<"Mailbox"> | boolean
    isAdmin?: BoolFilter<"Mailbox"> | boolean
    autoReply?: BoolFilter<"Mailbox"> | boolean
    autoReplySubject?: StringNullableFilter<"Mailbox"> | string | null
    autoReplyMessage?: StringNullableFilter<"Mailbox"> | string | null
    autoReplyStart?: DateTimeNullableFilter<"Mailbox"> | Date | string | null
    autoReplyEnd?: DateTimeNullableFilter<"Mailbox"> | Date | string | null
    forwardingEnabled?: BoolFilter<"Mailbox"> | boolean
    forwardingAddress?: StringNullableFilter<"Mailbox"> | string | null
    keepCopy?: BoolFilter<"Mailbox"> | boolean
    spamFilterLevel?: StringFilter<"Mailbox"> | string
    spamAction?: StringFilter<"Mailbox"> | string
    signatureHtml?: StringNullableFilter<"Mailbox"> | string | null
    signatureText?: StringNullableFilter<"Mailbox"> | string | null
    userId?: StringNullableFilter<"Mailbox"> | string | null
    domainId?: StringFilter<"Mailbox"> | string
    createdAt?: DateTimeFilter<"Mailbox"> | Date | string
    updatedAt?: DateTimeFilter<"Mailbox"> | Date | string
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUpdateManyWithoutCompanyNestedInput
    assets?: AssetUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCompanyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCreatedByInput, DocumentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DocumentCreateWithoutCreatedByInput, DocumentUncheckedCreateWithoutCreatedByInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCreatedByInput, DocumentUncheckedUpdateWithoutCreatedByInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCreatedByInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    documentNumber?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    issueDate?: DateTimeFilter<"Document"> | Date | string
    dueDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    subtotal?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Document"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Document"> | string
    notes?: StringNullableFilter<"Document"> | string | null
    terms?: StringNullableFilter<"Document"> | string | null
    pdfUrl?: StringNullableFilter<"Document"> | string | null
    companyId?: StringFilter<"Document"> | string
    clientId?: StringNullableFilter<"Document"> | string | null
    createdById?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxUncheckedCreateNestedManyWithoutUserInput
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCompanyInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutDocumentsInput
    createdBy: UserCreateNestedOneWithoutCreatedDocumentsInput
    items?: DocumentItemCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutCompanyInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    clientId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DocumentItemUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentCreateManyCompanyInputEnvelope = {
    data: DocumentCreateManyCompanyInput | DocumentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutCompanyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCompanyInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
  }

  export type ClientCreateManyCompanyInputEnvelope = {
    data: ClientCreateManyCompanyInput | ClientCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    description?: string | null
    isDefault?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    description?: string | null
    isDefault?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCreateOrConnectWithoutCompanyInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutCompanyInput, TemplateUncheckedCreateWithoutCompanyInput>
  }

  export type TemplateCreateManyCompanyInputEnvelope = {
    data: TemplateCreateManyCompanyInput | TemplateCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AssetCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
  }

  export type AssetUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
  }

  export type AssetCreateOrConnectWithoutCompanyInput = {
    where: AssetWhereUniqueInput
    create: XOR<AssetCreateWithoutCompanyInput, AssetUncheckedCreateWithoutCompanyInput>
  }

  export type AssetCreateManyCompanyInputEnvelope = {
    data: AssetCreateManyCompanyInput | AssetCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    jobTitle?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    signatureEnabled?: BoolFilter<"User"> | boolean
    signatureStyle?: StringFilter<"User"> | string
    signatureHtml?: StringNullableFilter<"User"> | string | null
    linkedinUrl?: StringNullableFilter<"User"> | string | null
    twitterUrl?: StringNullableFilter<"User"> | string | null
    instagramUrl?: StringNullableFilter<"User"> | string | null
    location?: StringNullableFilter<"User"> | string | null
    officeAddress?: StringNullableFilter<"User"> | string | null
    mailPassword?: StringNullableFilter<"User"> | string | null
    totpSecret?: StringNullableFilter<"User"> | string | null
    totpEnabled?: BoolFilter<"User"> | boolean
    totpBackupCodes?: StringNullableListFilter<"User">
    totpLastUsed?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoProvider?: StringNullableFilter<"User"> | string | null
    ssoExternalId?: StringNullableFilter<"User"> | string | null
    lastSsoLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    primaryMailboxId?: StringNullableFilter<"User"> | string | null
    autoProvisionEmail?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutCompanyInput, ClientUncheckedUpdateWithoutCompanyInput>
    create: XOR<ClientCreateWithoutCompanyInput, ClientUncheckedCreateWithoutCompanyInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutCompanyInput, ClientUncheckedUpdateWithoutCompanyInput>
  }

  export type ClientUpdateManyWithWhereWithoutCompanyInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    contactPerson?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    companyId?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
  }

  export type TemplateUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutCompanyInput, TemplateUncheckedUpdateWithoutCompanyInput>
    create: XOR<TemplateCreateWithoutCompanyInput, TemplateUncheckedCreateWithoutCompanyInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutCompanyInput, TemplateUncheckedUpdateWithoutCompanyInput>
  }

  export type TemplateUpdateManyWithWhereWithoutCompanyInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TemplateScalarWhereInput = {
    AND?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    OR?: TemplateScalarWhereInput[]
    NOT?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    id?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    type?: EnumDocumentTypeFilter<"Template"> | $Enums.DocumentType
    description?: StringNullableFilter<"Template"> | string | null
    isDefault?: BoolFilter<"Template"> | boolean
    config?: JsonNullableFilter<"Template">
    companyId?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
  }

  export type AssetUpsertWithWhereUniqueWithoutCompanyInput = {
    where: AssetWhereUniqueInput
    update: XOR<AssetUpdateWithoutCompanyInput, AssetUncheckedUpdateWithoutCompanyInput>
    create: XOR<AssetCreateWithoutCompanyInput, AssetUncheckedCreateWithoutCompanyInput>
  }

  export type AssetUpdateWithWhereUniqueWithoutCompanyInput = {
    where: AssetWhereUniqueInput
    data: XOR<AssetUpdateWithoutCompanyInput, AssetUncheckedUpdateWithoutCompanyInput>
  }

  export type AssetUpdateManyWithWhereWithoutCompanyInput = {
    where: AssetScalarWhereInput
    data: XOR<AssetUpdateManyMutationInput, AssetUncheckedUpdateManyWithoutCompanyInput>
  }

  export type AssetScalarWhereInput = {
    AND?: AssetScalarWhereInput | AssetScalarWhereInput[]
    OR?: AssetScalarWhereInput[]
    NOT?: AssetScalarWhereInput | AssetScalarWhereInput[]
    id?: StringFilter<"Asset"> | string
    name?: StringFilter<"Asset"> | string
    type?: EnumAssetTypeFilter<"Asset"> | $Enums.AssetType
    mimeType?: StringFilter<"Asset"> | string
    size?: IntFilter<"Asset"> | number
    url?: StringFilter<"Asset"> | string
    companyId?: StringFilter<"Asset"> | string
    createdAt?: DateTimeFilter<"Asset"> | Date | string
  }

  export type CompanyCreateWithoutClientsInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    templates?: TemplateCreateNestedManyWithoutCompanyInput
    assets?: AssetCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutClientsInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCompanyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutClientsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
  }

  export type DocumentCreateWithoutClientInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
    createdBy: UserCreateNestedOneWithoutCreatedDocumentsInput
    items?: DocumentItemCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutClientInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: DocumentItemUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutClientInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentCreateManyClientInputEnvelope = {
    data: DocumentCreateManyClientInput | DocumentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutClientsInput = {
    update: XOR<CompanyUpdateWithoutClientsInput, CompanyUncheckedUpdateWithoutClientsInput>
    create: XOR<CompanyCreateWithoutClientsInput, CompanyUncheckedCreateWithoutClientsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutClientsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutClientsInput, CompanyUncheckedUpdateWithoutClientsInput>
  }

  export type CompanyUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUpdateManyWithoutCompanyNestedInput
    assets?: AssetUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCompanyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
    create: XOR<DocumentCreateWithoutClientInput, DocumentUncheckedCreateWithoutClientInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClientInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClientInput, DocumentUncheckedUpdateWithoutClientInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClientInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientInput>
  }

  export type CompanyCreateWithoutDocumentsInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    templates?: TemplateCreateNestedManyWithoutCompanyInput
    assets?: AssetCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCompanyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
  }

  export type ClientCreateWithoutDocumentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutClientsInput
  }

  export type ClientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutDocumentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
  }

  export type UserCreateWithoutCreatedDocumentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxCreateNestedManyWithoutUserInput
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCreatedDocumentsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
  }

  export type DocumentItemCreateWithoutDocumentInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type DocumentItemUncheckedCreateWithoutDocumentInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type DocumentItemCreateOrConnectWithoutDocumentInput = {
    where: DocumentItemWhereUniqueInput
    create: XOR<DocumentItemCreateWithoutDocumentInput, DocumentItemUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentItemCreateManyDocumentInputEnvelope = {
    data: DocumentItemCreateManyDocumentInput | DocumentItemCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutDocumentsInput = {
    update: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUpdateManyWithoutCompanyNestedInput
    assets?: AssetUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCompanyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ClientUpsertWithoutDocumentsInput = {
    update: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientCreateWithoutDocumentsInput, ClientUncheckedCreateWithoutDocumentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutDocumentsInput, ClientUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ClientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCreatedDocumentsInput = {
    update: XOR<UserUpdateWithoutCreatedDocumentsInput, UserUncheckedUpdateWithoutCreatedDocumentsInput>
    create: XOR<UserCreateWithoutCreatedDocumentsInput, UserUncheckedCreateWithoutCreatedDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedDocumentsInput, UserUncheckedUpdateWithoutCreatedDocumentsInput>
  }

  export type UserUpdateWithoutCreatedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUpdateManyWithoutUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentItemUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentItemWhereUniqueInput
    update: XOR<DocumentItemUpdateWithoutDocumentInput, DocumentItemUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentItemCreateWithoutDocumentInput, DocumentItemUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentItemUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentItemWhereUniqueInput
    data: XOR<DocumentItemUpdateWithoutDocumentInput, DocumentItemUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentItemUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentItemScalarWhereInput
    data: XOR<DocumentItemUpdateManyMutationInput, DocumentItemUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentItemScalarWhereInput = {
    AND?: DocumentItemScalarWhereInput | DocumentItemScalarWhereInput[]
    OR?: DocumentItemScalarWhereInput[]
    NOT?: DocumentItemScalarWhereInput | DocumentItemScalarWhereInput[]
    id?: StringFilter<"DocumentItem"> | string
    description?: StringFilter<"DocumentItem"> | string
    quantity?: IntFilter<"DocumentItem"> | number
    unitPrice?: DecimalFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"DocumentItem"> | Decimal | DecimalJsLike | number | string
    documentId?: StringFilter<"DocumentItem"> | string
    createdAt?: DateTimeFilter<"DocumentItem"> | Date | string
  }

  export type DocumentCreateWithoutItemsInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
    client?: ClientCreateNestedOneWithoutDocumentsInput
    createdBy: UserCreateNestedOneWithoutCreatedDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutItemsInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    clientId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutItemsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutItemsInput, DocumentUncheckedCreateWithoutItemsInput>
  }

  export type DocumentUpsertWithoutItemsInput = {
    update: XOR<DocumentUpdateWithoutItemsInput, DocumentUncheckedUpdateWithoutItemsInput>
    create: XOR<DocumentCreateWithoutItemsInput, DocumentUncheckedCreateWithoutItemsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutItemsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutItemsInput, DocumentUncheckedUpdateWithoutItemsInput>
  }

  export type DocumentUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateWithoutTemplatesInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    assets?: AssetCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTemplatesInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    assets?: AssetUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTemplatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
  }

  export type CompanyUpsertWithoutTemplatesInput = {
    update: XOR<CompanyUpdateWithoutTemplatesInput, CompanyUncheckedUpdateWithoutTemplatesInput>
    create: XOR<CompanyCreateWithoutTemplatesInput, CompanyUncheckedCreateWithoutTemplatesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTemplatesInput, CompanyUncheckedUpdateWithoutTemplatesInput>
  }

  export type CompanyUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    assets?: AssetUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    assets?: AssetUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutAssetsInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    clients?: ClientCreateNestedManyWithoutCompanyInput
    templates?: TemplateCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAssetsInput = {
    id?: string
    name: string
    tagline?: string | null
    email: string
    phone: string
    website?: string | null
    addressLine1: string
    addressLine2?: string | null
    city: string
    country: string
    postalCode?: string | null
    logoUrl?: string | null
    primaryColor?: string
    secondaryColor?: string
    taxId?: string | null
    registrationNo?: string | null
    bankName?: string | null
    bankAccount?: string | null
    bankBranch?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    clients?: ClientUncheckedCreateNestedManyWithoutCompanyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAssetsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAssetsInput, CompanyUncheckedCreateWithoutAssetsInput>
  }

  export type CompanyUpsertWithoutAssetsInput = {
    update: XOR<CompanyUpdateWithoutAssetsInput, CompanyUncheckedUpdateWithoutAssetsInput>
    create: XOR<CompanyCreateWithoutAssetsInput, CompanyUncheckedCreateWithoutAssetsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutAssetsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutAssetsInput, CompanyUncheckedUpdateWithoutAssetsInput>
  }

  export type CompanyUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    clients?: ClientUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tagline?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNo?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankBranch?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    clients?: ClientUncheckedUpdateManyWithoutCompanyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EmailAttachmentCreateWithoutEmailInput = {
    id?: string
    filename: string
    mimeType: string
    size: number
    url?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentUncheckedCreateWithoutEmailInput = {
    id?: string
    filename: string
    mimeType: string
    size: number
    url?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentCreateOrConnectWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    create: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput>
  }

  export type EmailAttachmentCreateManyEmailInputEnvelope = {
    data: EmailAttachmentCreateManyEmailInput | EmailAttachmentCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailAttachmentUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    update: XOR<EmailAttachmentUpdateWithoutEmailInput, EmailAttachmentUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailAttachmentCreateWithoutEmailInput, EmailAttachmentUncheckedCreateWithoutEmailInput>
  }

  export type EmailAttachmentUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailAttachmentWhereUniqueInput
    data: XOR<EmailAttachmentUpdateWithoutEmailInput, EmailAttachmentUncheckedUpdateWithoutEmailInput>
  }

  export type EmailAttachmentUpdateManyWithWhereWithoutEmailInput = {
    where: EmailAttachmentScalarWhereInput
    data: XOR<EmailAttachmentUpdateManyMutationInput, EmailAttachmentUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailAttachmentScalarWhereInput = {
    AND?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
    OR?: EmailAttachmentScalarWhereInput[]
    NOT?: EmailAttachmentScalarWhereInput | EmailAttachmentScalarWhereInput[]
    id?: StringFilter<"EmailAttachment"> | string
    filename?: StringFilter<"EmailAttachment"> | string
    mimeType?: StringFilter<"EmailAttachment"> | string
    size?: IntFilter<"EmailAttachment"> | number
    url?: StringNullableFilter<"EmailAttachment"> | string | null
    emailId?: StringFilter<"EmailAttachment"> | string
    createdAt?: DateTimeFilter<"EmailAttachment"> | Date | string
  }

  export type EmailCreateWithoutAttachmentsInput = {
    id?: string
    messageId: string
    folder?: $Enums.EmailFolder
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailCreatetoAddressesInput | string[]
    ccAddresses?: EmailCreateccAddressesInput | string[]
    bccAddresses?: EmailCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    snippet?: string | null
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: EmailCreatelabelsInput | string[]
    priority?: string
    snoozedUntil?: Date | string | null
    snoozedFromFolder?: string | null
    userId: string
    sentAt?: Date | string
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    messageId: string
    folder?: $Enums.EmailFolder
    fromName?: string | null
    fromAddress: string
    toAddresses?: EmailCreatetoAddressesInput | string[]
    ccAddresses?: EmailCreateccAddressesInput | string[]
    bccAddresses?: EmailCreatebccAddressesInput | string[]
    subject: string
    textBody?: string | null
    htmlBody?: string | null
    snippet?: string | null
    isRead?: boolean
    isStarred?: boolean
    hasAttachments?: boolean
    labels?: EmailCreatelabelsInput | string[]
    priority?: string
    snoozedUntil?: Date | string | null
    snoozedFromFolder?: string | null
    userId: string
    sentAt?: Date | string
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCreateOrConnectWithoutAttachmentsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
  }

  export type EmailUpsertWithoutAttachmentsInput = {
    update: XOR<EmailUpdateWithoutAttachmentsInput, EmailUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<EmailCreateWithoutAttachmentsInput, EmailUncheckedCreateWithoutAttachmentsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutAttachmentsInput, EmailUncheckedUpdateWithoutAttachmentsInput>
  }

  export type EmailUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    folder?: EnumEmailFolderFieldUpdateOperationsInput | $Enums.EmailFolder
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailUpdatetoAddressesInput | string[]
    ccAddresses?: EmailUpdateccAddressesInput | string[]
    bccAddresses?: EmailUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    labels?: EmailUpdatelabelsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snoozedFromFolder?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    folder?: EnumEmailFolderFieldUpdateOperationsInput | $Enums.EmailFolder
    fromName?: NullableStringFieldUpdateOperationsInput | string | null
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddresses?: EmailUpdatetoAddressesInput | string[]
    ccAddresses?: EmailUpdateccAddressesInput | string[]
    bccAddresses?: EmailUpdatebccAddressesInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    textBody?: NullableStringFieldUpdateOperationsInput | string | null
    htmlBody?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isStarred?: BoolFieldUpdateOperationsInput | boolean
    hasAttachments?: BoolFieldUpdateOperationsInput | boolean
    labels?: EmailUpdatelabelsInput | string[]
    priority?: StringFieldUpdateOperationsInput | string
    snoozedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snoozedFromFolder?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxCreateWithoutDomainInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutMailboxesInput
    targetAliases?: EmailAliasCreateNestedManyWithoutTargetMailboxInput
  }

  export type MailboxUncheckedCreateWithoutDomainInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetAliases?: EmailAliasUncheckedCreateNestedManyWithoutTargetMailboxInput
  }

  export type MailboxCreateOrConnectWithoutDomainInput = {
    where: MailboxWhereUniqueInput
    create: XOR<MailboxCreateWithoutDomainInput, MailboxUncheckedCreateWithoutDomainInput>
  }

  export type MailboxCreateManyDomainInputEnvelope = {
    data: MailboxCreateManyDomainInput | MailboxCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type EmailAliasCreateWithoutDomainInput = {
    id?: string
    localPart: string
    externalTarget?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    targetMailbox?: MailboxCreateNestedOneWithoutTargetAliasesInput
  }

  export type EmailAliasUncheckedCreateWithoutDomainInput = {
    id?: string
    localPart: string
    targetMailboxId?: string | null
    externalTarget?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAliasCreateOrConnectWithoutDomainInput = {
    where: EmailAliasWhereUniqueInput
    create: XOR<EmailAliasCreateWithoutDomainInput, EmailAliasUncheckedCreateWithoutDomainInput>
  }

  export type EmailAliasCreateManyDomainInputEnvelope = {
    data: EmailAliasCreateManyDomainInput | EmailAliasCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type DomainDNSCreateWithoutDomainInput = {
    id?: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority?: number | null
    ttl?: number
    description?: string | null
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainDNSUncheckedCreateWithoutDomainInput = {
    id?: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority?: number | null
    ttl?: number
    description?: string | null
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainDNSCreateOrConnectWithoutDomainInput = {
    where: DomainDNSWhereUniqueInput
    create: XOR<DomainDNSCreateWithoutDomainInput, DomainDNSUncheckedCreateWithoutDomainInput>
  }

  export type DomainDNSCreateManyDomainInputEnvelope = {
    data: DomainDNSCreateManyDomainInput | DomainDNSCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type MailboxUpsertWithWhereUniqueWithoutDomainInput = {
    where: MailboxWhereUniqueInput
    update: XOR<MailboxUpdateWithoutDomainInput, MailboxUncheckedUpdateWithoutDomainInput>
    create: XOR<MailboxCreateWithoutDomainInput, MailboxUncheckedCreateWithoutDomainInput>
  }

  export type MailboxUpdateWithWhereUniqueWithoutDomainInput = {
    where: MailboxWhereUniqueInput
    data: XOR<MailboxUpdateWithoutDomainInput, MailboxUncheckedUpdateWithoutDomainInput>
  }

  export type MailboxUpdateManyWithWhereWithoutDomainInput = {
    where: MailboxScalarWhereInput
    data: XOR<MailboxUpdateManyMutationInput, MailboxUncheckedUpdateManyWithoutDomainInput>
  }

  export type EmailAliasUpsertWithWhereUniqueWithoutDomainInput = {
    where: EmailAliasWhereUniqueInput
    update: XOR<EmailAliasUpdateWithoutDomainInput, EmailAliasUncheckedUpdateWithoutDomainInput>
    create: XOR<EmailAliasCreateWithoutDomainInput, EmailAliasUncheckedCreateWithoutDomainInput>
  }

  export type EmailAliasUpdateWithWhereUniqueWithoutDomainInput = {
    where: EmailAliasWhereUniqueInput
    data: XOR<EmailAliasUpdateWithoutDomainInput, EmailAliasUncheckedUpdateWithoutDomainInput>
  }

  export type EmailAliasUpdateManyWithWhereWithoutDomainInput = {
    where: EmailAliasScalarWhereInput
    data: XOR<EmailAliasUpdateManyMutationInput, EmailAliasUncheckedUpdateManyWithoutDomainInput>
  }

  export type EmailAliasScalarWhereInput = {
    AND?: EmailAliasScalarWhereInput | EmailAliasScalarWhereInput[]
    OR?: EmailAliasScalarWhereInput[]
    NOT?: EmailAliasScalarWhereInput | EmailAliasScalarWhereInput[]
    id?: StringFilter<"EmailAlias"> | string
    localPart?: StringFilter<"EmailAlias"> | string
    targetMailboxId?: StringNullableFilter<"EmailAlias"> | string | null
    externalTarget?: StringNullableFilter<"EmailAlias"> | string | null
    isActive?: BoolFilter<"EmailAlias"> | boolean
    domainId?: StringFilter<"EmailAlias"> | string
    createdAt?: DateTimeFilter<"EmailAlias"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAlias"> | Date | string
  }

  export type DomainDNSUpsertWithWhereUniqueWithoutDomainInput = {
    where: DomainDNSWhereUniqueInput
    update: XOR<DomainDNSUpdateWithoutDomainInput, DomainDNSUncheckedUpdateWithoutDomainInput>
    create: XOR<DomainDNSCreateWithoutDomainInput, DomainDNSUncheckedCreateWithoutDomainInput>
  }

  export type DomainDNSUpdateWithWhereUniqueWithoutDomainInput = {
    where: DomainDNSWhereUniqueInput
    data: XOR<DomainDNSUpdateWithoutDomainInput, DomainDNSUncheckedUpdateWithoutDomainInput>
  }

  export type DomainDNSUpdateManyWithWhereWithoutDomainInput = {
    where: DomainDNSScalarWhereInput
    data: XOR<DomainDNSUpdateManyMutationInput, DomainDNSUncheckedUpdateManyWithoutDomainInput>
  }

  export type DomainDNSScalarWhereInput = {
    AND?: DomainDNSScalarWhereInput | DomainDNSScalarWhereInput[]
    OR?: DomainDNSScalarWhereInput[]
    NOT?: DomainDNSScalarWhereInput | DomainDNSScalarWhereInput[]
    id?: StringFilter<"DomainDNS"> | string
    recordType?: EnumDNSRecordTypeFilter<"DomainDNS"> | $Enums.DNSRecordType
    name?: StringFilter<"DomainDNS"> | string
    value?: StringFilter<"DomainDNS"> | string
    priority?: IntNullableFilter<"DomainDNS"> | number | null
    ttl?: IntFilter<"DomainDNS"> | number
    description?: StringNullableFilter<"DomainDNS"> | string | null
    isRequired?: BoolFilter<"DomainDNS"> | boolean
    isVerified?: BoolFilter<"DomainDNS"> | boolean
    lastCheckedAt?: DateTimeNullableFilter<"DomainDNS"> | Date | string | null
    domainId?: StringFilter<"DomainDNS"> | string
    createdAt?: DateTimeFilter<"DomainDNS"> | Date | string
    updatedAt?: DateTimeFilter<"DomainDNS"> | Date | string
  }

  export type UserCreateWithoutMailboxesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
    createdDocuments?: DocumentCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutMailboxesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdDocuments?: DocumentUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutMailboxesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMailboxesInput, UserUncheckedCreateWithoutMailboxesInput>
  }

  export type EmailDomainCreateWithoutMailboxesInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aliases?: EmailAliasCreateNestedManyWithoutDomainInput
    dnsRecords?: DomainDNSCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainUncheckedCreateWithoutMailboxesInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aliases?: EmailAliasUncheckedCreateNestedManyWithoutDomainInput
    dnsRecords?: DomainDNSUncheckedCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainCreateOrConnectWithoutMailboxesInput = {
    where: EmailDomainWhereUniqueInput
    create: XOR<EmailDomainCreateWithoutMailboxesInput, EmailDomainUncheckedCreateWithoutMailboxesInput>
  }

  export type EmailAliasCreateWithoutTargetMailboxInput = {
    id?: string
    localPart: string
    externalTarget?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    domain: EmailDomainCreateNestedOneWithoutAliasesInput
  }

  export type EmailAliasUncheckedCreateWithoutTargetMailboxInput = {
    id?: string
    localPart: string
    externalTarget?: string | null
    isActive?: boolean
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAliasCreateOrConnectWithoutTargetMailboxInput = {
    where: EmailAliasWhereUniqueInput
    create: XOR<EmailAliasCreateWithoutTargetMailboxInput, EmailAliasUncheckedCreateWithoutTargetMailboxInput>
  }

  export type EmailAliasCreateManyTargetMailboxInputEnvelope = {
    data: EmailAliasCreateManyTargetMailboxInput | EmailAliasCreateManyTargetMailboxInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMailboxesInput = {
    update: XOR<UserUpdateWithoutMailboxesInput, UserUncheckedUpdateWithoutMailboxesInput>
    create: XOR<UserCreateWithoutMailboxesInput, UserUncheckedCreateWithoutMailboxesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMailboxesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMailboxesInput, UserUncheckedUpdateWithoutMailboxesInput>
  }

  export type UserUpdateWithoutMailboxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMailboxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type EmailDomainUpsertWithoutMailboxesInput = {
    update: XOR<EmailDomainUpdateWithoutMailboxesInput, EmailDomainUncheckedUpdateWithoutMailboxesInput>
    create: XOR<EmailDomainCreateWithoutMailboxesInput, EmailDomainUncheckedCreateWithoutMailboxesInput>
    where?: EmailDomainWhereInput
  }

  export type EmailDomainUpdateToOneWithWhereWithoutMailboxesInput = {
    where?: EmailDomainWhereInput
    data: XOR<EmailDomainUpdateWithoutMailboxesInput, EmailDomainUncheckedUpdateWithoutMailboxesInput>
  }

  export type EmailDomainUpdateWithoutMailboxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aliases?: EmailAliasUpdateManyWithoutDomainNestedInput
    dnsRecords?: DomainDNSUpdateManyWithoutDomainNestedInput
  }

  export type EmailDomainUncheckedUpdateWithoutMailboxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aliases?: EmailAliasUncheckedUpdateManyWithoutDomainNestedInput
    dnsRecords?: DomainDNSUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type EmailAliasUpsertWithWhereUniqueWithoutTargetMailboxInput = {
    where: EmailAliasWhereUniqueInput
    update: XOR<EmailAliasUpdateWithoutTargetMailboxInput, EmailAliasUncheckedUpdateWithoutTargetMailboxInput>
    create: XOR<EmailAliasCreateWithoutTargetMailboxInput, EmailAliasUncheckedCreateWithoutTargetMailboxInput>
  }

  export type EmailAliasUpdateWithWhereUniqueWithoutTargetMailboxInput = {
    where: EmailAliasWhereUniqueInput
    data: XOR<EmailAliasUpdateWithoutTargetMailboxInput, EmailAliasUncheckedUpdateWithoutTargetMailboxInput>
  }

  export type EmailAliasUpdateManyWithWhereWithoutTargetMailboxInput = {
    where: EmailAliasScalarWhereInput
    data: XOR<EmailAliasUpdateManyMutationInput, EmailAliasUncheckedUpdateManyWithoutTargetMailboxInput>
  }

  export type MailboxCreateWithoutTargetAliasesInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutMailboxesInput
    domain: EmailDomainCreateNestedOneWithoutMailboxesInput
  }

  export type MailboxUncheckedCreateWithoutTargetAliasesInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    userId?: string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailboxCreateOrConnectWithoutTargetAliasesInput = {
    where: MailboxWhereUniqueInput
    create: XOR<MailboxCreateWithoutTargetAliasesInput, MailboxUncheckedCreateWithoutTargetAliasesInput>
  }

  export type EmailDomainCreateWithoutAliasesInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxCreateNestedManyWithoutDomainInput
    dnsRecords?: DomainDNSCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainUncheckedCreateWithoutAliasesInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxUncheckedCreateNestedManyWithoutDomainInput
    dnsRecords?: DomainDNSUncheckedCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainCreateOrConnectWithoutAliasesInput = {
    where: EmailDomainWhereUniqueInput
    create: XOR<EmailDomainCreateWithoutAliasesInput, EmailDomainUncheckedCreateWithoutAliasesInput>
  }

  export type MailboxUpsertWithoutTargetAliasesInput = {
    update: XOR<MailboxUpdateWithoutTargetAliasesInput, MailboxUncheckedUpdateWithoutTargetAliasesInput>
    create: XOR<MailboxCreateWithoutTargetAliasesInput, MailboxUncheckedCreateWithoutTargetAliasesInput>
    where?: MailboxWhereInput
  }

  export type MailboxUpdateToOneWithWhereWithoutTargetAliasesInput = {
    where?: MailboxWhereInput
    data: XOR<MailboxUpdateWithoutTargetAliasesInput, MailboxUncheckedUpdateWithoutTargetAliasesInput>
  }

  export type MailboxUpdateWithoutTargetAliasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMailboxesNestedInput
    domain?: EmailDomainUpdateOneRequiredWithoutMailboxesNestedInput
  }

  export type MailboxUncheckedUpdateWithoutTargetAliasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailDomainUpsertWithoutAliasesInput = {
    update: XOR<EmailDomainUpdateWithoutAliasesInput, EmailDomainUncheckedUpdateWithoutAliasesInput>
    create: XOR<EmailDomainCreateWithoutAliasesInput, EmailDomainUncheckedCreateWithoutAliasesInput>
    where?: EmailDomainWhereInput
  }

  export type EmailDomainUpdateToOneWithWhereWithoutAliasesInput = {
    where?: EmailDomainWhereInput
    data: XOR<EmailDomainUpdateWithoutAliasesInput, EmailDomainUncheckedUpdateWithoutAliasesInput>
  }

  export type EmailDomainUpdateWithoutAliasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUpdateManyWithoutDomainNestedInput
    dnsRecords?: DomainDNSUpdateManyWithoutDomainNestedInput
  }

  export type EmailDomainUncheckedUpdateWithoutAliasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUncheckedUpdateManyWithoutDomainNestedInput
    dnsRecords?: DomainDNSUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type EmailDomainCreateWithoutDnsRecordsInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxCreateNestedManyWithoutDomainInput
    aliases?: EmailAliasCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainUncheckedCreateWithoutDnsRecordsInput = {
    id?: string
    domain: string
    isVerified?: boolean
    isActive?: boolean
    verificationCode?: string | null
    verificationMethod?: string
    verifiedAt?: Date | string | null
    dkimSelector?: string | null
    dkimPublicKey?: string | null
    dkimPrivateKey?: string | null
    dkimVerified?: boolean
    spfRecord?: string | null
    spfVerified?: boolean
    dmarcPolicy?: string
    dmarcRecord?: string | null
    dmarcVerified?: boolean
    mxVerified?: boolean
    catchAllEnabled?: boolean
    catchAllMailboxId?: string | null
    maxMailboxes?: number
    maxAliases?: number
    totalStorageQuotaMb?: number
    usedStorageMb?: number
    companyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mailboxes?: MailboxUncheckedCreateNestedManyWithoutDomainInput
    aliases?: EmailAliasUncheckedCreateNestedManyWithoutDomainInput
  }

  export type EmailDomainCreateOrConnectWithoutDnsRecordsInput = {
    where: EmailDomainWhereUniqueInput
    create: XOR<EmailDomainCreateWithoutDnsRecordsInput, EmailDomainUncheckedCreateWithoutDnsRecordsInput>
  }

  export type EmailDomainUpsertWithoutDnsRecordsInput = {
    update: XOR<EmailDomainUpdateWithoutDnsRecordsInput, EmailDomainUncheckedUpdateWithoutDnsRecordsInput>
    create: XOR<EmailDomainCreateWithoutDnsRecordsInput, EmailDomainUncheckedCreateWithoutDnsRecordsInput>
    where?: EmailDomainWhereInput
  }

  export type EmailDomainUpdateToOneWithWhereWithoutDnsRecordsInput = {
    where?: EmailDomainWhereInput
    data: XOR<EmailDomainUpdateWithoutDnsRecordsInput, EmailDomainUncheckedUpdateWithoutDnsRecordsInput>
  }

  export type EmailDomainUpdateWithoutDnsRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUpdateManyWithoutDomainNestedInput
    aliases?: EmailAliasUpdateManyWithoutDomainNestedInput
  }

  export type EmailDomainUncheckedUpdateWithoutDnsRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationMethod?: StringFieldUpdateOperationsInput | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dkimSelector?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPublicKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimPrivateKey?: NullableStringFieldUpdateOperationsInput | string | null
    dkimVerified?: BoolFieldUpdateOperationsInput | boolean
    spfRecord?: NullableStringFieldUpdateOperationsInput | string | null
    spfVerified?: BoolFieldUpdateOperationsInput | boolean
    dmarcPolicy?: StringFieldUpdateOperationsInput | string
    dmarcRecord?: NullableStringFieldUpdateOperationsInput | string | null
    dmarcVerified?: BoolFieldUpdateOperationsInput | boolean
    mxVerified?: BoolFieldUpdateOperationsInput | boolean
    catchAllEnabled?: BoolFieldUpdateOperationsInput | boolean
    catchAllMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    maxMailboxes?: IntFieldUpdateOperationsInput | number
    maxAliases?: IntFieldUpdateOperationsInput | number
    totalStorageQuotaMb?: IntFieldUpdateOperationsInput | number
    usedStorageMb?: IntFieldUpdateOperationsInput | number
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUncheckedUpdateManyWithoutDomainNestedInput
    aliases?: EmailAliasUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type EmailTrackingEventCreateWithoutTrackingInput = {
    id?: string
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    country?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type EmailTrackingEventUncheckedCreateWithoutTrackingInput = {
    id?: string
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    country?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type EmailTrackingEventCreateOrConnectWithoutTrackingInput = {
    where: EmailTrackingEventWhereUniqueInput
    create: XOR<EmailTrackingEventCreateWithoutTrackingInput, EmailTrackingEventUncheckedCreateWithoutTrackingInput>
  }

  export type EmailTrackingEventCreateManyTrackingInputEnvelope = {
    data: EmailTrackingEventCreateManyTrackingInput | EmailTrackingEventCreateManyTrackingInput[]
    skipDuplicates?: boolean
  }

  export type EmailLinkClickCreateWithoutTrackingInput = {
    id?: string
    originalUrl: string
    clickCount?: number
    ipAddress?: string | null
    userAgent?: string | null
    firstClickedAt?: Date | string
    lastClickedAt?: Date | string
  }

  export type EmailLinkClickUncheckedCreateWithoutTrackingInput = {
    id?: string
    originalUrl: string
    clickCount?: number
    ipAddress?: string | null
    userAgent?: string | null
    firstClickedAt?: Date | string
    lastClickedAt?: Date | string
  }

  export type EmailLinkClickCreateOrConnectWithoutTrackingInput = {
    where: EmailLinkClickWhereUniqueInput
    create: XOR<EmailLinkClickCreateWithoutTrackingInput, EmailLinkClickUncheckedCreateWithoutTrackingInput>
  }

  export type EmailLinkClickCreateManyTrackingInputEnvelope = {
    data: EmailLinkClickCreateManyTrackingInput | EmailLinkClickCreateManyTrackingInput[]
    skipDuplicates?: boolean
  }

  export type EmailTrackingEventUpsertWithWhereUniqueWithoutTrackingInput = {
    where: EmailTrackingEventWhereUniqueInput
    update: XOR<EmailTrackingEventUpdateWithoutTrackingInput, EmailTrackingEventUncheckedUpdateWithoutTrackingInput>
    create: XOR<EmailTrackingEventCreateWithoutTrackingInput, EmailTrackingEventUncheckedCreateWithoutTrackingInput>
  }

  export type EmailTrackingEventUpdateWithWhereUniqueWithoutTrackingInput = {
    where: EmailTrackingEventWhereUniqueInput
    data: XOR<EmailTrackingEventUpdateWithoutTrackingInput, EmailTrackingEventUncheckedUpdateWithoutTrackingInput>
  }

  export type EmailTrackingEventUpdateManyWithWhereWithoutTrackingInput = {
    where: EmailTrackingEventScalarWhereInput
    data: XOR<EmailTrackingEventUpdateManyMutationInput, EmailTrackingEventUncheckedUpdateManyWithoutTrackingInput>
  }

  export type EmailTrackingEventScalarWhereInput = {
    AND?: EmailTrackingEventScalarWhereInput | EmailTrackingEventScalarWhereInput[]
    OR?: EmailTrackingEventScalarWhereInput[]
    NOT?: EmailTrackingEventScalarWhereInput | EmailTrackingEventScalarWhereInput[]
    id?: StringFilter<"EmailTrackingEvent"> | string
    trackingId?: StringFilter<"EmailTrackingEvent"> | string
    eventType?: StringFilter<"EmailTrackingEvent"> | string
    ipAddress?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    userAgent?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    device?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    browser?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    country?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    city?: StringNullableFilter<"EmailTrackingEvent"> | string | null
    createdAt?: DateTimeFilter<"EmailTrackingEvent"> | Date | string
  }

  export type EmailLinkClickUpsertWithWhereUniqueWithoutTrackingInput = {
    where: EmailLinkClickWhereUniqueInput
    update: XOR<EmailLinkClickUpdateWithoutTrackingInput, EmailLinkClickUncheckedUpdateWithoutTrackingInput>
    create: XOR<EmailLinkClickCreateWithoutTrackingInput, EmailLinkClickUncheckedCreateWithoutTrackingInput>
  }

  export type EmailLinkClickUpdateWithWhereUniqueWithoutTrackingInput = {
    where: EmailLinkClickWhereUniqueInput
    data: XOR<EmailLinkClickUpdateWithoutTrackingInput, EmailLinkClickUncheckedUpdateWithoutTrackingInput>
  }

  export type EmailLinkClickUpdateManyWithWhereWithoutTrackingInput = {
    where: EmailLinkClickScalarWhereInput
    data: XOR<EmailLinkClickUpdateManyMutationInput, EmailLinkClickUncheckedUpdateManyWithoutTrackingInput>
  }

  export type EmailLinkClickScalarWhereInput = {
    AND?: EmailLinkClickScalarWhereInput | EmailLinkClickScalarWhereInput[]
    OR?: EmailLinkClickScalarWhereInput[]
    NOT?: EmailLinkClickScalarWhereInput | EmailLinkClickScalarWhereInput[]
    id?: StringFilter<"EmailLinkClick"> | string
    trackingId?: StringFilter<"EmailLinkClick"> | string
    originalUrl?: StringFilter<"EmailLinkClick"> | string
    clickCount?: IntFilter<"EmailLinkClick"> | number
    ipAddress?: StringNullableFilter<"EmailLinkClick"> | string | null
    userAgent?: StringNullableFilter<"EmailLinkClick"> | string | null
    firstClickedAt?: DateTimeFilter<"EmailLinkClick"> | Date | string
    lastClickedAt?: DateTimeFilter<"EmailLinkClick"> | Date | string
  }

  export type EmailTrackingCreateWithoutOpensInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: EmailLinkClickCreateNestedManyWithoutTrackingInput
  }

  export type EmailTrackingUncheckedCreateWithoutOpensInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: EmailLinkClickUncheckedCreateNestedManyWithoutTrackingInput
  }

  export type EmailTrackingCreateOrConnectWithoutOpensInput = {
    where: EmailTrackingWhereUniqueInput
    create: XOR<EmailTrackingCreateWithoutOpensInput, EmailTrackingUncheckedCreateWithoutOpensInput>
  }

  export type EmailTrackingUpsertWithoutOpensInput = {
    update: XOR<EmailTrackingUpdateWithoutOpensInput, EmailTrackingUncheckedUpdateWithoutOpensInput>
    create: XOR<EmailTrackingCreateWithoutOpensInput, EmailTrackingUncheckedCreateWithoutOpensInput>
    where?: EmailTrackingWhereInput
  }

  export type EmailTrackingUpdateToOneWithWhereWithoutOpensInput = {
    where?: EmailTrackingWhereInput
    data: XOR<EmailTrackingUpdateWithoutOpensInput, EmailTrackingUncheckedUpdateWithoutOpensInput>
  }

  export type EmailTrackingUpdateWithoutOpensInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: EmailLinkClickUpdateManyWithoutTrackingNestedInput
  }

  export type EmailTrackingUncheckedUpdateWithoutOpensInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: EmailLinkClickUncheckedUpdateManyWithoutTrackingNestedInput
  }

  export type EmailTrackingCreateWithoutClicksInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opens?: EmailTrackingEventCreateNestedManyWithoutTrackingInput
  }

  export type EmailTrackingUncheckedCreateWithoutClicksInput = {
    id?: string
    trackingId: string
    emailId?: string | null
    outboxId?: string | null
    subject: string
    recipientEmail: string
    openCount?: number
    clickCount?: number
    firstOpenedAt?: Date | string | null
    lastOpenedAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    opens?: EmailTrackingEventUncheckedCreateNestedManyWithoutTrackingInput
  }

  export type EmailTrackingCreateOrConnectWithoutClicksInput = {
    where: EmailTrackingWhereUniqueInput
    create: XOR<EmailTrackingCreateWithoutClicksInput, EmailTrackingUncheckedCreateWithoutClicksInput>
  }

  export type EmailTrackingUpsertWithoutClicksInput = {
    update: XOR<EmailTrackingUpdateWithoutClicksInput, EmailTrackingUncheckedUpdateWithoutClicksInput>
    create: XOR<EmailTrackingCreateWithoutClicksInput, EmailTrackingUncheckedCreateWithoutClicksInput>
    where?: EmailTrackingWhereInput
  }

  export type EmailTrackingUpdateToOneWithWhereWithoutClicksInput = {
    where?: EmailTrackingWhereInput
    data: XOR<EmailTrackingUpdateWithoutClicksInput, EmailTrackingUncheckedUpdateWithoutClicksInput>
  }

  export type EmailTrackingUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: EmailTrackingEventUpdateManyWithoutTrackingNestedInput
  }

  export type EmailTrackingUncheckedUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingId?: StringFieldUpdateOperationsInput | string
    emailId?: NullableStringFieldUpdateOperationsInput | string | null
    outboxId?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    openCount?: IntFieldUpdateOperationsInput | number
    clickCount?: IntFieldUpdateOperationsInput | number
    firstOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastOpenedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opens?: EmailTrackingEventUncheckedUpdateManyWithoutTrackingNestedInput
  }

  export type MailboxCreateManyUserInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCreatedByInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    clientId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailboxUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: EmailDomainUpdateOneRequiredWithoutMailboxesNestedInput
    targetAliases?: EmailAliasUpdateManyWithoutTargetMailboxNestedInput
  }

  export type MailboxUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetAliases?: EmailAliasUncheckedUpdateManyWithoutTargetMailboxNestedInput
  }

  export type MailboxUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    items?: DocumentItemUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DocumentItemUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    jobTitle?: string | null
    phone?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    signatureEnabled?: boolean
    signatureStyle?: string
    signatureHtml?: string | null
    linkedinUrl?: string | null
    twitterUrl?: string | null
    instagramUrl?: string | null
    location?: string | null
    officeAddress?: string | null
    mailPassword?: string | null
    totpSecret?: string | null
    totpEnabled?: boolean
    totpBackupCodes?: UserCreatetotpBackupCodesInput | string[]
    totpLastUsed?: Date | string | null
    ssoProvider?: string | null
    ssoExternalId?: string | null
    lastSsoLogin?: Date | string | null
    primaryMailboxId?: string | null
    autoProvisionEmail?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCompanyInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    clientId?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateManyCompanyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    contactPerson?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    country?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCreateManyCompanyInput = {
    id?: string
    name: string
    type: $Enums.DocumentType
    description?: string | null
    isDefault?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssetCreateManyCompanyInput = {
    id?: string
    name: string
    type: $Enums.AssetType
    mimeType: string
    size: number
    url: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mailboxes?: MailboxUncheckedUpdateManyWithoutUserNestedInput
    createdDocuments?: DocumentUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    signatureEnabled?: BoolFieldUpdateOperationsInput | boolean
    signatureStyle?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    officeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    mailPassword?: NullableStringFieldUpdateOperationsInput | string | null
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean
    totpBackupCodes?: UserUpdatetotpBackupCodesInput | string[]
    totpLastUsed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoProvider?: NullableStringFieldUpdateOperationsInput | string | null
    ssoExternalId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSsoLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primaryMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    autoProvisionEmail?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutDocumentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    items?: DocumentItemUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DocumentItemUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumAssetTypeFieldUpdateOperationsInput | $Enums.AssetType
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyClientInput = {
    id?: string
    documentNumber: string
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    issueDate?: Date | string
    dueDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    taxRate?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    terms?: string | null
    pdfUrl?: string | null
    companyId: string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedDocumentsNestedInput
    items?: DocumentItemUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: DocumentItemUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentItemCreateManyDocumentInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type DocumentItemUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentItemUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentItemUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentCreateManyEmailInput = {
    id?: string
    filename: string
    mimeType: string
    size: number
    url?: string | null
    createdAt?: Date | string
  }

  export type EmailAttachmentUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAttachmentUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MailboxCreateManyDomainInput = {
    id?: string
    localPart: string
    displayName?: string | null
    passwordHash: string
    quotaMb?: number
    usedMb?: number
    maxSendPerDay?: number
    sentToday?: number
    lastSentReset?: Date | string
    isActive?: boolean
    isAdmin?: boolean
    autoReply?: boolean
    autoReplySubject?: string | null
    autoReplyMessage?: string | null
    autoReplyStart?: Date | string | null
    autoReplyEnd?: Date | string | null
    forwardingEnabled?: boolean
    forwardingAddress?: string | null
    keepCopy?: boolean
    spamFilterLevel?: string
    spamAction?: string
    signatureHtml?: string | null
    signatureText?: string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAliasCreateManyDomainInput = {
    id?: string
    localPart: string
    targetMailboxId?: string | null
    externalTarget?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainDNSCreateManyDomainInput = {
    id?: string
    recordType: $Enums.DNSRecordType
    name: string
    value: string
    priority?: number | null
    ttl?: number
    description?: string | null
    isRequired?: boolean
    isVerified?: boolean
    lastCheckedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MailboxUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutMailboxesNestedInput
    targetAliases?: EmailAliasUpdateManyWithoutTargetMailboxNestedInput
  }

  export type MailboxUncheckedUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetAliases?: EmailAliasUncheckedUpdateManyWithoutTargetMailboxNestedInput
  }

  export type MailboxUncheckedUpdateManyWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    quotaMb?: IntFieldUpdateOperationsInput | number
    usedMb?: IntFieldUpdateOperationsInput | number
    maxSendPerDay?: IntFieldUpdateOperationsInput | number
    sentToday?: IntFieldUpdateOperationsInput | number
    lastSentReset?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    autoReply?: BoolFieldUpdateOperationsInput | boolean
    autoReplySubject?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyMessage?: NullableStringFieldUpdateOperationsInput | string | null
    autoReplyStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autoReplyEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    forwardingEnabled?: BoolFieldUpdateOperationsInput | boolean
    forwardingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    keepCopy?: BoolFieldUpdateOperationsInput | boolean
    spamFilterLevel?: StringFieldUpdateOperationsInput | string
    spamAction?: StringFieldUpdateOperationsInput | string
    signatureHtml?: NullableStringFieldUpdateOperationsInput | string | null
    signatureText?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetMailbox?: MailboxUpdateOneWithoutTargetAliasesNestedInput
  }

  export type EmailAliasUncheckedUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    targetMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasUncheckedUpdateManyWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    targetMailboxId?: NullableStringFieldUpdateOperationsInput | string | null
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainDNSUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainDNSUncheckedUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainDNSUncheckedUpdateManyWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumDNSRecordTypeFieldUpdateOperationsInput | $Enums.DNSRecordType
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    ttl?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasCreateManyTargetMailboxInput = {
    id?: string
    localPart: string
    externalTarget?: string | null
    isActive?: boolean
    domainId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailAliasUpdateWithoutTargetMailboxInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domain?: EmailDomainUpdateOneRequiredWithoutAliasesNestedInput
  }

  export type EmailAliasUncheckedUpdateWithoutTargetMailboxInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailAliasUncheckedUpdateManyWithoutTargetMailboxInput = {
    id?: StringFieldUpdateOperationsInput | string
    localPart?: StringFieldUpdateOperationsInput | string
    externalTarget?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    domainId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingEventCreateManyTrackingInput = {
    id?: string
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    device?: string | null
    browser?: string | null
    country?: string | null
    city?: string | null
    createdAt?: Date | string
  }

  export type EmailLinkClickCreateManyTrackingInput = {
    id?: string
    originalUrl: string
    clickCount?: number
    ipAddress?: string | null
    userAgent?: string | null
    firstClickedAt?: Date | string
    lastClickedAt?: Date | string
  }

  export type EmailTrackingEventUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingEventUncheckedUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTrackingEventUncheckedUpdateManyWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLinkClickUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLinkClickUncheckedUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLinkClickUncheckedUpdateManyWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    clickCount?: IntFieldUpdateOperationsInput | number
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    firstClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastClickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientCountOutputTypeDefaultArgs instead
     */
    export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentCountOutputTypeDefaultArgs instead
     */
    export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailCountOutputTypeDefaultArgs instead
     */
    export type EmailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailDomainCountOutputTypeDefaultArgs instead
     */
    export type EmailDomainCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailDomainCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MailboxCountOutputTypeDefaultArgs instead
     */
    export type MailboxCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MailboxCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTrackingCountOutputTypeDefaultArgs instead
     */
    export type EmailTrackingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTrackingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyDefaultArgs instead
     */
    export type CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientDefaultArgs instead
     */
    export type ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentItemDefaultArgs instead
     */
    export type DocumentItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateDefaultArgs instead
     */
    export type TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssetDefaultArgs instead
     */
    export type AssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailDefaultArgs instead
     */
    export type EmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailAttachmentDefaultArgs instead
     */
    export type EmailAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailOutboxDefaultArgs instead
     */
    export type EmailOutboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailOutboxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailDomainDefaultArgs instead
     */
    export type EmailDomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailDomainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MailboxDefaultArgs instead
     */
    export type MailboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MailboxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailAliasDefaultArgs instead
     */
    export type EmailAliasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailAliasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DomainDNSDefaultArgs instead
     */
    export type DomainDNSArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DomainDNSDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailLogDefaultArgs instead
     */
    export type EmailLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailQuarantinedDefaultArgs instead
     */
    export type EmailQuarantinedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailQuarantinedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTemplateDefaultArgs instead
     */
    export type EmailTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VacationResponderDefaultArgs instead
     */
    export type VacationResponderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VacationResponderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTrackingDefaultArgs instead
     */
    export type EmailTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailTrackingEventDefaultArgs instead
     */
    export type EmailTrackingEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailTrackingEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailLinkClickDefaultArgs instead
     */
    export type EmailLinkClickArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailLinkClickDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MailMergeDefaultArgs instead
     */
    export type MailMergeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MailMergeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailHostingSettingsDefaultArgs instead
     */
    export type EmailHostingSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailHostingSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MailboxAuditLogDefaultArgs instead
     */
    export type MailboxAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MailboxAuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}